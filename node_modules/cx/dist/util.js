var Console = {
	log: function log() {
		var _console;

		if (typeof window != "undefined" && window.console) (_console = console).log.apply(_console, arguments);
	},
	warn: function warn() {
		var _console2;

		if (typeof window != "undefined" && window.console) (_console2 = console).warn.apply(_console2, arguments);
	}
};

var activeFlags = {
	deprecated: true
};
function debug(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags[flag]) return;
		Console.log.apply(Console, arguments);
	}
}
var Debug = {
	enable: function enable(flag) {
		if (process.env.NODE_ENV !== "production") {
			activeFlags[flag] = true;
		}
	},
	disable: function disable(flag) {
		if (process.env.NODE_ENV !== "production") {
			activeFlags[flag] = false;
		}
	},
	log: debug
};
var renderFlag = "render";
var prepareFlag = "prepare";
var processDataFlag = "process-data";
var cleanupFlag = "cleanup";
var menuFlag = "menu";
var focusFlag = "focus";
var internalFlag = "internal";
var shouldUpdateFlag = "should-update";
var appDataFlag = "app-data";
var tooltipsFlag = "tooltips";
var deprecatedFlag = "deprecated";
var destroyFlag = "destroy";

function isNumber(n) {
	return typeof n === "number";
}

function findFirst(el, condition) {
	if (condition(el)) return el;
	var children = el.childNodes;
	if (children)
		for (var i = 0; i < children.length; i++) {
			var child = findFirst(children[i], condition);
			if (child) return child;
		}
	return null;
}
function findFirstChild(el, condition) {
	var children = el.childNodes;
	if (children)
		for (var i = 0; i < children.length; i++) {
			var child = findFirst(children[i], condition);
			if (child) return child;
		}
	return null;
}
function closest(el, condition) {
	while (el) {
		if (condition(el)) return el;
		el = el.parentNode;
	}

	return null;
}
function closestParent(el, condition) {
	return el && closest(el.parentNode, condition);
}
function isFocused(el) {
	return document.activeElement == el;
}
function isFocusedDeep(el) {
	return document.activeElement == el || (document.activeElement && el.contains(document.activeElement));
}
var focusableWithoutTabIndex = ["INPUT", "SELECT", "TEXTAREA", "A", "BUTTON"];
function isFocusable(el) {
	var firstPass = el && isNumber(el.tabIndex) && el.tabIndex >= 0;
	if (!firstPass) return false;
	if (focusableWithoutTabIndex.indexOf(el.tagName) != -1 && !el.hasAttribute("disabled")) return true;
	return el.hasAttribute("tabindex");
}
function getFocusedElement() {
	return document.activeElement;
}
function isDescendant(el, descEl) {
	return el.contains(descEl);
}
function isSelfOrDescendant(el, descEl) {
	return el == descEl || el.contains(descEl);
}

var globalCacheIdentifier = 1;
var GlobalCacheIdentifier = /*#__PURE__*/ (function() {
	function GlobalCacheIdentifier() {}

	GlobalCacheIdentifier.get = function get() {
		return globalCacheIdentifier;
	};

	GlobalCacheIdentifier.change = function change() {
		globalCacheIdentifier++;
	};

	return GlobalCacheIdentifier;
})();

function isUndefined(v) {
	return v === undefined;
}

function isArray(a) {
	return Array.isArray(a);
}

var defaultFormatter = function defaultFormatter(v) {
	return v.toString();
};

var formatFactory = {
	string: function string() {
		return defaultFormatter;
	},
	wrap: function wrap(part0, prefix, suffix) {
		if (!prefix) prefix = "";
		if (!suffix) suffix = "";
		return function(value) {
			return prefix + value.toString() + suffix;
		};
	},
	fixed: function fixed(part0, digits) {
		return function(value) {
			return value.toFixed(digits);
		};
	},
	prefix: function prefix(part0, _prefix) {
		if (!_prefix) _prefix = "";
		return function(value) {
			return _prefix + value.toString();
		};
	},
	suffix: function suffix(part0, _suffix) {
		if (!_suffix) _suffix = "";
		return function(value) {
			return value.toString() + _suffix;
		};
	},
	uppercase: function uppercase() {
		return function(value) {
			return value.toString().toUpperCase();
		};
	},
	lowercase: function lowercase() {
		return function(value) {
			return value.toString().toLowerCase();
		};
	},
	urlencode: function urlencode() {
		return function(value) {
			return encodeURIComponent(value);
		};
	},
	number: function number(part0, minFractionDigits, maxFractionDigits) {
		var _resolveMinMaxFractio = resolveMinMaxFractionDigits(minFractionDigits, maxFractionDigits),
			minimumFractionDigits = _resolveMinMaxFractio.minimumFractionDigits,
			maximumFractionDigits = _resolveMinMaxFractio.maximumFractionDigits;

		var trimmable = maximumFractionDigits - minimumFractionDigits;

		if (trimmable > 0) {
			if (minimumFractionDigits == 0) ++trimmable;
			return function(value) {
				return trimFractionZeros(value.toFixed(maximumFractionDigits), trimmable);
			};
		}

		return function(value) {
			return value.toFixed(maximumFractionDigits);
		};
	},
	percentage: function percentage(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value * 100) + "%";
		};
	},
	percentageSign: function percentageSign(part0, minFractionDigits, maxFractionDigits) {
		var numberFormatter = formatFactory.number(part0, minFractionDigits, maxFractionDigits);
		return function(value) {
			return numberFormatter(value) + "%";
		};
	},
	date: function date() {
		return function(value) {
			var date = new Date(value);
			return date.getMonth() + 1 + "/" + date.getDate() + "/" + date.getFullYear();
		};
	},
	time: function time() {
		return function(value) {
			var date = new Date(value);
			var h = date.getHours() >= 10 ? date.getHours() : "0" + date.getHours();
			var m = date.getMinutes() >= 10 ? date.getMinutes() : "0" + date.getMinutes();
			return h + ":" + m;
		};
	},
	datetime: function datetime() {
		var date = formatFactory.date();
		var time = formatFactory.time();
		return function(value) {
			return date(value) + " " + time(value);
		};
	},
	ellipsis: function ellipsis(part0, length, where) {
		length = Number(length);
		if (!(length > 3)) length = 10;

		switch (where) {
			default:
			case "end":
				return function(value) {
					var s = String(value);
					if (s.length > length) return s.substring(0, length - 3) + "...";
					return s;
				};

			case "start":
				return function(value) {
					var s = String(value);
					if (s.length > length) return "..." + s.substring(s.length - length + 3);
					return s;
				};

			case "middle":
				return function(value) {
					var s = String(value);

					if (s.length > length) {
						var x = Math.floor(length - 2) / 2;
						return s.substring(0, x) + "..." + s.substring(s.length - (length - 3 - x));
					}

					return s;
				};
		}
	}
};
formatFactory.s = formatFactory.str = formatFactory.string;
formatFactory.f = formatFactory.fixed;
formatFactory.n = formatFactory.number;
formatFactory.p = formatFactory.percentage;
formatFactory.ps = formatFactory.percentageSign;
formatFactory.d = formatFactory.date;
formatFactory.t = formatFactory.time;
formatFactory.dt = formatFactory.datetime;

function buildFormatter(format) {
	var formatter = defaultFormatter,
		nullText = "";

	if (format) {
		var pipeParts = format.split("|");
		nullText = pipeParts[1] || "";
		var colonSepParts = pipeParts[0].split(":");

		for (var i = 0; i < colonSepParts.length; i++) {
			var parts = colonSepParts[i].split(";");
			var factory = formatFactory[parts[0]];
			if (!factory) debug("Unknown string format: " + format);
			else if (i == 0) formatter = factory.apply(void 0, parts);
			else {
				(function() {
					var outerFmt = factory.apply(void 0, parts);
					var innerFmt = formatter;

					formatter = function formatter(v) {
						return outerFmt(innerFmt(v));
					};
				})();
			}
		}
	}

	return function(v) {
		return v == null || v === "" ? nullText : formatter(v);
	};
}

var format = {
	cache: {}
};

function getFormatCache() {
	if (format.cacheIdentifier != GlobalCacheIdentifier.get()) {
		format = {
			cache: {},
			cacheIdentifier: GlobalCacheIdentifier.get()
		};
	}

	return format.cache;
}

function getFormatter(format) {
	if (!format) format = "";
	var formatCache = getFormatCache();
	var formatter = formatCache[format];
	if (!formatter) formatter = formatCache[format] = buildFormatter(format);
	return formatter;
}

var Format = /*#__PURE__*/ (function() {
	function Format() {}

	Format.value = function value(v, format) {
		var formatter = getFormatter(format);
		return formatter(v);
	};

	Format.parse = function parse(format) {
		return getFormatter(format);
	};

	Format.register = function register(format, formatter) {
		this.registerFactory(format, function() {
			return formatter;
		});
	};

	Format.registerFactory = function registerFactory(format, factory) {
		var _this = this;

		if (isArray(format))
			format.forEach(function(f) {
				return _this.registerFactory(f, factory);
			});
		else formatFactory[format] = factory;
	};

	return Format;
})();
function resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits) {
	minimumFractionDigits = minimumFractionDigits != null ? Number(minimumFractionDigits) : minimumFractionDigits;
	maximumFractionDigits = maximumFractionDigits != null ? Number(maximumFractionDigits) : maximumFractionDigits;

	if (isNumber(minimumFractionDigits)) {
		if (isUndefined(maximumFractionDigits)) maximumFractionDigits = minimumFractionDigits;
		else if (isNumber(maximumFractionDigits) && maximumFractionDigits < minimumFractionDigits)
			maximumFractionDigits = minimumFractionDigits;
	} else if (minimumFractionDigits == null && maximumFractionDigits == null) {
		minimumFractionDigits = 0;
		maximumFractionDigits = 18;
	}

	return {
		minimumFractionDigits: minimumFractionDigits,
		maximumFractionDigits: maximumFractionDigits
	};
}
function trimFractionZeros(str, max) {
	var cnt = 0,
		l = str.length;

	while (cnt < max && (str[l - 1 - cnt] === "0" || str[l - 1 - cnt] === ".")) {
		cnt++;
	}

	return cnt > 0 ? str.substring(0, l - cnt) : str;
}

//http://stackoverflow.com/questions/36428283/arrow-function-eval-preprocessor
function expandFatArrows(code) {
	var arrowHeadRegex = RegExp(/(\((?:\w+,)*\w+\)|\(\)|\w+)[\r\t ]*=>\s*/);
	var arrowHeadMatch = arrowHeadRegex.exec(code);

	if (arrowHeadMatch) {
		//if no match return as it is
		var params = arrowHeadMatch[1];

		if (params.charAt(0) !== "(") {
			params = "(" + params + ")";
		}

		var index = arrowHeadMatch.index;
		var startCode = code.substring(0, index);
		var bodyAndNext = code.substring(index + arrowHeadMatch[0].length);
		var curlyCount = 0;
		var curlyPresent = false;
		var singleLineBodyEnd = 0;
		var bodyEnd = 0;

		for (var i = 0; i < bodyAndNext.length; i++) {
			var ch = bodyAndNext[i];

			if (ch === "{") {
				curlyPresent = true;
				curlyCount++;
			} else if (ch === "}") {
				curlyCount--;
			} else if (!curlyPresent) {
				//any character other than { or }
				singleLineBodyEnd = getSingeLineBodyEnd(bodyAndNext, i);
				break;
			}

			if (curlyPresent && curlyCount === 0) {
				bodyEnd = i;
				break;
			}
		}

		var body;

		if (curlyPresent) {
			if (curlyCount !== 0) {
				throw Error("Could not match curly braces for function at : " + index);
			}

			body = bodyAndNext.substring(0, bodyEnd + 1);
			var restCode = bodyAndNext.substring(bodyEnd + 1);
			var expandedFun = "(function " + params + body + ").bind(this)";
			code = startCode + expandedFun + restCode;
		} else {
			if (singleLineBodyEnd <= 0) {
				throw Error("could not get function body at : " + index);
			}

			body = bodyAndNext.substring(0, singleLineBodyEnd + 1);
			restCode = bodyAndNext.substring(singleLineBodyEnd + 1);
			expandedFun = "(function " + params + "{return " + body + "}).bind(this)";
			code = startCode + expandedFun + restCode;
		}

		return expandFatArrows(code); //recursive call
	}

	return code;
}

function getSingeLineBodyEnd(bodyCode, startI) {
	var braceCount = 0;
	var openingQuote = null;

	for (var i = startI; i < bodyCode.length; i++) {
		var ch = bodyCode[i];
		var lastCh = null;

		if (ch === '"' || ch === "'") {
			openingQuote = ch;
			i = skipQuotedString(bodyCode, openingQuote, i);
			ch = bodyCode[i];
		}

		if (i !== 0 && !bodyCode[i - 1].match(/[\t\r ]/)) {
			lastCh = bodyCode[i - 1];
		}

		if (ch === "{" || ch === "(") {
			braceCount++;
		} else if (ch === "}" || ch === ")") {
			braceCount--;
		}

		if (braceCount < 0 || (lastCh !== "." && ch === "\n")) {
			return i - 1;
		}
	}

	return bodyCode.length;
}

function skipQuotedString(bodyAndNext, openingQuote, i) {
	var matchFound = false; //matching quote

	var openingQuoteI = i;
	i++;

	for (; i < bodyAndNext.length; i++) {
		var ch = bodyAndNext[i];
		var lastCh = i !== 0 ? bodyAndNext[i - 1] : null;

		if (ch !== openingQuote || (ch === openingQuote && lastCh === "\\")) {
			continue; //skip quoted string
		} else if (ch === openingQuote) {
			//matched closing quote
			matchFound = false;
			break;
		}
	}

	if (matchFound) {
		throw new Error("Could not find closing quote for quote at : " + openingQuoteI);
	}

	return i;
}

function innerTextTrim(str) {
	str = str.replace(/\t/g, "");
	str = str.replace(/(\s*[\r\n]\s*)/g, "");
	return str;
}

function isDigit(x) {
	return x >= "0" && x <= "9";
}

function isFunction(f) {
	return typeof f === "function";
}

function isObject(o) {
	return o !== null && typeof o === "object";
}

function isPromise(x) {
	return isObject(x) && isFunction(x.then);
}

var isTouch = null;
function isTouchDevice() {
	if (isTouch == null) isTouch = typeof window != "undefined" && "ontouchstart" in window;
	return isTouch;
}

var KeyCode = {
	backspace: 8,
	tab: 9,
	enter: 13,
	shift: 16,
	ctrl: 17,
	alt: 18,
	esc: 27,
	space: 32,
	pageUp: 33,
	pageDown: 34,
	end: 35,
	home: 36,
	left: 37,
	up: 38,
	right: 39,
	down: 40,
	insert: 45,
	delete: 46,
	a: 65
};

function parseStyle(str) {
	if (typeof str != "string") return str;
	var style = {},
		parts = str.split(";");

	for (var i = 0; i < parts.length; i++) {
		var part = parts[i];
		var colonIndex = part.indexOf(":");
		if (colonIndex == -1) continue;
		var name = part.substring(0, colonIndex).trim();
		var value = part.substring(colonIndex + 1).trim(); //avoid css variables

		if (!name.startsWith("--")) {
			name = name
				.split("-")
				.map(function(p, i) {
					return i == 0 ? p : p[0].toUpperCase() + p.substring(1);
				})
				.join("");
		}

		style[name] = value;
	}

	return style;
}

function quoteStr(str) {
	if (str == null) return str;
	return "'" + str.replace(/'/g, "\\i") + "'";
}

function findScrollableParent(sourceEl, horizontal) {
	if (horizontal === void 0) {
		horizontal = false;
	}

	if (!sourceEl) return null;
	var scrollParent = closest(sourceEl, function(el) {
		if (el.nodeType != Node.ELEMENT_NODE) return false;
		if (!horizontal && el.clientHeight >= el.scrollHeight) return false;
		if (horizontal && el.clientWidth >= el.scrollWidth) return false;
		var overflow = getComputedStyle(el)[horizontal ? "overflow-x" : "overflow-y"];
		return overflow == "auto" || overflow == "scroll";
	});
	return scrollParent || sourceEl.ownerDocument.scrollingElement || sourceEl.ownerDocument.documentElement;
}

function getParentFrameBoundingClientRect(el) {
	if (el.ownerDocument != document) {
		var frames = document.getElementsByTagName("iframe");

		for (var i = 0; i < frames.length; i++) {
			if (frames[i].contentDocument == el.ownerDocument) {
				return frames[i].getBoundingClientRect();
			}
		}
	}

	return {
		top: 0,
		left: 0,
		right: window.innerWidth,
		bottom: window.innerHeight,
		width: window.innerWidth,
		height: window.innerHeight
	};
}

function getTopLevelBoundingClientRect(el) {
	var bounds = el.getBoundingClientRect();
	var offset = getParentFrameBoundingClientRect(el);
	return {
		top: bounds.top + offset.top,
		left: bounds.left + offset.left,
		bottom: bounds.bottom + offset.top,
		right: bounds.right + offset.left,
		width: bounds.right - bounds.left,
		height: bounds.bottom - bounds.top
	};
}

function getScrollerBoundingClientRect(scrollEl, topLevel) {
	if (topLevel === void 0) {
		topLevel = false;
	}

	if (scrollEl == scrollEl.ownerDocument.body || scrollEl == scrollEl.ownerDocument.documentElement) {
		if (topLevel) return getParentFrameBoundingClientRect(scrollEl.ownerDocument.body);
		return {
			left: 0,
			top: 0,
			right: window.innerWidth,
			bottom: window.innerHeight,
			width: window.innerWidth,
			height: window.innerHeight
		};
	}

	return topLevel ? getTopLevelBoundingClientRect(scrollEl) : scrollEl.getBoundingClientRect();
}

function scrollElementIntoView(el, vertical, horizontal, inflate) {
	if (vertical === void 0) {
		vertical = true;
	}

	if (horizontal === void 0) {
		horizontal = false;
	}

	if (inflate === void 0) {
		inflate = 0;
	}

	if (horizontal) {
		var parentEl = findScrollableParent(el, true);

		if (parentEl) {
			var pr = getScrollerBoundingClientRect(parentEl);
			var er = el.getBoundingClientRect();
			var scrollbarWidth = parentEl.offsetWidth - parentEl.clientWidth;
			if (er.right + inflate > pr.right - scrollbarWidth)
				parentEl.scrollLeft = Math.max(0, parentEl.scrollLeft + er.right + inflate - pr.right + scrollbarWidth);
			if (er.left - inflate < pr.left)
				parentEl.scrollLeft = Math.max(0, parentEl.scrollLeft + er.left - inflate - pr.left);
		}
	}

	if (vertical) {
		var _parentEl = findScrollableParent(el);

		if (_parentEl) {
			var _pr = getScrollerBoundingClientRect(_parentEl);

			var _er = el.getBoundingClientRect();

			var scrollbarHeight = _parentEl.offsetHeight - _parentEl.clientHeight;
			if (_er.bottom + inflate > _pr.bottom - scrollbarHeight)
				_parentEl.scrollTop = Math.max(0, _parentEl.scrollTop + _er.bottom + inflate - _pr.bottom + scrollbarHeight);
			if (_er.top - inflate < _pr.top)
				_parentEl.scrollTop = Math.max(0, _parentEl.scrollTop + _er.top - inflate - _pr.top);
		}
	}
}

function shallowEquals(v1, v2) {
	if (v1 === v2) return true;
	var t1 = typeof v1,
		t2 = typeof v2,
		k,
		i;
	if (t1 != t2) return false;
	if (v1 == null || v2 == null)
		//this captures undefined too
		return false;

	if (t1 == "object") {
		if (isArray(v1)) {
			if (!isArray(v2) || v1.length != v2.length) return false;

			for (i = 0; i < v1.length; i++) {
				if (!shallowEquals(v1[i], v2[i])) return false;
			}

			return true;
		} else {
			for (k in v1) {
				if (v1.hasOwnProperty(k) && (!v2.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}

			for (k in v2) {
				if (v2.hasOwnProperty(k) && (!v1.hasOwnProperty(k) || v1[k] !== v2[k])) return false;
			}

			return true;
		}
	}

	return v1 === v2;
}

var appLoopFlag = "app-loop";
var vdomRenderFlag = "vdom-render";
var counter = {};
var activeFlags$1 = {};

var nowImpl = function nowImpl() {
	return Date.now();
};

function now() {
	if (process.env.NODE_ENV !== "production") {
		return nowImpl();
	} else {
		return 0;
	}
}

function enable(flag) {
	if (process.env.NODE_ENV !== "production") {
		activeFlags$1[flag] = true;
	}
}

function disable(flag) {
	if (process.env.NODE_ENV !== "production") {
		activeFlags$1[flag] = false;
	}
}

function count(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags$1[flag]) return;
		return (counter[flag] = (counter[flag] || 0) + 1);
	}
}

function log(flag) {
	if (process.env.NODE_ENV !== "production") {
		if (!activeFlags$1[flag]) return;
		Console.log.apply(Console, arguments);
	}
}

if (
	process.env.NODE_ENV !== "production" &&
	typeof window != "undefined" &&
	window.performance &&
	window.performance.now
) {
	nowImpl = function nowImpl() {
		return performance.now();
	};
}

var Timing = {
	now: now,
	enable: enable,
	disable: disable,
	count: count,
	log: log
};

function dateDiff(d1, d2) {
	return d1.getTime() - d2.getTime();
}

function zeroTime(d) {
	return new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function monthStart(d) {
	return new Date(d.getFullYear(), d.getMonth(), 1);
}

function lowerBoundCheck(date, minDate, exclusive) {
	if (exclusive === void 0) {
		exclusive = false;
	}

	var d = dateDiff(date, minDate);
	return d > 0 || (d == 0 && !exclusive);
}

function upperBoundCheck(date, maxDate, exclusive) {
	if (exclusive === void 0) {
		exclusive = false;
	}

	var d = dateDiff(date, maxDate);
	return d < 0 || (d == 0 && !exclusive);
}

function maxDate() {
	var max = arguments[0];

	for (var i = 1; i < arguments.length; i++) {
		if (dateDiff(max, arguments[i]) < 0) max = arguments[i];
	}

	return max;
}

function minDate() {
	var min = arguments[0];

	for (var i = 1; i < arguments.length; i++) {
		if (dateDiff(min, arguments[i]) > 0) min = arguments[i];
	}

	return min;
}

function sameDate(d1, d2) {
	return d1.getDate() == d2.getDate() && d1.getMonth() == d2.getMonth() && d1.getYear() == d2.getYear();
}

//https://stackoverflow.com/questions/17415579/how-to-iso-8601-format-a-date-with-timezone-offset-in-javascript
function pad(num) {
	var norm = Math.floor(Math.abs(num));
	return (norm < 10 ? "0" : "") + norm;
}

function encodeDateWithTimezoneOffset(date) {
	var tzo = -date.getTimezoneOffset(),
		dif = tzo >= 0 ? "+" : "-";
	return (
		date.getFullYear() +
		"-" +
		pad(date.getMonth() + 1) +
		"-" +
		pad(date.getDate()) +
		"T" +
		pad(date.getHours()) +
		":" +
		pad(date.getMinutes()) +
		":" +
		pad(date.getSeconds()) +
		dif +
		pad(tzo / 60) +
		":" +
		pad(tzo % 60)
	);
}

function hue2rgb(p, q, t) {
	if (t < 0) t += 1;
	if (t > 1) t -= 1;
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
}
function hslToRgb(h, s, l) {
	h /= 360;
	s /= 100;
	l /= 100;
	var r, g, b;

	if (s == 0) {
		r = g = b = l; // achromatic
	} else {
		var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		var p = 2 * l - q;
		r = hue2rgb(p, q, h + 1 / 3);
		g = hue2rgb(p, q, h);
		b = hue2rgb(p, q, h - 1 / 3);
	}

	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function parseColor(color) {
	if (!color) return null;
	if (color[0] == "#") return parseHexColor(color);
	if (color.indexOf("rgb") == 0) return parseRgbColor(color);
	if (color.indexOf("hsl") == 0) return parseHslColor(color);
	throw new Error("Unknown color format: " + color + ".");
}
function parseHexColor(color) {
	if (!color) return null;
	if (color[0] != "#") throw new Error("Invalid color " + color + ".");
	if (color.length == 4)
		return {
			type: "rgba",
			r: parseInt(color.charAt(1), 16) * 0x11,
			g: parseInt(color.charAt(2), 16) * 0x11,
			b: parseInt(color.charAt(3), 16) * 0x11,
			a: 1
		};
	if (color.length != 7) throw new Error("Invalid color " + color + ".");
	return {
		type: "rgba",
		r: parseInt(color.substr(1, 2), 16),
		g: parseInt(color.substr(3, 2), 16),
		b: parseInt(color.substr(5, 2), 16),
		a: 1
	};
}
function parseRgbColor(color) {
	if (!color) return null;
	color = color.trim();
	var values;

	if (color.indexOf("rgba(") == 0) {
		values = color
			.substring(5, color.length - 1)
			.split(",")
			.map(function(x) {
				return parseFloat(x.trim());
			});
		if (values.length != 4) throw new Error("Invalid color " + color + ".");
		return {
			type: "rgba",
			r: values[0],
			g: values[1],
			b: values[2],
			a: values[3]
		};
	}

	if (color.indexOf("rgb(") != 0) throw new Error("Invalid color " + color + ".");
	values = color
		.substring(5, color.length - 1)
		.split(",")
		.map(function(x) {
			return parseFloat(x.trim());
		});
	if (values.length != 3) throw new Error("Invalid color " + color + ".");
	return {
		type: "rgba",
		r: values[0],
		g: values[1],
		b: values[2],
		a: 1
	};
}
function parseHslColor(color) {
	if (!color) return null;
	color = color.trim();
	var values;

	if (color.indexOf("hsla(") == 0) {
		values = color
			.substring(5, color.length - 1)
			.split(",")
			.map(function(x) {
				return parseFloat(x.trim());
			});
		if (values.length != 4) throw new Error("Invalid color " + color + ".");
		return {
			type: "hsla",
			h: values[0],
			s: values[1],
			l: values[2],
			a: values[3]
		};
	}

	if (color.indexOf("hsl(") != 0) throw new Error("Invalid color " + color + ".");
	values = color
		.substring(5, color.length - 1)
		.split(",")
		.map(function(x) {
			return parseFloat(x.trim());
		});
	if (values.length != 3) throw new Error("Invalid color " + color + ".");
	return {
		type: "hsla",
		h: values[0],
		s: values[1],
		l: values[2],
		a: 1
	};
}

function componentToHex(c) {
	var hex = c.toString(16);
	return hex.length == 1 ? "0" + hex : hex;
}

function rgbToHex(r, g, b) {
	return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function rgbToHsl(r, g, b) {
	r /= 255;
	g /= 255;
	b /= 255;
	var max = Math.max(r, g, b),
		min = Math.min(r, g, b);
	var h,
		s,
		l = (max + min) / 2;

	if (max == min) {
		h = s = 0; // achromatic
	} else {
		var d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;

			case g:
				h = (b - r) / d + 2;
				break;

			case b:
				h = (r - g) / d + 4;
				break;
		}

		h /= 6;
	}

	return [h * 360, s * 100, l * 100];
}

//shamelessly taken from https://davidwalsh.name/vendor-prefix
var getPrefixes = function getPrefixes() {
	var styles = window.getComputedStyle(document.documentElement, ""),
		pre = (Array.prototype.slice
			.call(styles)
			.join("")
			.match(/-(moz|webkit|ms)-/) ||
			(styles.OLink === "" && ["", "o"]))[1],
		dom = "WebKit|Moz|MS|O".match(new RegExp("(" + pre + ")", "i"))[1];
	return {
		dom: dom,
		lowercase: pre,
		css: "-" + pre + "-",
		js: pre[0].toUpperCase() + pre.substr(1)
	};
};

var prefixes;
function getVendorPrefix(type) {
	if (!prefixes) prefixes = getPrefixes();
	return prefixes[type];
}

var stopPropagation = function stopPropagation(e) {
	return e.stopPropagation();
};
var preventDefault = function preventDefault(e) {
	return e.preventDefault();
};

function escapeSpecialRegexCharacters(s) {
	return s.replace(/[\\^$*+?.()|[\]{}]/g, "\\$&");
}

function getTermsAndRegularExpressions(query) {
	if (!query) return [[], []];
	var terms = query.split(" ").filter(Boolean);
	var regexes = terms.map(function(word) {
		return new RegExp(escapeSpecialRegexCharacters(word), "gi");
	});
	return [terms, regexes];
}

function getSearchQueryPredicate(query, options) {
	var _getTermsAndRegularEx = getTermsAndRegularExpressions(query),
		terms = _getTermsAndRegularEx[0],
		regexes = _getTermsAndRegularEx[1];

	if (terms.length == 0)
		return function() {
			return true;
		};

	if (regexes.length == 1) {
		var regex = regexes[0];
		return function(text) {
			return text && text.match(regex);
		};
	}

	return function(text) {
		return (
			text &&
			regexes.every(function(re) {
				return text.match(re);
			})
		);
	};
}
var highlighterCache = {};
function getSearchQueryHighlighter(query, options) {
	var _getTermsAndRegularEx2 = getTermsAndRegularExpressions(query),
		terms = _getTermsAndRegularEx2[0],
		regexes = _getTermsAndRegularEx2[1];

	if (terms.length == 0)
		return function(text) {
			return [text];
		};
	if (highlighterCache[query]) return highlighterCache[query];

	var result = function result(query) {
		var chunks = [query];

		for (var i = 0; i < regexes.length; i++) {
			var newChunks = [];

			for (var j = 0; j < chunks.length; j++) {
				var at = 0;
				var chunk = chunks[j];
				var parts = chunk.split(regexes[i]);

				for (var k = 0; k < parts.length; k++) {
					newChunks.push(parts[k]);
					at += parts[k].length;

					if (k < parts.length - 1) {
						newChunks.push(chunk.substr(at, terms[i].length));
						at += terms[i].length;
					}
				}
			}

			chunks = newChunks;
		}

		return chunks;
	};

	if (options != null && options.cache) {
		highlighterCache[query] = result;
		setTimeout(function() {
			delete highlighterCache[query];
		}, (options == null ? void 0 : options.cachePeriod) || 5000);
	}

	return result;
}

var passiveEventsSupported = null;
function browserSupportsPassiveEventHandlers() {
	if (passiveEventsSupported == null) {
		try {
			passiveEventsSupported = false;
			var options = Object.defineProperty({}, "passive", {
				get: function get() {
					passiveEventsSupported = true;
				}
			});
			window.addEventListener("test", null, options);
		} catch (e) {}
	}

	return passiveEventsSupported;
}

var lastTouchEvent = 0;
var isTouchDetectionEnabled = false;
function enableTouchEventDetection() {
	if (isTouchDevice() && !isTouchDetectionEnabled) {
		var options;
		if (browserSupportsPassiveEventHandlers())
			options = {
				passive: true
			};
		document.addEventListener(
			"touchstart",
			function() {
				lastTouchEvent = new Date().getTime();
			},
			options
		);
		document.addEventListener(
			"touchmove",
			function() {
				//console.log('TOUCHMOVE');
				lastTouchEvent = new Date().getTime();
			},
			options
		);
		document.addEventListener(
			"touchend",
			function() {
				lastTouchEvent = new Date().getTime(); //console.log('TOUCHEND');
			},
			options
		);
		isTouchDetectionEnabled = true;
	}
}
function isTouchEvent() {
	return isTouchDevice() && (!isTouchDetectionEnabled || new Date().getTime() - lastTouchEvent < 1000);
} //enable touch event detection if there is no performance penalty on scrolling

if (isTouchDevice() && browserSupportsPassiveEventHandlers()) enableTouchEventDetection();

function debounce(callback, delay) {
	var timer;

	var result = function result() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		var context = this;
		clearTimeout(timer);
		timer = setTimeout(function() {
			callback.apply(context, args);
		}, delay);
	};

	result.reset = function reset() {
		clearTimeout(timer);

		for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		callback.apply(this, args);
	};

	return result;
}

function throttle(callback, delay) {
	var timer, context, args;
	return function() {
		context = this;
		args = arguments;
		if (!timer)
			timer = setTimeout(function() {
				callback.apply(context, args);
				timer = null;
			}, delay);
	};
}

var SubscriberList = /*#__PURE__*/ (function() {
	function SubscriberList() {
		this.clear();
	}

	var _proto = SubscriberList.prototype;

	_proto.getSlot = function getSlot() {
		if (this.freeSlots.length) return this.freeSlots.pop();
		var slot = String(this.nextSlot++);
		return slot;
	};

	_proto.recycle = function recycle(slot, callback) {
		if (this.subscriptions[slot] === callback) {
			this.freeSlots.push(slot);
			delete this.subscriptions[slot];
			this.subscriptionCount--;
		}
	};

	_proto.subscribe = function subscribe(callback) {
		var _this = this;

		var slot = this.getSlot();
		this.subscriptions[slot] = callback;
		this.subscriptionCount++;
		return function() {
			_this.recycle(slot, callback);
		};
	};

	_proto.clear = function clear() {
		this.subscriptions = {};
		this.freeSlots = [];
		this.nextSlot = 1;
		this.subscriptionCount = 0;
	};

	_proto.isEmpty = function isEmpty() {
		return this.subscriptionCount == 0;
	};

	_proto.getSubscribers = function getSubscribers() {
		var result = [];

		for (var key in this.subscriptions) {
			result.push(this.subscriptions[key]);
		}

		return result;
	};

	_proto.notify = function notify() {
		for (var key in this.subscriptions) {
			var _this$subscriptions;

			(_this$subscriptions = this.subscriptions)[key].apply(_this$subscriptions, arguments);
		}
	};

	_proto.execute = function execute(callback) {
		for (var key in this.subscriptions) {
			callback(this.subscriptions[key]);
		}
	};

	return SubscriberList;
})();

function isNonEmptyArray(x) {
	return Array.isArray(x) && x.length > 0;
}

function isString(s) {
	return typeof s === "string";
}

function isDefined(v) {
	return v !== undefined;
}

function routeAppend(base, path) {
	var result = base;

	if (path) {
		if (path[0] == "/") {
			if (result[result.length - 1] == "/") result += path.substring(1);
			else result += path;
		} else if (result[result.length - 1] == "/") result += path;
		else result += "/" + path;
	}

	return result;
}

function reverseSlice(array, start) {
	var last = array.length - 1;

	while (start < last) {
		var x = array[start];
		array[start] = array[last];
		array[last] = x;
		start++;
		last--;
	}
}

//IE sometimes returns null while other browsers always return document.body.
function getActiveElement() {
	return document.activeElement || document.body;
}

var componentAlias = {};
var Component = /*#__PURE__*/ (function() {
	function Component(config) {
		if (config && config.$props) {
			Object.assign(config, config.$props);
			delete config.$props;
		}

		Object.assign(this, config);
	}

	Component.alias = function alias(_alias, type) {
		var _this = this;

		if (type) {
			type.prototype.componentAlias = _alias;
			componentAlias[this.namespace + _alias] = type;
		} //decorator usage
		else
			return function(t) {
				_this.alias(_alias, t);

				return t;
			};
	};

	Component.create = function create(typeAlias, config, more) {
		var _this2 = this;

		if (!typeAlias) return this.factory(typeAlias, config, more);
		if (typeAlias.isComponent) return typeAlias;
		if (isComponentFactory(typeAlias)) return this.create(typeAlias.create(config));
		if (isArray(typeAlias))
			return typeAlias.map(function(c) {
				return _this2.create(c, config, more);
			});
		if (typeAlias.$type) return this.create(typeAlias.$type, typeAlias, config);
		if (typeAlias.type) return this.create(typeAlias.type, typeAlias, config);
		var cmpType, alias;
		if (typeAlias.isComponentType) cmpType = typeAlias;
		else if (isFunction(typeAlias)) {
			if (this.factory) return this.factory(typeAlias, config, more);
			throw new Error("Unsupported component type " + typeAlias + ".");
		} else if (isString(typeAlias)) {
			alias = this.namespace + typeAlias;
			cmpType = componentAlias[alias];

			if (!cmpType) {
				if (typeAlias && this.factory) return this.factory(typeAlias, config, more);
				throw new Error("Unknown component alias " + alias + ".");
			}
		} else if (typeof typeAlias == "object") {
			cmpType = typeAlias.type || typeAlias.$type;

			if (!cmpType) {
				cmpType = this;
				more = more ? Object.assign({}, config, more) : config;
				config = typeAlias;
			}
		}
		if (isArray(config))
			return config.map(function(cfg) {
				return _this2.create(cmpType, cfg, more);
			});
		var cfg = config;
		if (more) cfg = Object.assign({}, config, more);
		var cmp = new cmpType(cfg);
		if (cmpType.autoInit && cmp.init) cmp.init();
		return cmp;
	};

	return Component;
})();
Component.prototype.isComponent = true;
Component.isComponentType = true;
Component.namespace = "";
Component.autoInit = false;

Component.factory = function(alias, config, more) {
	throw new Error("Unknown component alias " + alias + ".");
};

function createComponentFactory(factory, jsxDriver, meta) {
	factory.$isComponentFactory = true;
	factory.$meta = meta;
	factory.create = jsxDriver;
	return factory;
}
function isComponentFactory(factory) {
	return factory && factory.$isComponentFactory;
}

function onIdleCallback(callback, options) {
	var token = null;
	if (typeof requestIdleCallback == "function") token = requestIdleCallback(callback, options);
	else token = setTimeout(callback, 1);
	return function() {
		if (typeof cancelIdleCallback == "function") cancelIdleCallback(token);
		else clearTimeout(token);
	};
}

function validatedDebounce(callback, valueGetter, delay) {
	var timer;

	var result = function result() {
		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		clearTimeout(timer);
		var prev = valueGetter();
		timer = setTimeout(function() {
			var now = valueGetter();
			if (prev !== now) return;
			callback.apply(void 0, args);
		}, delay);
	};

	result.reset = function reset() {
		clearTimeout(timer);
		callback.apply(void 0, arguments);
	};

	return result;
}

function addEventListenerWithOptions(element, event, callback, options) {
	var thirdParam = browserSupportsPassiveEventHandlers() ? options : options.capture === true;
	element.addEventListener(event, callback, thirdParam);
	return function() {
		element.removeEventListener(event, callback, thirdParam);
	};
}

function coalesce() {
	for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	for (var i = 0; i < args.length; i++) {
		if (args[i] != null) return args[i];
	}

	return null;
}

function dummyCallback() {}

function calculateNaturalElementHeight(el) {
	if (el.scrollHeight > el.clientHeight) return naturalElementHeight(el);
	var h = el.offsetHeight;

	for (var i = 0; i < el.children.length; i++) {
		var child = el.children[i];

		if (child.scrollHeight > child.clientHeight) {
			h -= child.offsetHeight;
			h += naturalElementHeight(child);
		}
	}

	return h;
}

function naturalElementHeight(el) {
	var h = el.offsetHeight;
	var overflow = el.scrollHeight - el.clientHeight;
	if (overflow <= 0) return h;
	var computedStyle = getComputedStyle(el);
	var maxH = parseFloat(computedStyle.getPropertyValue("max-height"));
	if (!isNaN(maxH)) return Math.min(parseFloat(maxH), h + overflow);
	return h + overflow;
}

function isTextInputElement(el) {
	return el.tagName == "INPUT" || el.tagName == "TEXTAREA";
}

var TraversalStack = /*#__PURE__*/ (function() {
	function TraversalStack() {
		this.data = [];
	}

	var _proto = TraversalStack.prototype;

	_proto.push = function push(node) {
		if (this.data.length == 0) this.hop();
		this.data[this.data.length - 1].elements.push(node);
	};

	_proto.hop = function hop() {
		this.data.push({
			elements: [],
			index: 0
		});
	};

	_proto.pop = function pop() {
		while (this.data.length > 0) {
			var line = this.data[this.data.length - 1];

			if (line.index < line.elements.length) {
				line.index++;
				return line.elements[line.index - 1];
			}

			this.data.pop();
		}

		return null;
	};

	_proto.empty = function empty() {
		while (this.data.length > 0) {
			var line = this.data[this.data.length - 1];
			if (line.index < line.elements.length) return false;
			this.data.pop();
		}

		return true;
	};

	return TraversalStack;
})();

export {
	Component,
	Console,
	Debug,
	Format,
	GlobalCacheIdentifier,
	KeyCode,
	SubscriberList,
	Timing,
	TraversalStack,
	addEventListenerWithOptions,
	appDataFlag,
	appLoopFlag,
	browserSupportsPassiveEventHandlers,
	calculateNaturalElementHeight,
	cleanupFlag,
	closest,
	closestParent,
	coalesce,
	createComponentFactory,
	dateDiff,
	debounce,
	debug,
	deprecatedFlag,
	destroyFlag,
	dummyCallback,
	enableTouchEventDetection,
	encodeDateWithTimezoneOffset,
	escapeSpecialRegexCharacters,
	expandFatArrows,
	findFirst,
	findFirstChild,
	findScrollableParent,
	focusFlag,
	getActiveElement,
	getFocusedElement,
	getParentFrameBoundingClientRect,
	getScrollerBoundingClientRect,
	getSearchQueryHighlighter,
	getSearchQueryPredicate,
	getTopLevelBoundingClientRect,
	getVendorPrefix,
	hslToRgb,
	innerTextTrim,
	internalFlag,
	isArray,
	isComponentFactory,
	isDefined,
	isDescendant,
	isDigit,
	isFocusable,
	isFocused,
	isFocusedDeep,
	isFunction,
	isNonEmptyArray,
	isNumber,
	isObject,
	isPromise,
	isSelfOrDescendant,
	isString,
	isTextInputElement,
	isTouchDevice,
	isTouchEvent,
	isUndefined,
	lowerBoundCheck,
	maxDate,
	menuFlag,
	minDate,
	monthStart,
	now,
	onIdleCallback,
	parseColor,
	parseHexColor,
	parseHslColor,
	parseRgbColor,
	parseStyle,
	prepareFlag,
	preventDefault,
	processDataFlag,
	quoteStr,
	renderFlag,
	resolveMinMaxFractionDigits,
	reverseSlice,
	rgbToHex,
	rgbToHsl,
	routeAppend,
	sameDate,
	scrollElementIntoView,
	shallowEquals,
	shouldUpdateFlag,
	stopPropagation,
	throttle,
	tooltipsFlag,
	trimFractionZeros,
	upperBoundCheck,
	validatedDebounce,
	vdomRenderFlag,
	zeroTime
};
