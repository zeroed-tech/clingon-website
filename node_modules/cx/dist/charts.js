import {
	PureContainer,
	getContent,
	Widget,
	Selection,
	withHoverSync,
	Container,
	VDOM,
	CSS,
	Format as Format$1
} from "cx/ui";
import {
	isNumber,
	isArray,
	isUndefined,
	parseStyle,
	shallowEquals,
	debug,
	isDefined,
	stopPropagation,
	closest,
	getTopLevelBoundingClientRect,
	Format,
	zeroTime
} from "cx/util";
import { jsx, jsxs } from "react/jsx-runtime";
import {
	tooltipMouseMove,
	tooltipMouseLeave,
	HtmlElement,
	captureMouseOrTouch,
	getCursorPos,
	tooltipParentWillUnmount,
	tooltipParentWillReceiveProps,
	tooltipParentDidMount
} from "cx/widgets";

function _defineProperty(obj, key, value) {
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}

	return obj;
}

function ownKeys(object, enumerableOnly) {
	var keys = Object.keys(object);

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object);
		if (enumerableOnly)
			symbols = symbols.filter(function(sym) {
				return Object.getOwnPropertyDescriptor(object, sym).enumerable;
			});
		keys.push.apply(keys, symbols);
	}

	return keys;
}

function _objectSpread2(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};

		if (i % 2) {
			ownKeys(Object(source), true).forEach(function(key) {
				_defineProperty(target, key, source[key]);
			});
		} else if (Object.getOwnPropertyDescriptors) {
			Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
		} else {
			ownKeys(Object(source)).forEach(function(key) {
				Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
			});
		}
	}

	return target;
}

function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;

	_setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
	_setPrototypeOf =
		Object.setPrototypeOf ||
		function _setPrototypeOf(o, p) {
			o.__proto__ = p;
			return o;
		};

	return _setPrototypeOf(o, p);
}

var Rect = /*#__PURE__*/ (function() {
	function Rect(config) {
		Object.assign(this, config);
	}

	var _proto = Rect.prototype;

	_proto.width = function width() {
		return this.r - this.l;
	};

	_proto.height = function height() {
		return this.b - this.t;
	};

	_proto.valid = function valid() {
		return this.r > this.l && this.b > this.t;
	};

	_proto.makeValid = function makeValid() {
		return new Rect({
			l: Math.min(this.l, this.r),
			r: Math.max(this.l, this.r),
			t: Math.min(this.t, this.b),
			b: Math.max(this.t, this.b)
		});
	};

	_proto.isEqual = function isEqual(r) {
		if (!r || !r.isRect) return false;
		return r.l == this.l && r.r == this.r && r.t == this.t && r.b == this.b;
	};

	Rect.add = function add(a, b) {
		return new Rect({
			l: a.l + b.l,
			t: a.t + b.t,
			r: a.r + b.r,
			b: a.b + b.b
		});
	};

	Rect.multiply = function multiply(a, b) {
		return new Rect({
			l: a.l + (a.r - a.l) * b.l,
			r: a.l + (a.r - a.l) * b.r,
			t: a.t + (a.b - a.t) * b.t,
			b: a.t + (a.b - a.t) * b.b
		});
	};

	Rect.margin = function margin(r, m) {
		var mr = Rect.convertMargin(m);
		return Rect.add(r, mr);
	};

	Rect.convertMargin = function convertMargin(m) {
		if (!m) return new Rect();
		if (m.isRect) return m;
		if (isNumber(m))
			return new Rect({
				l: m,
				t: m,
				r: -m,
				b: -m
			});
		var m = Rect.convert(m);
		m.b = -m.b;
		m.r = -m.r;
		return m;
	};

	Rect.convert = function convert(r) {
		if (!r)
			return new Rect({
				l: 0,
				r: 0,
				t: 0,
				b: 0
			});
		if (r.isRect) return r;
		if (typeof r === "string") r = r.split(" ");

		if (isArray(r)) {
			return new Rect({
				t: parseFloat(r[0]),
				r: parseFloat(r[1]),
				b: parseFloat(r[2]),
				l: parseFloat(r[3])
			});
		}

		return new Rect(r);
	};

	return Rect;
})();
Rect.prototype.isRect = true;
Rect.prototype.l = 0; //left;

Rect.prototype.r = 0; //right

Rect.prototype.t = 0; //top

Rect.prototype.b = 0; //bottom

var BoundedObject = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(BoundedObject, _PureContainer);

	function BoundedObject() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = BoundedObject.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[
				this,
				{
					anchors: undefined,
					offset: undefined,
					margin: undefined,
					padding: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		_PureContainer.prototype.prepareData.call(this, context, instance);

		var data = instance.data;
		data.anchors = Rect.convert(data.anchors);
		data.offset = Rect.convert(data.offset);
		data.margin = Rect.convertMargin(data.margin);
		data.padding = Rect.convertMargin(data.padding);
	};

	_proto.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data;
		return Rect.add(Rect.add(Rect.multiply(instance.parentRect, data.anchors), data.offset), data.margin);
	};

	_proto.prepareBounds = function prepareBounds(context, instance) {
		var data = instance.data;

		if (
			instance.shouldUpdate ||
			!instance.cached.parentRect ||
			!instance.cached.parentRect.isEqual(context.parentRect) ||
			!data.bounds
		) {
			if (!context.parentRect) throw new Error("Parent bounds were not provided through the context.");
			instance.parentRect = context.parentRect;
			instance.cache("parentRect", context.parentRect);
			instance.markShouldUpdate(context);
			data.bounds = this.calculateBounds(context, instance);
			data.childrenBounds = Rect.add(data.bounds, data.padding);
		}
	};

	_proto.prepare = function prepare(context, instance) {
		this.prepareBounds(context, instance);
		context.push("parentRect", instance.data.childrenBounds);
	};

	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("parentRect");
	};

	return BoundedObject;
})(PureContainer);
BoundedObject.prototype.anchors = 0;
BoundedObject.prototype.margin = 0;
BoundedObject.prototype.offset = 0;
BoundedObject.prototype.padding = 0;
BoundedObject.prototype.isPureContainer = false;
BoundedObject.prototype.styled = true;

var Axis = /*#__PURE__*/ (function(_BoundedObject) {
	_inheritsLoose(Axis, _BoundedObject);

	function Axis() {
		return _BoundedObject.apply(this, arguments) || this;
	}

	var _proto = Axis.prototype;

	_proto.init = function init() {
		if (this.labelAnchor == "auto") this.labelAnchor = this.vertical ? (this.secondary ? "start" : "end") : "middle";
		if (this.labelDx == "auto") this.labelDx = 0;
		if (this.labelDy == "auto") this.labelDy = this.vertical ? "0.4em" : this.secondary ? 0 : "0.8em";
		if (isUndefined(this.minLabelDistance))
			this.minLabelDistance = this.vertical ? this.minLabelDistanceVertical : this.minLabelDistanceHorizontal;
		if (this.labelLineCountDyFactor == "auto")
			this.labelLineCountDyFactor = this.vertical ? -0.5 : this.secondary ? -1 : 0;
		this.lineStyle = parseStyle(this.lineStyle);
		this.tickStyle = parseStyle(this.tickStyle);
		this.labelStyle = parseStyle(this.labelStyle);

		_BoundedObject.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _BoundedObject$protot;

		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[
				this,
				{
					anchors: undefined,
					hideLabels: undefined,
					hideLine: undefined,
					hideTicks: undefined,
					labelRotation: undefined,
					labelAnchor: undefined,
					lineStyle: undefined,
					lineClass: undefined,
					labelStyle: undefined,
					labelClass: undefined,
					tickStyle: undefined,
					tickClass: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.report = function report(context, instance) {
		return instance.calculator;
	};

	_proto.renderTicksAndLabels = function renderTicksAndLabels(context, instance, valueFormatter) {
		var _this = this;

		if (this.hidden) return false;
		var data = instance.data,
			calculator = instance.calculator;
		var bounds = data.bounds;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var size = calculator.findTickSize(this.minLabelDistance);
		var labelClass = CSS.expand(CSS.element(baseClass, "label"), data.labelClass);
		var offsetClass = CSS.element(baseClass, "label-offset");
		var x1,
			y1,
			x2,
			y2,
			tickSize = this.tickSize;

		if (this.vertical) {
			x1 = x2 = this.secondary ? bounds.r : bounds.l;
			y1 = bounds.b;
			y2 = bounds.t;
		} else {
			x1 = bounds.l;
			x2 = bounds.r;
			y1 = y2 = this.secondary ? bounds.t : bounds.b;
		}

		var res = [null, null];

		if (!data.hideLine) {
			res[0] = /*#__PURE__*/ jsx(
				"line",
				{
					className: CSS.expand(CSS.element(baseClass, "line"), data.lineClass),
					style: data.lineStyle,
					x1: x1,
					y1: y1,
					x2: x2,
					y2: y2
				},
				"line"
			);
		}

		var t = [];

		if (size > 0 && !data.hideLabels) {
			var ticks = calculator.getTicks([size]);
			ticks.forEach(function(serie, si) {
				serie.forEach(function(v, i) {
					var s = calculator.map(v);

					if (_this.secondary) {
						x1 = _this.vertical ? bounds.r : s;
						y1 = _this.vertical ? s : bounds.t;
						x2 = _this.vertical ? bounds.r + tickSize : s;
						y2 = _this.vertical ? s : bounds.t - tickSize;
					} else {
						x1 = _this.vertical ? bounds.l : s;
						y1 = _this.vertical ? s : bounds.b;
						x2 = _this.vertical ? bounds.l - tickSize : s;
						y2 = _this.vertical ? s : bounds.b + tickSize;
					}

					t.push("M " + x1 + " " + y1 + " L " + x2 + " " + y2);
					var x, y;

					if (_this.secondary) {
						x = _this.vertical ? bounds.r + _this.labelOffset : s;
						y = _this.vertical ? s : bounds.t - _this.labelOffset;
					} else {
						x = _this.vertical ? bounds.l - _this.labelOffset : s;
						y = _this.vertical ? s : bounds.b + _this.labelOffset;
					}

					var transform = data.labelRotation ? "rotate(" + data.labelRotation + " " + x + " " + y + ")" : null;
					res.push(
						/*#__PURE__*/ jsx(
							"text",
							{
								className: labelClass,
								style: data.labelStyle,
								x: x,
								y: y,
								dx: _this.labelDx,
								textAnchor: data.labelAnchor,
								transform: transform,
								children: _this.wrapLines(valueFormatter(v), x, _this.labelDy, offsetClass)
							},
							"label-" + si + "-" + i
						)
					);
				});
			});
		}

		if (!data.hideTicks) {
			res[1] = /*#__PURE__*/ jsx(
				"path",
				{
					className: CSS.expand(CSS.element(baseClass, "ticks"), data.tickClass),
					style: data.tickStyle,
					d: t.join(" ")
				},
				"ticks"
			);
		}

		return res;
	};

	_proto.wrapLines = function wrapLines(str, x, dy, offsetClass) {
		if (!this.labelWrap || typeof str != "string")
			return /*#__PURE__*/ jsx("tspan", {
				x: x,
				dy: dy,
				children: str
			});
		var parts = str.split(" ");
		if (parts.length == 0) return null;
		var lines = [];
		var line = null;

		for (var i = 0; i < parts.length; i++) {
			if (!line) line = parts[i];
			else if (parts[i].length + line.length < this.labelMaxLineLength) line += " " + parts[i];
			else {
				lines.push(line);
				line = parts[i];
			}
		}

		lines.push(line);
		if (lines.length == 1)
			return /*#__PURE__*/ jsx("tspan", {
				x: x,
				dy: dy,
				children: str
			});
		var offset = this.labelLineCountDyFactor * (lines.length - 1);
		var result = [
			dy != null &&
				/*#__PURE__*/ jsx(
					"tspan",
					{
						className: offsetClass,
						dy: dy,
						children: "_"
					},
					-2
				)
		];
		lines.forEach(function(p, i) {
			result.push(
				/*#__PURE__*/ jsx(
					"tspan",
					{
						dy: (i == 0 ? offset : 1) + "em",
						x: x,
						children: p
					},
					i
				)
			);
		});
		return result;
	};

	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);

		var bounds = instance.data.bounds;

		var _ref = !this.vertical ? [bounds.l, bounds.r] : [bounds.b, bounds.t],
			a = _ref[0],
			b = _ref[1];

		instance.calculator.measure(a, b);
		if (this.onMeasured) instance.invoke("onMeasured", instance.calculator.hash(), instance);
		if (!instance.calculator.isSame(instance.cached.axis)) instance.markShouldUpdate(context);
	};

	_proto.cleanup = function cleanup(context, instance) {
		var cached = instance.cached,
			calculator = instance.calculator;
		cached.axis = calculator.hash();
	};

	return Axis;
})(BoundedObject);
Axis.prototype.anchors = "0 1 1 0";
Axis.prototype.styled = true;
Axis.prototype.vertical = false;
Axis.prototype.secondary = false;
Axis.prototype.inverted = false;
Axis.prototype.hidden = false;
Axis.prototype.hideLabels = false;
Axis.prototype.hideTicks = false;
Axis.prototype.hideLine = false;
Axis.prototype.tickSize = 3;
Axis.prototype.minTickDistance = 25;
Axis.prototype.minLabelDistanceVertical = 40;
Axis.prototype.minLabelDistanceHorizontal = 50;
Axis.prototype.labelOffset = 10;
Axis.prototype.labelRotation = 0;
Axis.prototype.labelAnchor = "auto";
Axis.prototype.labelDx = "auto";
Axis.prototype.labelDy = "auto";
Axis.prototype.labelWrap = false;
Axis.prototype.labelLineCountDyFactor = "auto";
Axis.prototype.labelMaxLineLength = 10;
Axis.namespace = "ui.svg.chart.axis";

var Chart = /*#__PURE__*/ (function(_BoundedObject) {
	_inheritsLoose(Chart, _BoundedObject);

	function Chart() {
		return _BoundedObject.apply(this, arguments) || this;
	}

	var _proto = Chart.prototype;

	_proto.init = function init() {
		_BoundedObject.prototype.init.call(this);

		if (!this.axes) this.axes = {};

		for (var axis in this.axes) {
			this.axes[axis] = Axis.create(this.axes[axis]);
		}
	};

	_proto.explore = function explore(context, instance) {
		instance.calculators = _objectSpread2({}, context.axes);
		context.push("axes", instance.calculators);
		instance.axes = {}; //axes need to be registered before children to be processed first

		for (var axis in this.axes) {
			var axisInstance = instance.getChild(context, this.axes[axis]);

			if (axisInstance.scheduleExploreIfVisible(context)) {
				instance.axes[axis] = axisInstance;
				instance.calculators[axis] = this.axes[axis].report(context, axisInstance);
			}
		}

		_BoundedObject.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("axes");
	};

	_proto.prepare = function prepare(context, instance) {
		context.push("axes", instance.calculators);

		_BoundedObject.prototype.prepare.call(this, context, instance);
	};

	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("axes");

		_BoundedObject.prototype.prepareCleanup.call(this, context, instance);
	};

	_proto.render = function render(context, instance, key) {
		var axes = [];

		for (var k in instance.axes) {
			axes.push(getContent(instance.axes[k].render(context, key + "-axis-" + k)));
		}

		var result = [];
		if (!this.axesOnTop) result.push(axes);
		result.push(this.renderChildren(context, instance));
		if (this.axesOnTop) result.push(axes);
		return result;
	};

	return Chart;
})(BoundedObject);
Chart.prototype.anchors = "0 1 1 0";
Chart.prototype.styled = true;
Chart.prototype.isPureContainer = true;
Chart.prototype.axesOnTop = false;
Widget.alias("chart", Chart);

var PieChart = /*#__PURE__*/ (function(_BoundedObject) {
	_inheritsLoose(PieChart, _BoundedObject);

	function PieChart() {
		return _BoundedObject.apply(this, arguments) || this;
	}

	var _proto = PieChart.prototype;

	_proto.declareData = function declareData() {
		var _BoundedObject$protot;

		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					angle: undefined,
					startAngle: 0,
					clockwise: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		if (!instance.pie) instance.pie = new PieCalculator();
		var data = instance.data;
		instance.pie.reset(data.angle, data.startAngle, data.clockwise);
		context.push("pie", instance.pie);

		_BoundedObject.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("pie");
	};

	_proto.prepare = function prepare(context, instance) {
		this.prepareBounds(context, instance);
		var data = instance.data,
			pie = instance.pie;
		pie.measure(data.bounds);
		var hash = pie.hash();
		instance.cache("hash", hash);
		pie.shouldUpdate = !shallowEquals(hash, instance.cached.hash);
		if (!pie.shouldUpdate) instance.markShouldUpdate(context);

		_BoundedObject.prototype.prepare.call(this, context, instance);
	};

	return PieChart;
})(BoundedObject);
PieChart.prototype.anchors = "0 1 1 0";

var PieCalculator = /*#__PURE__*/ (function() {
	function PieCalculator() {}

	var _proto2 = PieCalculator.prototype;

	_proto2.reset = function reset(angle, startAngle, clockwise) {
		this.angleTotal = (angle / 180) * Math.PI;
		this.startAngle = (startAngle / 180) * Math.PI;
		this.clockwise = clockwise;
		this.stacks = {};
	};

	_proto2.acknowledge = function acknowledge(stack, value) {
		var s = this.stacks[stack];
		if (!s)
			s = this.stacks[stack] = {
				total: 0
			};
		if (value > 0) s.total += value;
	};

	_proto2.hash = function hash() {
		var _this = this;

		return {
			angleTotal: this.angleTotal,
			startAngle: this.startAngle,
			clockwise: this.clockwise,
			stacks: Object.keys(this.stacks)
				.map(function(s) {
					return "" + _this.stacks[s].angleFactor;
				})
				.join(":"),
			cx: this.cx,
			cy: this.cy,
			R: this.R
		};
	};

	_proto2.measure = function measure(rect) {
		for (var s in this.stacks) {
			var stack = this.stacks[s];
			stack.angleFactor = stack.total > 0 ? this.angleTotal / stack.total : 0;
			stack.lastAngle = this.startAngle;
		}

		this.cx = (rect.l + rect.r) / 2;
		this.cy = (rect.t + rect.b) / 2;
		this.R = Math.max(0, Math.min(rect.width(), rect.height())) / 2;
	};

	_proto2.map = function map(stack, value) {
		var s = this.stacks[stack];
		var angle = value * s.angleFactor;
		var startAngle = s.lastAngle;
		if (!this.clockwise) s.lastAngle += angle;
		else s.lastAngle -= angle;
		return {
			startAngle: startAngle,
			endAngle: s.lastAngle,
			midAngle: (startAngle + s.lastAngle) / 2,
			cx: this.cx,
			cy: this.cy,
			R: this.R
		};
	};

	return PieCalculator;
})();

function createSvgArc(x, y, r0, r, startAngle, endAngle) {
	if (startAngle > endAngle) {
		var s = startAngle;
		startAngle = endAngle;
		endAngle = s;
	}

	var largeArc = endAngle - startAngle <= Math.PI ? 0 : 1;
	if (endAngle - startAngle >= 2 * Math.PI - 0.0001) endAngle = startAngle + 2 * Math.PI - 0.0001;
	var result = [];
	var startX, startY;

	if (r0 > 0) {
		startX = x + Math.cos(endAngle) * r0;
		startY = y - Math.sin(endAngle) * r0;
		result.push("M", startX, startY);
		result.push("A", r0, r0, 0, largeArc, 1, x + Math.cos(startAngle) * r0, y - Math.sin(startAngle) * r0);
	} else {
		startX = x;
		startY = y;
		result.push("M", startX, startY);
	}

	result.push(
		"L",
		x + Math.cos(startAngle) * r,
		y - Math.sin(startAngle) * r,
		"A",
		r,
		r,
		0,
		largeArc,
		0,
		x + Math.cos(endAngle) * r,
		y - Math.sin(endAngle) * r,
		"L",
		startX,
		startY
	);
	return result.join(" ");
}

PieChart.prototype.anchors = "0 1 1 0";
PieChart.prototype.angle = 360;
Widget.alias("pie-slice");
var PieSlice = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(PieSlice, _Container);

	function PieSlice() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto3 = PieSlice.prototype;

	_proto3.init = function init() {
		this.selection = Selection.create(this.selection);

		_Container.prototype.init.call(this);
	};

	_proto3.declareData = function declareData() {
		var _Container$prototype$;

		var selection = this.selection.configureWidget(this);

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					active: true,
					r0: undefined,
					r: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					offset: undefined,
					value: undefined,
					disabled: undefined,
					innerPointRadius: undefined,
					outerPointRadius: undefined,
					name: undefined,
					stack: undefined,
					legend: undefined,
					hoverId: undefined
				}
			])
		);
	};

	_proto3.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;

		_Container.prototype.prepareData.call(this, context, instance);
	};

	_proto3.explore = function explore(context, instance) {
		instance.pie = context.pie;
		if (!instance.pie) throw new Error("Pie.Slice must be placed inside a Pie.");
		var data = instance.data;
		instance.valid = isNumber(data.value) && data.value > 0;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		instance.hoverSync = context.hoverSync;

		if (instance.valid && data.active) {
			instance.pie.acknowledge(data.stack, data.value);

			_Container.prototype.explore.call(this, context, instance);
		}
	};

	_proto3.prepare = function prepare(context, instance) {
		var _this2 = this;

		var data = instance.data,
			segment = instance.segment,
			pie = instance.pie,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (instance.valid && data.active) {
			var seg = pie.map(data.stack, data.value);

			if (
				!segment ||
				instance.shouldUpdate ||
				seg.startAngle != segment.startAngle ||
				seg.endAngle != segment.endAngle ||
				pie.shouldUpdate
			) {
				if (data.offset > 0) {
					seg.ox = seg.cx + Math.cos(seg.midAngle) * data.offset;
					seg.oy = seg.cy - Math.sin(seg.midAngle) * data.offset;
				} else {
					seg.ox = seg.cx;
					seg.oy = seg.cy;
				}

				seg.radiusMultiplier = 1;
				if (this.percentageRadius) seg.radiusMultiplier = seg.R / 100;
				var innerR = data.innerPointRadius != null ? data.innerPointRadius : data.r0;
				var outerR = data.outerPointRadius != null ? data.outerPointRadius : data.r;
				var ix = seg.ox + Math.cos(seg.midAngle) * innerR * seg.radiusMultiplier;
				var iy = seg.oy - Math.sin(seg.midAngle) * innerR * seg.radiusMultiplier;
				var ox = seg.ox + Math.cos(seg.midAngle) * outerR * seg.radiusMultiplier;
				var oy = seg.oy - Math.sin(seg.midAngle) * outerR * seg.radiusMultiplier;
				instance.segment = seg;
				instance.bounds = new Rect({
					l: ix,
					r: ox,
					t: iy,
					b: oy
				});
				instance.markShouldUpdate(context);
			}

			context.push("parentRect", instance.bounds);
		}

		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				hoverId: data.hoverId,
				hoverChannel: this.hoverChannel,
				hoverSync: instance.hoverSync,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				}
			});
	};

	_proto3.prepareCleanup = function prepareCleanup(context, instance) {
		if (instance.valid && instance.data.active) {
			context.pop("parentRect");
		}
	};

	_proto3.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};

	_proto3.render = function render(context, instance, key) {
		var _this3 = this;

		var segment = instance.segment,
			data = instance.data;
		if (!instance.valid || !data.active) return null;
		return withHoverSync(key, instance.hoverSync, this.hoverChannel, data.hoverId, function(_ref) {
			var _stateMods;

			var hover = _ref.hover,
				_onMouseMove = _ref.onMouseMove,
				_onMouseLeave = _ref.onMouseLeave;
			var stateMods =
				((_stateMods = {
					selected: _this3.selection.isInstanceSelected(instance),
					disabled: data.disabled,
					selectable: !_this3.selection.isDummy
				}),
				(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
				(_stateMods.hover = hover),
				_stateMods);
			var d = createSvgArc(
				segment.ox,
				segment.oy,
				data.r0 * segment.radiusMultiplier,
				data.r * segment.radiusMultiplier,
				segment.startAngle,
				segment.endAngle
			);
			return /*#__PURE__*/ jsxs(
				"g",
				{
					className: data.classNames,
					children: [
						/*#__PURE__*/ jsx("path", {
							className: _this3.CSS.element(_this3.baseClass, "slice", stateMods),
							style: data.style,
							d: d,
							onMouseMove: function onMouseMove(e) {
								_onMouseMove(e, instance);

								tooltipMouseMove(e, instance, _this3.tooltip);
							},
							onMouseLeave: function onMouseLeave(e) {
								_onMouseLeave(e, instance);

								tooltipMouseLeave(e, instance, _this3.tooltip);
							},
							onClick: function onClick(e) {
								_this3.handleClick(e, instance);
							}
						}),
						_this3.renderChildren(context, instance)
					]
				},
				key
			);
		});
	};

	_proto3.handleClick = function handleClick(e, instance) {
		if (!this.selection.isDummy) {
			this.selection.selectInstance(instance, {
				toggle: e.ctrlKey
			});
			e.stopPropagation();
			e.preventDefault();
		}
	};

	return PieSlice;
})(Container);
PieSlice.prototype.offset = 0;
PieSlice.prototype.r0 = 0;
PieSlice.prototype.r = 50;
PieSlice.prototype.percentageRadius = true;
PieSlice.prototype.baseClass = "pieslice";
PieSlice.prototype.legend = "legend";
PieSlice.prototype.active = true;
PieSlice.prototype.stack = "stack";
PieSlice.prototype.legendAction = "auto";
PieSlice.prototype.legendShape = "rect";
PieSlice.prototype.hoverChannel = "default";
PieSlice.prototype.styled = true;
Widget.alias("pie-chart", PieChart);

debug("The Pie class is deprecated. Please use PieChart instead.");
var Pie = PieChart;
Pie.Slice = PieSlice;

var ColumnBarBase = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(ColumnBarBase, _PureContainer);

	function ColumnBarBase() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = ColumnBarBase.prototype;

	_proto.init = function init() {
		this.selection = Selection.create(this.selection);

		_PureContainer.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		var selection = this.selection.configureWidget(this);
		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					x: undefined,
					y: undefined,
					style: {
						structured: true
					},
					class: {
						structured: true
					},
					className: {
						structured: true
					},
					disabled: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true,
					stacked: undefined,
					stack: undefined,
					offset: undefined,
					hoverId: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		instance.axes = context.axes;
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		instance.hoverSync = context.hoverSync;
		var data = instance.data;
		data.valid = this.checkValid(data);
		if (!data.colorName && data.name) data.colorName = data.name;

		_PureContainer.prototype.prepareData.call(this, context, instance);
	};

	_proto.checkValid = function checkValid(data) {
		return true;
	};

	_proto.prepare = function prepare(context, instance) {
		var _this = this;

		var data = instance.data,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (!data.valid) return;

		if (data.active) {
			instance.bounds = this.calculateRect(instance);
			instance.cache("bounds", instance.bounds);
			if (!instance.bounds.isEqual(instance.cached.bounds)) instance.markShouldUpdate(context);
			context.push("parentRect", instance.bounds);
			if (instance.xAxis.shouldUpdate || instance.yAxis.shouldUpdate) instance.markShouldUpdate(context);
		}

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				}
			});
	};

	_proto.prepareCleanup = function prepareCleanup(context, instance) {
		var data = instance.data;
		if (data.valid && data.active) context.pop("parentRect");
	};

	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};

	_proto.calculateRect = function calculateRect(context, instance) {
		throw new Error("Abstract method.");
	};

	_proto.render = function render(context, instance, key) {
		var _this2 = this;

		var data = instance.data,
			bounds = instance.bounds;
		if (!data.active || !data.valid) return null;
		return withHoverSync(key, instance.hoverSync, this.hoverChannel, data.hoverId, function(_ref) {
			var _stateMods;

			var hover = _ref.hover,
				_onMouseMove = _ref.onMouseMove,
				_onMouseLeave = _ref.onMouseLeave,
				key = _ref.key;
			var stateMods =
				((_stateMods = {
					selected: _this2.selection.isInstanceSelected(instance),
					disabled: data.disabled,
					selectable: !_this2.selection.isDummy
				}),
				(_stateMods["color-" + data.colorIndex] = data.colorIndex != null),
				(_stateMods.hover = hover),
				_stateMods);
			return /*#__PURE__*/ jsxs(
				"g",
				{
					className: data.classNames,
					children: [
						/*#__PURE__*/ jsx("rect", {
							className: _this2.CSS.element(_this2.baseClass, "rect", stateMods),
							style: data.style,
							x: bounds.l,
							y: bounds.t,
							width: Math.max(0.0001, bounds.width()),
							height: Math.max(0.0001, bounds.height()),
							onMouseMove: function onMouseMove(e) {
								_onMouseMove(e, instance);

								tooltipMouseMove(e, instance, _this2.tooltip);
							},
							onMouseLeave: function onMouseLeave(e) {
								_onMouseLeave(e, instance);

								tooltipMouseLeave(e, instance, _this2.tooltip);
							},
							onClick: function onClick(e) {
								_this2.handleClick(e, instance);
							}
						}),
						_this2.renderChildren(context, instance)
					]
				},
				key
			);
		});
	};

	_proto.handleClick = function handleClick(e, instance) {
		if (!this.selection.isDummy) {
			this.selection.selectInstance(instance, {
				toggle: e.ctrlKey
			});
			e.stopPropagation();
			e.preventDefault();
		}
	};

	return ColumnBarBase;
})(PureContainer);
ColumnBarBase.prototype.xAxis = "x";
ColumnBarBase.prototype.yAxis = "y";
ColumnBarBase.prototype.offset = 0;
ColumnBarBase.prototype.legend = "legend";
ColumnBarBase.prototype.legendAction = "auto";
ColumnBarBase.prototype.active = true;
ColumnBarBase.prototype.stacked = false;
ColumnBarBase.prototype.stack = "stack";
ColumnBarBase.prototype.legendShape = "rect";
ColumnBarBase.prototype.styled = true;
ColumnBarBase.prototype.hoverChannel = "default";

var Column = /*#__PURE__*/ (function(_ColumnBarBase) {
	_inheritsLoose(Column, _ColumnBarBase);

	function Column() {
		return _ColumnBarBase.apply(this, arguments) || this;
	}

	var _proto = Column.prototype;

	_proto.init = function init() {
		if (isDefined(this.width)) this.size = this.width;

		_ColumnBarBase.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _ColumnBarBase$protot;

		return (_ColumnBarBase$protot = _ColumnBarBase.prototype.declareData).call.apply(
			_ColumnBarBase$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					y0: undefined,
					size: undefined,
					autoSize: undefined
				}
			])
		);
	};

	_proto.checkValid = function checkValid(data) {
		return data.x != null && data.y != null && data.y0 != null;
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		if (!data.valid) return;

		if (data.active) {
			xAxis.acknowledge(data.x, data.size, data.offset);
			if (data.autoSize) xAxis.book(data.x, data.stacked ? data.stack : data.name);

			if (data.stacked) {
				yAxis.stacknowledge(data.stack, data.x, data.y0);
				yAxis.stacknowledge(data.stack, data.x, data.y);
			} else {
				if (!this.hiddenBase) yAxis.acknowledge(data.y0);
				yAxis.acknowledge(data.y);
			}

			_ColumnBarBase.prototype.explore.call(this, context, instance);
		}
	};

	_proto.calculateRect = function calculateRect(instance) {
		var data = instance.data;
		var offset = data.offset,
			size = data.size;

		if (data.autoSize) {
			var _instance$xAxis$locat = instance.xAxis.locate(data.x, data.stacked ? data.stack : data.name),
				index = _instance$xAxis$locat[0],
				count = _instance$xAxis$locat[1];

			offset = (size / count) * (index - count / 2 + 0.5);
			size = size / count;
		}

		var x1 = instance.xAxis.map(data.x, offset - size / 2);
		var x2 = instance.xAxis.map(data.x, offset + size / 2);
		var y1 = data.stacked ? instance.yAxis.stack(data.stack, data.x, data.y0) : instance.yAxis.map(data.y0);
		var y2 = data.stacked ? instance.yAxis.stack(data.stack, data.x, data.y) : instance.yAxis.map(data.y);

		if (Math.abs(y2 - y1) < this.minPixelHeight) {
			if (y1 <= y2) y2 = y1 + this.minPixelHeight;
			else y2 = y1 - this.minPixelHeight;
		}

		var bounds = new Rect({
			l: Math.min(x1, x2),
			r: Math.max(x1, x2),
			t: Math.min(y1, y2),
			b: Math.max(y1, y2)
		});
		return bounds;
	};

	return Column;
})(ColumnBarBase);
Column.prototype.baseClass = "column";
Column.prototype.y0 = 0;
Column.prototype.size = 1;
Column.prototype.autoSize = false;
Column.prototype.legendShape = "column";
Column.prototype.hiddenBase = false;
Column.prototype.minPixelHeight = 0.5;
Widget.alias("column", Column);

var Bar = /*#__PURE__*/ (function(_ColumnBarBase) {
	_inheritsLoose(Bar, _ColumnBarBase);

	function Bar() {
		return _ColumnBarBase.apply(this, arguments) || this;
	}

	var _proto = Bar.prototype;

	_proto.init = function init() {
		if (isDefined(this.height)) this.size = this.height;

		_ColumnBarBase.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _ColumnBarBase$protot;

		return (_ColumnBarBase$protot = _ColumnBarBase.prototype.declareData).call.apply(
			_ColumnBarBase$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x0: undefined,
					size: undefined,
					autoSize: undefined
				}
			])
		);
	};

	_proto.checkValid = function checkValid(data) {
		return data.y != null && data.x != null && data.x0 != null;
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);
		if (!data.valid) return;

		if (data.active) {
			yAxis.acknowledge(data.y, data.size, data.offset);
			if (data.autoSize) yAxis.book(data.y, data.stacked ? data.stack : data.name);

			if (data.stacked) {
				xAxis.stacknowledge(data.stack, data.y, data.x0);
				xAxis.stacknowledge(data.stack, data.y, data.x);
			} else {
				if (!this.hiddenBase) xAxis.acknowledge(data.x0);
				xAxis.acknowledge(data.x);
			}

			_ColumnBarBase.prototype.explore.call(this, context, instance);
		}
	};

	_proto.calculateRect = function calculateRect(instance) {
		var data = instance.data;
		var offset = data.offset,
			size = data.size;

		if (data.autoSize) {
			var _instance$yAxis$locat = instance.yAxis.locate(data.y, data.stacked ? data.stack : data.name),
				index = _instance$yAxis$locat[0],
				count = _instance$yAxis$locat[1];

			offset = (size / count) * (index - count / 2 + 0.5);
			size = size / count;
		}

		var x1 = data.stacked ? instance.xAxis.stack(data.stack, data.y, data.x0) : instance.xAxis.map(data.x0);
		var x2 = data.stacked ? instance.xAxis.stack(data.stack, data.y, data.x) : instance.xAxis.map(data.x);
		var y1 = instance.yAxis.map(data.y, offset - size / 2);
		var y2 = instance.yAxis.map(data.y, offset + size / 2);
		var bounds = new Rect({
			l: Math.min(x1, x2),
			r: Math.max(x1, x2),
			t: Math.min(y1, y2),
			b: Math.max(y1, y2)
		});
		return bounds;
	};

	return Bar;
})(ColumnBarBase);
Bar.prototype.baseClass = "bar";
Bar.prototype.x0 = 0;
Bar.prototype.size = 1;
Bar.prototype.autoSize = false;
Bar.prototype.legendShape = "bar";
Bar.prototype.hiddenBase = false;
Widget.alias("bar", Bar);

var shapes = {};
var warnings = {};
function registerShape(name, callback) {
	shapes[name] = callback;
}
function getShape(shapeName) {
	if (shapes[shapeName]) return shapes[shapeName];

	if (!warnings[shapeName]) {
		warnings[shapeName] = true;
		debug("Unknown shape '" + shapeName + "'. Using square instead.");
	}

	return shapes["square"];
}
function getAvailableShapes() {
	return Object.keys(shapes);
}
function circle(cx, cy, size, props, options) {
	return /*#__PURE__*/ jsx(
		"circle",
		_objectSpread2(
			_objectSpread2({}, props),
			{},
			{
				cx: cx,
				cy: cy,
				r: size / 2
			}
		)
	);
}
registerShape("circle", circle);
function square(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"rect",
		_objectSpread2(
			_objectSpread2({}, props),
			{},
			{
				x: cx - size / 2,
				y: cy - size / 2,
				width: size,
				height: size
			}
		)
	);
}
registerShape("square", square);
registerShape("rect", square);
function bar(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"rect",
		_objectSpread2(
			_objectSpread2({}, props),
			{},
			{
				x: cx - size / 2,
				y: cy - size / 4,
				width: size,
				height: size / 2
			}
		)
	);
}
registerShape("bar", bar);
function column(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"rect",
		_objectSpread2(
			_objectSpread2({}, props),
			{},
			{
				x: cx - size / 4,
				y: cy - size / 2,
				width: size / 2,
				height: size
			}
		)
	);
}
registerShape("column", column);
function line(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"line",
		_objectSpread2(
			_objectSpread2({}, props),
			{},
			{
				x1: cx - size / 2,
				y1: cy,
				x2: cx + size / 2,
				y2: cy
			}
		)
	);
}
registerShape("line", line);
registerShape("hline", line);
function vline(cx, cy, size, props, options) {
	size *= 0.9;
	return /*#__PURE__*/ jsx(
		"line",
		_objectSpread2(
			_objectSpread2({}, props),
			{},
			{
				x1: cx,
				y1: cy - size / 2,
				x2: cx,
				y2: cy + size / 2
			}
		)
	);
}
registerShape("vline", vline);
function triangle(cx, cy, size, props, options) {
	size *= 1.29;
	var d = "";
	var cos = Math.cos(Math.PI / 6);
	var sin = Math.sin(Math.PI / 6);
	d += "M " + cx + " " + (cy - size / 2) + " ";
	d += "L " + (cx + (cos * size) / 2) + " " + (cy + (sin * size) / 2) + " ";
	d += "L " + (cx - (cos * size) / 2) + " " + (cy + (sin * size) / 2) + " ";
	d += "Z";
	return /*#__PURE__*/ jsx(
		"path",
		_objectSpread2(
			_objectSpread2({}, props),
			{},
			{
				d: d
			}
		)
	);
}
registerShape("triangle", triangle);

var Legend = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(Legend, _HtmlElement);

	function Legend() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = Legend.prototype;

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = Object.assign(data.stateMods || {}, {
			vertical: this.vertical
		});

		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
		switch (attrName) {
			case "shapeSize":
			case "svgSize":
				return false;

			default:
				return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
		}
	};

	_proto.explore = function explore(context, instance) {
		if (!context.legends) context.legends = {};
		instance.legends = context.legends;

		context.addLegendEntry = function(legendName, entry) {
			//case when all legends are scoped and new entry is added outside the scope
			if (!context.legends) return;
			var legend = context.legends[legendName];
			if (!legend)
				legend = context.legends[legendName] = {
					entries: [],
					names: {}
				};

			if (!legend.names[entry.name]) {
				legend.entries.push(entry);
				legend.names[entry.name] = entry;
			}
		};

		_HtmlElement.prototype.explore.call(this, context, instance);
	};

	_proto.renderChildren = function renderChildren(context, instance) {
		var _this = this;

		var CSS = this.CSS;
		var entries = instance.legends[this.name] && instance.legends[this.name].entries,
			list;

		if (isArray(entries) && entries.length > 0) {
			list = /*#__PURE__*/ jsx(
				"div",
				{
					className: CSS.element(this.baseClass, "wrap"),
					children: entries.map(function(e, i) {
						return withHoverSync(i, e.hoverSync, e.hoverChannel, e.hoverId, function(_ref) {
							var onMouseMove = _ref.onMouseMove,
								onMouseLeave = _ref.onMouseLeave,
								hover = _ref.hover;
							return /*#__PURE__*/ jsxs(
								"div",
								{
									className: CSS.element(_this.baseClass, "entry", {
										"color-root": true,
										hover: hover,
										disabled: e.disabled,
										selected: e.selected
									}),
									onClick: e.onClick,
									onMouseMove: onMouseMove,
									onMouseLeave: onMouseLeave,
									children: [_this.renderShape(e), e.name]
								},
								i
							);
						});
					})
				},
				"wrap"
			);
		}

		return [list, _HtmlElement.prototype.renderChildren.call(this, context, instance)];
	};

	_proto.renderShape = function renderShape(entry) {
		var _this$CSS$element;

		var className = this.CSS.element(
			this.baseClass,
			"shape",
			((_this$CSS$element = {}),
			(_this$CSS$element["color-" + entry.colorIndex] =
				entry.colorIndex != null && (isUndefined(entry.active) || entry.active)),
			_this$CSS$element)
		);
		var shape = getShape(entry.shape || "square");
		return /*#__PURE__*/ jsx("svg", {
			className: this.CSS.element(this.baseClass, "svg"),
			style: {
				width: this.svgSize + "px",
				height: this.svgSize + "px",
				marginTop: -this.svgSize / 2 + "px"
			},
			children: shape(this.svgSize / 2, this.svgSize / 2, entry.shapeSize || this.shapeSize, {
				style: entry.style,
				className: className
			})
		});
	};

	return Legend;
})(HtmlElement);
Legend.prototype.name = "legend";
Legend.prototype.baseClass = "legend";
Legend.prototype.vertical = false;
Legend.prototype.memoize = false;
Legend.prototype.shapeSize = 18;
Legend.prototype.svgSize = 20;
Widget.alias("legend", Legend);

Legend.Scope = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(_class, _PureContainer);

	function _class() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto2 = _class.prototype;

	_proto2.explore = function explore(context, instance) {
		context.push("legends", (instance.legends = {}));

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto2.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("legends");
	};

	_proto2.prepare = function prepare(context, instance) {
		context.push("legends", instance.legends);
	};

	_proto2.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("legends");
	};

	return _class;
})(PureContainer);

var LegendScope = Legend.Scope;

var LegendEntry = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(LegendEntry, _HtmlElement);

	function LegendEntry() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = LegendEntry.prototype;

	_proto.init = function init() {
		this.selection = Selection.create(this.selection);

		_HtmlElement.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _HtmlElement$prototyp;

		var selection = this.selection.configureWidget(this);

		(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
			_HtmlElement$prototyp,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					selected: undefined,
					shape: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true,
					size: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;

		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		_HtmlElement.prototype.explore.call(this, context, instance);
	};

	_proto.prepare = function prepare(context, instance) {
		var data = instance.data,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}
	};

	_proto.attachProps = function attachProps(context, instance, props) {
		var _this = this;

		var shape = this.renderShape(instance);
		props.children = [shape, props.children];
		props.onMouseDown = stopPropagation;

		props.onClick = function(e) {
			_this.handleClick(e, instance);
		};

		delete props.active;
		delete props.selection;
		delete props.colorMap;
		delete props.colorIndex;
		delete props.shape;
		delete props.name;
		delete props.selected;
		delete props.svgSize;
	};

	_proto.handleClick = function handleClick(e, instance) {
		if (this.onClick && instance.invoke("onClick", e, instance) === false) return;
		e.stopPropagation();
		var any = this.legendAction == "auto";
		if (any || this.legendAction == "toggle") if (instance.set("active", !instance.data.active)) return;
		if ((any || this.legendAction == "select") && !this.selection.isDummy) this.selection.selectInstance(instance);
	};

	_proto.renderShape = function renderShape(instance) {
		var _this$CSS$element;

		var entry = instance.data;
		var className = this.CSS.element(
			this.baseClass,
			"shape",
			((_this$CSS$element = {
				disabled: entry.disabled,
				selected: entry.selected || this.selection.isInstanceSelected(instance)
			}),
			(_this$CSS$element["color-" + entry.colorIndex] =
				entry.colorIndex != null && (isUndefined(entry.active) || entry.active)),
			_this$CSS$element)
		);
		var shape = getShape(entry.shape || "square");
		return /*#__PURE__*/ jsx(
			"svg",
			{
				className: this.CSS.element(this.baseClass, "svg"),
				style: {
					width: this.svgSize + "px",
					height: this.svgSize + "px",
					marginTop: -this.svgSize / 2 + "px"
				},
				children: shape(this.svgSize / 2, this.svgSize / 2, entry.size, {
					style: entry.style,
					className: className
				})
			},
			"svg"
		);
	};

	return LegendEntry;
})(HtmlElement);
LegendEntry.prototype.baseClass = "legendentry";
LegendEntry.prototype.shape = "square";
LegendEntry.prototype.legendAction = "auto";
LegendEntry.prototype.size = 18;
LegendEntry.prototype.svgSize = 20;
Widget.alias("legend-entry", LegendEntry);

var ColorMap = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(ColorMap, _Widget);

	function ColorMap() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = ColorMap.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					names: undefined,
					offset: undefined,
					step: undefined,
					size: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		var _this = this;

		if (!context.colorMaps) context.colorMaps = {};

		context.getColorMap = function(colorMap) {
			var map = context.colorMaps[colorMap];

			if (!map) {
				var cache = _this.onGetCache ? instance.invoke("onGetCache") : {};
				map = cache[colorMap];

				if (!map) {
					var data = instance.data;
					map = context.colorMaps[colorMap] = cache[colorMap] = new ColorIndex({
						offset: data.offset,
						step: data.step,
						size: data.size
					});
				}

				if (Array.isArray(instance.data.names))
					instance.data.names.forEach(function(name) {
						return map.acknowledge(name);
					});
			}

			return map;
		};
	};

	_proto.render = function render() {
		return null;
	};

	return ColorMap;
})(Widget);
ColorMap.prototype.offset = 0;
ColorMap.prototype.step = null;
ColorMap.prototype.size = 16;
var ColorMapScope = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(ColorMapScope, _PureContainer);

	function ColorMapScope() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto2 = ColorMapScope.prototype;

	_proto2.explore = function explore(context, instance) {
		context.push("colorMaps", (instance.colorMaps = {}));

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto2.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("colorMaps");
	};

	_proto2.prepare = function prepare(context, instance) {
		context.push("colorMaps", instance.colorMaps);
	};

	_proto2.prepareCleanup = function prepareCleanup(context, instance) {
		context.pop("colorMaps");
	};

	return ColorMapScope;
})(PureContainer);
ColorMap.Scope = ColorMapScope;
Widget.alias("color-map", ColorMap);
var ColorIndex = /*#__PURE__*/ (function() {
	function ColorIndex(_ref) {
		var offset = _ref.offset,
			step = _ref.step,
			size = _ref.size;
		this.colorMap = {};
		this.dirty = true;
		this.offset = offset;
		this.step = step;
		this.size = size;
	}

	var _proto3 = ColorIndex.prototype;

	_proto3.acknowledge = function acknowledge(name) {
		if (!(name in this.colorMap)) {
			this.colorMap[name] = Object.keys(this.colorMap).length;
			this.dirty = true;
		}
	};

	_proto3.map = function map(name) {
		if (this.dirty) {
			this.dirty = false;

			if (!this.step) {
				var n = Object.keys(this.colorMap).length;
				this.step = n > 0 ? this.size / n : 1;
			}
		}

		var index = this.colorMap[name] || 0;
		return Math.round(this.offset + this.step * index + this.size) % this.size;
	};

	return ColorIndex;
})();

var Marker = /*#__PURE__*/ (function(_BoundedObject) {
	_inheritsLoose(Marker, _BoundedObject);

	function Marker() {
		return _BoundedObject.apply(this, arguments) || this;
	}

	var _proto = Marker.prototype;

	_proto.init = function init() {
		this.selection = Selection.create(this.selection);

		if (this.draggable) {
			this.draggableX = true;
			this.draggableY = true;
		}

		if (this.constrain) {
			this.constrainX = true;
			this.constrainY = true;
		}

		_BoundedObject.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _BoundedObject$protot;

		var selection = this.selection.configureWidget(this);
		return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				selection,
				{
					x: undefined,
					y: undefined,
					size: undefined,
					shape: undefined,
					disabled: undefined,
					colorMap: undefined,
					colorIndex: undefined,
					colorName: undefined,
					legendColorIndex: undefined,
					name: undefined,
					active: true
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		instance.axes = context.axes;
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		var data = instance.data;
		data.selected = this.selection.isInstanceSelected(instance);
		data.stateMods = {
			selected: data.selected,
			disabled: data.disabled,
			selectable: !this.selection.isDummy,
			"draggable-x": this.draggableX && !this.draggableY,
			"draggable-y": this.draggableY && !this.draggableX,
			"draggable-xy": this.draggableY && this.draggableX
		};
		if (data.name && !data.colorName) data.colorName = data.name;

		_BoundedObject.prototype.prepareData.call(this, context, instance);
	};

	_proto.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var x, y;

		if (data.x == null || data.y == null) {
			var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);

			x = (bounds.l + bounds.r) / 2;
			y = (bounds.t + bounds.b) / 2;
		}

		if (data.x != null) x = xAxis.map(data.x);
		if (data.y != null) y = yAxis.map(data.y);
		return new Rect({
			l: x - data.size / 2,
			r: x + data.size / 2,
			t: y - data.size / 2,
			b: y + data.size / 2
		});
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (data.active) {
			if (this.affectsAxes) {
				if (xAxis && data.x != null) xAxis.acknowledge(data.x, 0, this.xOffset);
				if (yAxis && data.y != null) yAxis.acknowledge(data.y, 0, this.yOffset);
			}

			if (context.pointReducer) context.pointReducer(data.x, data.y, data.name, data);

			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};

	_proto.prepare = function prepare(context, instance) {
		var _this = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (data.active) {
			if (xAxis && xAxis.shouldUpdate) instance.markShouldUpdate(context);
			if (yAxis && yAxis.shouldUpdate) instance.markShouldUpdate(context);
		}

		_BoundedObject.prototype.prepare.call(this, context, instance);

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.legendColorIndex || data.colorIndex,
				disabled: data.disabled,
				selected: data.selected,
				style: data.style,
				shape: data.shape,
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				}
			});
	};

	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") if (instance.set("active", !data.active)) return;
		if (allActions || this.legendAction == "select") this.handleClick(e, instance);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		if (!data.active || data.x === null || data.y === null) return null;
		return /*#__PURE__*/ jsx(
			MarkerComponent,
			{
				instance: instance,
				data: instance.data,
				shouldUpdate: instance.shouldUpdate,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	_proto.handleMouseDown = function handleMouseDown(e, instance) {
		var _this2 = this;

		if (this.draggableX || this.draggableY) {
			var svgEl = closest(e.target, function(el) {
				return el.tagName == "svg";
			});
			if (svgEl)
				captureMouseOrTouch(
					e,
					function(e, captureData) {
						_this2.handleDragMove(e, instance, captureData);
					},
					null,
					{
						svgEl: svgEl,
						el: e.target
					},
					e.target.style.cursor
				);
		} else {
			if (!this.selection.isDummy) this.selection.selectInstance(instance);
		}
	};

	_proto.handleClick = function handleClick(e, instance) {
		if (this.onClick) instance.invoke("onClick", e, instance);
	};

	_proto.handleDragMove = function handleDragMove(e, instance, captureData) {
		var cursor = getCursorPos(e);
		var svgBounds = getTopLevelBoundingClientRect(captureData.svgEl);
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (this.draggableX && xAxis) {
			var x = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset);
			if (this.constrainX) x = xAxis.constrainValue(x);
			instance.set("x", xAxis.encodeValue(x));
		}

		if (this.draggableY && yAxis) {
			var y = yAxis.trackValue(cursor.clientY - svgBounds.top, this.yOffset);
			if (this.constrainY) y = yAxis.constrainValue(y);
			instance.set("y", yAxis.encodeValue(y));
		}

		tooltipMouseMove(e, instance, this.tooltip, {
			target: captureData.el
		});
	};

	return Marker;
})(BoundedObject);
Marker.prototype.xOffset = 0;
Marker.prototype.yOffset = 0;
Marker.prototype.size = 5;
Marker.prototype.anchors = "0.5 0.5 0.5 0.5";
Marker.prototype.xAxis = "x";
Marker.prototype.yAxis = "y";
Marker.prototype.baseClass = "marker";
Marker.prototype.draggableX = false;
Marker.prototype.draggableY = false;
Marker.prototype.draggable = false;
Marker.prototype.constrainX = false;
Marker.prototype.constrainY = false;
Marker.prototype.constrain = false;
Marker.prototype.legend = "legend";
Marker.prototype.legendAction = "auto";
Marker.prototype.shape = "circle";
Marker.prototype.styled = true;
Marker.prototype.hidden = false;
Marker.prototype.affectsAxes = true;
BoundedObject.alias("marker", Marker);

var MarkerComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(MarkerComponent, _VDOM$Component);

	function MarkerComponent() {
		return _VDOM$Component.apply(this, arguments) || this;
	}

	var _proto2 = MarkerComponent.prototype;

	_proto2.shouldComponentUpdate = function shouldComponentUpdate(props) {
		return props.shouldUpdate;
	};

	_proto2.render = function render() {
		var _CSS$element,
			_this3 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			children = _this$props.children,
			data = _this$props.data;
		var widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var bounds = data.bounds,
			shape = data.shape;
		var shapeRenderer = getShape(shape);
		var shapeProps = {
			className: CSS.element(
				baseClass,
				"shape",
				((_CSS$element = {}),
				(_CSS$element["color-" + data.colorIndex] = data.colorIndex != null),
				(_CSS$element.selected = data.selected),
				_CSS$element)
			),
			style: data.style,
			cx: (bounds.l + bounds.r) / 2,
			cy: (bounds.t + bounds.b) / 2,
			r: data.size / 2,
			onMouseMove: function onMouseMove(e) {
				tooltipMouseMove(e, instance, widget.tooltip);
			},
			onMouseLeave: function onMouseLeave(e) {
				tooltipMouseLeave(e, instance, widget.tooltip);
			},
			onMouseDown: function onMouseDown(e) {
				widget.handleMouseDown(e, instance);
			},
			onTouchStart: function onTouchStart(e) {
				widget.handleMouseDown(e, instance);
			},
			onClick: function onClick(e) {
				widget.handleClick(e, instance);
			}
		};

		if (widget.tooltip) {
			shapeProps.ref = function(c) {
				_this3.el = c;
			};
		}

		return /*#__PURE__*/ jsxs("g", {
			className: data.classNames,
			children: [
				!widget.hidden && shapeRenderer((bounds.l + bounds.r) / 2, (bounds.t + bounds.b) / 2, data.size, shapeProps),
				children
			]
		});
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		tooltipParentWillReceiveProps(this.el, props.instance, props.instance.widget.tooltip);
	};

	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount(this.el, this.props.instance, this.props.instance.widget.tooltip);
	};

	return MarkerComponent;
})(VDOM.Component);

var MarkerLine = /*#__PURE__*/ (function(_BoundedObject) {
	_inheritsLoose(MarkerLine, _BoundedObject);

	function MarkerLine() {
		return _BoundedObject.apply(this, arguments) || this;
	}

	var _proto = MarkerLine.prototype;

	_proto.init = function init() {
		if (isDefined(this.x)) this.x1 = this.x2 = this.x;
		if (isDefined(this.y)) this.y1 = this.y2 = this.y;

		_BoundedObject.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _BoundedObject$protot;

		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x1: undefined,
					y1: undefined,
					x2: undefined,
					y2: undefined,
					colorIndex: undefined,
					active: true,
					name: undefined,
					legend: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data;
		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);

		if (data.active) {
			if (this.affectsAxes) {
				if (data.x1 != null) xAxis.acknowledge(data.x1);
				if (data.x2 != null) xAxis.acknowledge(data.x2);
				if (data.y1 != null) yAxis.acknowledge(data.y1);
				if (data.y2 != null) yAxis.acknowledge(data.y2);
			}

			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};

	_proto.prepare = function prepare(context, instance) {
		var _this = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);

		_BoundedObject.prototype.prepare.call(this, context, instance);

		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				style: data.style,
				shape: "line",
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				}
			});
	};

	_proto.calculateBounds = function calculateBounds(context, instance) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);

		var x1 = bounds.l,
			x2 = bounds.r,
			y1 = bounds.t,
			y2 = bounds.b;
		if (data.x1 != null) x1 = xAxis.map(data.x1);
		if (data.x2 != null) x2 = xAxis.map(data.x2);
		if (data.y1 != null) y1 = yAxis.map(data.y1);
		if (data.y2 != null) y2 = yAxis.map(data.y2);
		bounds.l = Math.min(x1, x2);
		bounds.t = Math.min(y1, y2);
		bounds.r = Math.max(x1, x2);
		bounds.b = Math.max(y1, y2);
		instance.x1 = x1;
		instance.x2 = x2;
		instance.y1 = y1;
		instance.y2 = y2;
		return bounds;
	};

	_proto.render = function render(context, instance, key) {
		var _stateMods;

		var data = instance.data,
			x1 = instance.x1,
			x2 = instance.x2,
			y1 = instance.y1,
			y2 = instance.y2;
		if (!data.active || data.x1 === null || data.x2 === null || data.y1 === null || data.y2 === null) return null;
		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);
		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				children: [
					/*#__PURE__*/ jsx("line", {
						className: this.CSS.element(this.baseClass, "line", stateMods),
						style: data.style,
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2
					}),
					this.renderChildren(context, instance)
				]
			},
			key
		);
	};

	return MarkerLine;
})(BoundedObject);
MarkerLine.prototype.xAxis = "x";
MarkerLine.prototype.yAxis = "y";
MarkerLine.prototype.anchors = "0 1 1 0";
MarkerLine.prototype.baseClass = "markerline";
MarkerLine.prototype.legend = "legend";
MarkerLine.prototype.legendAction = "auto";
MarkerLine.prototype.affectsAxes = true;
BoundedObject.alias("marker-line", MarkerLine);

var Range = /*#__PURE__*/ (function(_BoundedObject) {
	_inheritsLoose(Range, _BoundedObject);

	function Range() {
		return _BoundedObject.apply(this, arguments) || this;
	}

	var _proto = Range.prototype;

	_proto.declareData = function declareData() {
		var _BoundedObject$protot;

		(_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x1: undefined,
					y1: undefined,
					x2: undefined,
					y2: undefined,
					colorIndex: undefined,
					active: true,
					name: undefined,
					legend: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data;
		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);

		if (data.active) {
			if (xAxis) {
				if (data.x1 != null) instance.xAxis.acknowledge(data.x1, this.xSize, this.xOffset);
				if (data.x2 != null) instance.xAxis.acknowledge(data.x2, this.xSize, this.xOffset);
			}

			if (yAxis) {
				if (data.y1 != null) instance.yAxis.acknowledge(data.y1, this.ySize, this.yOffset);
				if (data.y2 != null) instance.yAxis.acknowledge(data.y2, this.ySize, this.yOffset);
			}

			_BoundedObject.prototype.explore.call(this, context, instance);
		}
	};

	_proto.prepare = function prepare(context, instance) {
		var _this = this;

		_BoundedObject.prototype.prepare.call(this, context, instance);

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (xAxis && xAxis.shouldUpdate) instance.markShouldUpdate(context);
		if (yAxis && yAxis.shouldUpdate) instance.markShouldUpdate(context);
		if (data.name && data.legend && context.addLegendEntry)
			context.addLegendEntry(data.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				style: data.style,
				shape: "rect",
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				}
			});
	};

	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};

	_proto.calculateBounds = function calculateBounds(context, instance) {
		var bounds = _BoundedObject.prototype.calculateBounds.call(this, context, instance);

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (data.x1 != null) bounds.l = xAxis.map(data.x1, this.xOffset - this.xSize / 2);
		if (data.x2 != null) bounds.r = xAxis.map(data.x2, this.xOffset + this.xSize / 2);
		if (data.y1 != null) bounds.t = yAxis.map(data.y1, this.yOffset - this.ySize / 2);
		if (data.y2 != null) bounds.b = yAxis.map(data.y2, this.yOffset + this.ySize / 2);
		return bounds;
	};

	_proto.render = function render(context, instance, key) {
		var _stateMods,
			_this2 = this;

		var data = instance.data;
		if (!data.active) return null;
		var bounds = data.bounds;
		var x1 = Math.min(bounds.l, bounds.r),
			y1 = Math.min(bounds.t, bounds.b),
			x2 = Math.max(bounds.l, bounds.r),
			y2 = Math.max(bounds.t, bounds.b);
		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);
		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				children: [
					!this.hidden &&
						/*#__PURE__*/ jsx("rect", {
							className: this.CSS.element(this.baseClass, "rect", stateMods),
							style: data.style,
							x: x1,
							y: y1,
							width: x2 - x1,
							height: y2 - y1,
							onMouseDown: function onMouseDown(e) {
								return _this2.handleMouseDown(e, instance);
							},
							onTouchStart: function onTouchStart(e) {
								return _this2.handleMouseDown(e, instance);
							}
						}),
					this.renderChildren(context, instance)
				]
			},
			key
		);
	};

	_proto.handleClick = function handleClick(e, instance) {
		if (this.onClick) instance.invoke("onClick", e, instance);
	};

	_proto.handleMouseDown = function handleMouseDown(e, instance) {
		var _this3 = this;

		if (this.draggableX || this.draggableY) {
			var svgEl = closest(e.target, function(el) {
				return el.tagName == "svg";
			});
			var svgBounds = getTopLevelBoundingClientRect(svgEl);
			var cursor = getCursorPos(e);
			var data = instance.data,
				xAxis = instance.xAxis,
				yAxis = instance.yAxis;
			var captureData = {
				svgBounds: svgBounds,
				start: {
					x1: data.x1,
					x2: data.x2,
					y1: data.y1,
					y2: data.y2
				}
			};
			if (this.draggableX && xAxis)
				captureData.start.x = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset, this.constrainX);
			if (this.draggableY && yAxis)
				captureData.start.y = yAxis.trackValue(cursor.clientY - svgBounds.top, this.yOffset, this.constrainY);
			if (svgEl)
				captureMouseOrTouch(
					e,
					function(e, captureData) {
						_this3.handleDragMove(e, instance, captureData);
					},
					null,
					captureData,
					e.target.style.cursor
				);
		}
	};

	_proto.handleDragMove = function handleDragMove(e, instance, captureData) {
		var cursor = getCursorPos(e);
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var svgBounds = captureData.svgBounds,
			start = captureData.start;

		if (this.draggableX && xAxis) {
			var dist = xAxis.trackValue(cursor.clientX - svgBounds.left, this.xOffset, this.constrainX) - captureData.start.x;
			var x1v = xAxis.decodeValue(captureData.start.x1);
			var x2v = xAxis.decodeValue(captureData.start.x2);

			if (this.constrainX) {
				if (dist > 0) dist = Math.min(xAxis.constrainValue(x2v + dist) - x2v, dist);
				else dist = Math.max(xAxis.constrainValue(x1v + dist) - x1v, dist);
			}

			instance.set("x1", xAxis.encodeValue(x1v + dist));
			instance.set("x2", xAxis.encodeValue(x2v + dist));
		}

		if (this.draggableY && yAxis) {
			var dist = yAxis.trackValue(cursor.clientY - svgBounds.left, this.yOffset, this.constrainY) - captureData.start.y;
			var y1v = yAxis.decodeValue(captureData.start.y1);
			var y2v = yAxis.decodeValue(captureData.start.y2);
			if (this.constrainY)
				dist = Math.max(yAxis.constrainValue(y1v + dist) - y1v, Math.min(yAxis.constrainValue(y2v + dist) - y2v, dist));
			instance.set("y1", yAxis.encodeValue(y1v + dist));
			instance.set("y2", yAxis.encodeValue(y2v + dist));
		}
	};

	return Range;
})(BoundedObject);
Range.prototype.invisible = false;
Range.prototype.xAxis = "x";
Range.prototype.yAxis = "y";
Range.prototype.xSize = 0;
Range.prototype.ySize = 0;
Range.prototype.xOffset = 0;
Range.prototype.yOffset = 0;
Range.prototype.anchors = "0 1 1 0";
Range.prototype.baseClass = "range";
Range.prototype.legend = "legend";
Range.prototype.legendAction = "auto";
BoundedObject.alias("range", Range);

var Gridlines = /*#__PURE__*/ (function(_BoundedObject) {
	_inheritsLoose(Gridlines, _BoundedObject);

	function Gridlines() {
		return _BoundedObject.apply(this, arguments) || this;
	}

	var _proto = Gridlines.prototype;

	_proto.explore = function explore(context, instance) {
		_BoundedObject.prototype.explore.call(this, context, instance);

		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
	};

	_proto.prepare = function prepare(context, instance) {
		_BoundedObject.prototype.prepare.call(this, context, instance);

		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if ((xAxis && xAxis.shouldUpdate) || (yAxis && yAxis.shouldUpdate)) instance.markShouldUpdate(context);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var bounds = data.bounds;
		var path = "",
			xTicks,
			yTicks;

		if (xAxis) {
			xTicks = xAxis.mapGridlines();
			xTicks.forEach(function(x) {
				path += "M " + x + " " + bounds.t + " L " + x + " " + bounds.b;
			});
		}

		if (yAxis) {
			yTicks = yAxis.mapGridlines();
			yTicks.forEach(function(y) {
				path += "M " + bounds.l + " " + y + " L " + bounds.r + " " + y;
			});
		}

		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: /*#__PURE__*/ jsx("path", {
					style: data.style,
					d: path
				})
			},
			key
		);
	};

	return Gridlines;
})(BoundedObject);
Gridlines.prototype.xAxis = "x";
Gridlines.prototype.yAxis = "y";
Gridlines.prototype.anchors = "0 1 1 0";
Gridlines.prototype.baseClass = "gridlines";
BoundedObject.alias("gridlines", Gridlines);

var LineGraph = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(LineGraph, _Widget);

	function LineGraph() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = LineGraph.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					class: {
						structured: true
					},
					className: {
						structured: true
					},
					lineStyle: {
						structured: true
					},
					areaStyle: {
						structured: true
					},
					area: undefined,
					line: undefined,
					y0: undefined,
					name: undefined,
					active: true,
					stack: undefined,
					stacked: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;

		_Widget.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		var _this = this;

		var data = instance.data;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (data.active) {
			instance.axes = context.axes;
			instance.xAxis = instance.axes[this.xAxis];
			instance.yAxis = instance.axes[this.yAxis];

			_Widget.prototype.explore.call(this, context, instance);

			if (isArray(data.data)) {
				data.data.forEach(function(p, index) {
					var x = p[_this.xField];
					instance.xAxis.acknowledge(x);

					if (data.stacked) {
						instance.yAxis.stacknowledge(data.stack, x, _this.y0Field ? p[_this.y0Field] : data.y0);
						instance.yAxis.stacknowledge(data.stack, x, p[_this.yField]);
					} else {
						instance.yAxis.acknowledge(p[_this.yField]);

						if (data.area) {
							if (!_this.hiddenBase) instance.yAxis.acknowledge(_this.y0Field ? p[_this.y0Field] : data.y0);
							if (context.pointReducer && _this.y0Field)
								context.pointReducer(x, p[_this.y0Field], data.name, p, data, index);
						}
					}

					if (context.pointReducer) context.pointReducer(x, p[_this.yField], data.name, p, data, index);
				});
			}
		}
	};

	_proto.prepare = function prepare(context, instance) {
		var _this2 = this;

		var data = instance.data,
			colorMap = instance.colorMap;

		if (colorMap && data.colorName) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (data.active) {
			if (instance.axes[this.xAxis].shouldUpdate || instance.axes[this.yAxis].shouldUpdate)
				instance.markShouldUpdate(context);
		}

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				//selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				}
			});
	};

	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};

	_proto.render = function render(context, instance, key) {
		var _this3 = this,
			_stateMods;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		if (!data.active) return null;
		var spans = [];
		var span = [];
		isArray(data.data) &&
			data.data.forEach(function(p) {
				var ax = p[_this3.xField],
					ay = p[_this3.yField],
					ay0 = _this3.y0Field ? p[_this3.y0Field] : data.y0,
					x,
					y,
					y0;

				if (ax != null && ay != null && ay0 != null) {
					x = xAxis.map(ax);
					y0 = data.stacked ? yAxis.stack(data.stack, ax, ay0) : yAxis.map(ay0);
					y = data.stacked ? yAxis.stack(data.stack, ax, ay) : yAxis.map(ay);
				}

				if (x != null && y != null && y0 != null)
					span.push({
						x: x,
						y: y,
						y0: y0
					});
				else if (span.length > 0) {
					spans.push(span);
					span = [];
				}
			});
		if (span.length > 0) spans.push(span);
		var stateMods = ((_stateMods = {}), (_stateMods["color-" + data.colorIndex] = data.colorIndex != null), _stateMods);
		var line, area;

		if (data.line) {
			var linePath = "";
			spans.forEach(function(span) {
				span.forEach(function(p, i) {
					linePath += i == 0 ? " M " : " L ";
					linePath += p.x + " " + p.y;
				});
			});
			line = /*#__PURE__*/ jsx("path", {
				className: this.CSS.element(this.baseClass, "line", stateMods),
				style: this.CSS.parseStyle(data.lineStyle),
				d: linePath
			});
		}

		if (data.area) {
			var areaPath = "";
			spans.forEach(function(span) {
				var closePath = "";
				span.forEach(function(p, i) {
					areaPath += i == 0 ? " M " : " L ";
					areaPath += p.x + " " + p.y;
					if (data.area) closePath = "L " + p.x + " " + p.y0 + " " + closePath;
				});
				areaPath += closePath;
				areaPath += "L " + span[0].x + " " + span[0].y;
			});
			area = /*#__PURE__*/ jsx("path", {
				className: this.CSS.element(this.baseClass, "area", stateMods),
				style: this.CSS.parseStyle(data.areaStyle),
				d: areaPath
			});
		}

		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				children: [line, area]
			},
			key
		);
	};

	return LineGraph;
})(Widget);
LineGraph.prototype.xAxis = "x";
LineGraph.prototype.yAxis = "y";
LineGraph.prototype.area = false;
LineGraph.prototype.line = true;
LineGraph.prototype.xField = "x";
LineGraph.prototype.yField = "y";
LineGraph.prototype.baseClass = "linegraph";
LineGraph.prototype.y0 = 0;
LineGraph.prototype.y0Field = false;
LineGraph.prototype.active = true;
LineGraph.prototype.legend = "legend";
LineGraph.prototype.legendAction = "auto";
LineGraph.prototype.legendShape = "rect";
LineGraph.prototype.stack = "stack";
LineGraph.prototype.hiddenBase = false;
Widget.alias("line-graph", LineGraph);

var ColumnBarGraphBase = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(ColumnBarGraphBase, _Widget);

	function ColumnBarGraphBase() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = ColumnBarGraphBase.prototype;

	_proto.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data
		});

		_Widget.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		var selection = this.selection.configureWidget(this);

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this, selection].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					size: undefined,
					offset: undefined,
					y0: undefined,
					x0: undefined,
					autoSize: undefined,
					active: true,
					stacked: undefined,
					stack: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;

		_Widget.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];
		var data = instance.data;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		_Widget.prototype.explore.call(this, context, instance);
	};

	_proto.prepare = function prepare(context, instance) {
		var _this = this;

		var data = instance.data,
			colorMap = instance.colorMap,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (colorMap && data.name) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (xAxis.shouldUpdate || yAxis.shouldUpdate) instance.markShouldUpdate(context);
		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				selected: this.selection.isInstanceSelected(instance),
				style: data.style,
				shape: this.legendShape,
				onClick: function onClick(e) {
					_this.onLegendClick(e, instance);
				}
			});
	};

	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: data.active && this.renderGraph(context, instance)
			},
			key
		);
	};

	_proto.handleClick = function handleClick(e, instance, point, index) {
		if (this.onClick && instance.invoke("onClick", e, instance, point, index) === false) return;
		if (!this.selection.isDummy)
			this.selection.select(instance.store, point, index, {
				toggle: e.ctrlKey
			});
	};

	return ColumnBarGraphBase;
})(Widget);
ColumnBarGraphBase.prototype.xAxis = "x";
ColumnBarGraphBase.prototype.yAxis = "y";
ColumnBarGraphBase.prototype.xField = "x";
ColumnBarGraphBase.prototype.yField = "y";
ColumnBarGraphBase.prototype.colorIndexField = false;
ColumnBarGraphBase.prototype.size = 1;
ColumnBarGraphBase.prototype.legend = "legend";
ColumnBarGraphBase.prototype.legendAction = "auto";
ColumnBarGraphBase.prototype.legendShape = "rect";
ColumnBarGraphBase.prototype.stack = "stack";
ColumnBarGraphBase.prototype.stacked = false;
ColumnBarGraphBase.prototype.autoSize = 0;
ColumnBarGraphBase.prototype.offset = 0;
ColumnBarGraphBase.prototype.styled = true;

var ColumnGraph = /*#__PURE__*/ (function(_ColumnBarGraphBase) {
	_inheritsLoose(ColumnGraph, _ColumnBarGraphBase);

	function ColumnGraph() {
		return _ColumnBarGraphBase.apply(this, arguments) || this;
	}

	var _proto = ColumnGraph.prototype;

	_proto.explore = function explore(context, instance) {
		var _this = this;

		_ColumnBarGraphBase.prototype.explore.call(this, context, instance);

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis;

		if (isArray(data.data)) {
			data.data.forEach(function(p, index) {
				var y0 = _this.y0Field ? p[_this.y0Field] : data.y0;
				var x = p[_this.xField];
				var y = p[_this.yField];
				xAxis.acknowledge(x, data.size, data.offset);
				if (data.autoSize) xAxis.book(x, data.stacked ? data.stack : data.name);

				if (data.stacked) {
					yAxis.stacknowledge(data.stack, x, y0);
					yAxis.stacknowledge(data.stack, x, y);
				} else {
					if (!_this.hiddenBase) yAxis.acknowledge(y0);
					yAxis.acknowledge(y);
				}

				if (context.pointReducer) context.pointReducer(x, y, data.name, p, data, index);
			});
		}
	};

	_proto.renderGraph = function renderGraph(context, instance) {
		var _this2 = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			store = instance.store;
		if (!isArray(data.data)) return false;
		var isSelected = this.selection.getIsSelectedDelegate(store);
		return data.data.map(function(p, i) {
			var _state;

			var offset = data.offset,
				size = data.size;
			var y0 = _this2.y0Field ? p[_this2.y0Field] : data.y0;
			var x = p[_this2.xField];
			var y = p[_this2.yField];

			if (data.autoSize) {
				var _instance$xAxis$locat = instance.xAxis.locate(x, data.stacked ? data.stack : data.name),
					index = _instance$xAxis$locat[0],
					count = _instance$xAxis$locat[1];

				offset = (size / count) * (index - count / 2 + 0.5);
				size = size / count;
			}

			var x1 = xAxis.map(x, offset - size / 2);
			var x2 = xAxis.map(x, offset + size / 2);
			var y1 = data.stacked ? yAxis.stack(data.stack, x, y0) : yAxis.map(y0);
			var y2 = data.stacked ? yAxis.stack(data.stack, x, y) : yAxis.map(y);
			var color = _this2.colorIndexField ? p[_this2.colorIndexField] : data.colorIndex;
			var state =
				((_state = {
					selected: isSelected(p, i),
					selectable: !_this2.selection.isDummy
				}),
				(_state["color-" + color] = color != null),
				_state);
			var mmove, mleave;

			if (_this2.tooltip) {
				mmove = function mmove(e) {
					return tooltipMouseMove(e, instance, _this2.tooltip, {
						target: e.target.parent,
						data: {
							$record: p
						}
					});
				};

				mleave = function mleave(e) {
					return tooltipMouseLeave(e, instance, _this2.tooltip, {
						target: e.target.parent,
						data: {
							$record: p
						}
					});
				};
			}

			return /*#__PURE__*/ jsx(
				"rect",
				{
					className: _this2.CSS.element(_this2.baseClass, "column", state),
					onClick: function onClick(e) {
						_this2.handleClick(e, instance, p, i);
					},
					x: Math.min(x1, x2),
					y: Math.min(y1, y2),
					width: Math.abs(x2 - x1),
					height: Math.abs(y2 - y1),
					style: data.style,
					onMouseMove: mmove,
					onMouseLeave: mleave
				},
				i
			);
		});
	};

	return ColumnGraph;
})(ColumnBarGraphBase);
ColumnGraph.prototype.baseClass = "columngraph";
ColumnGraph.prototype.y0Field = false;
ColumnGraph.prototype.y0 = 0;
ColumnGraph.prototype.legendShape = "column";
ColumnGraph.prototype.hiddenBase = false;
Widget.alias("columngraph", ColumnGraph);

var BarGraph = /*#__PURE__*/ (function(_ColumnBarGraphBase) {
	_inheritsLoose(BarGraph, _ColumnBarGraphBase);

	function BarGraph() {
		return _ColumnBarGraphBase.apply(this, arguments) || this;
	}

	var _proto = BarGraph.prototype;

	_proto.explore = function explore(context, instance) {
		var _this = this;

		_ColumnBarGraphBase.prototype.explore.call(this, context, instance);

		var data = instance.data,
			yAxis = instance.yAxis,
			xAxis = instance.xAxis;

		if (isArray(data.data)) {
			data.data.forEach(function(p) {
				var x0 = _this.x0Field ? p[_this.x0Field] : data.x0;
				var y = p[_this.yField];
				var x = p[_this.xField];
				yAxis.acknowledge(y, data.size, data.offset);
				if (data.autoSize) yAxis.book(y, data.stacked ? data.stack : data.name);

				if (data.stacked) {
					xAxis.stacknowledge(data.stack, y, x0);
					xAxis.stacknowledge(data.stack, y, x);
				} else {
					if (!_this.hiddenBase) xAxis.acknowledge(x0);
					xAxis.acknowledge(x);
				}
			});
		}
	};

	_proto.renderGraph = function renderGraph(context, instance) {
		var _this2 = this;

		var data = instance.data,
			yAxis = instance.yAxis,
			xAxis = instance.xAxis,
			store = instance.store;
		if (!isArray(data.data)) return false;
		var isSelected = this.selection.getIsSelectedDelegate(store);
		return data.data.map(function(p, i) {
			var _state;

			var offset = data.offset,
				size = data.size;
			var x0 = _this2.x0Field ? p[_this2.x0Field] : data.x0;
			var y = p[_this2.yField];
			var x = p[_this2.xField];

			if (data.autoSize) {
				var _instance$yAxis$locat = instance.yAxis.locate(y, data.stacked ? data.stack : data.name),
					index = _instance$yAxis$locat[0],
					count = _instance$yAxis$locat[1];

				offset = (size / count) * (index - count / 2 + 0.5);
				size = size / count;
			}

			var y1 = yAxis.map(y, offset - size / 2);
			var y2 = yAxis.map(y, offset + size / 2);
			var x1 = data.stacked ? xAxis.stack(data.stack, y, x0) : xAxis.map(x0);
			var x2 = data.stacked ? xAxis.stack(data.stack, y, x) : xAxis.map(x);
			var color = _this2.colorIndexField ? p[_this2.colorIndexField] : data.colorIndex;
			var state =
				((_state = {
					selected: isSelected(p, i),
					selectable: !_this2.selection.isDummy
				}),
				(_state["color-" + color] = color != null),
				_state);
			var mmove, mleave;

			if (_this2.tooltip) {
				mmove = function mmove(e) {
					return tooltipMouseMove(e, instance, _this2.tooltip, {
						target: e.target.parent,
						data: {
							$record: p
						}
					});
				};

				mleave = function mleave(e) {
					return tooltipMouseLeave(e, instance, _this2.tooltip, {
						target: e.target.parent,
						data: {
							$record: p
						}
					});
				};
			}

			return /*#__PURE__*/ jsx(
				"rect",
				{
					className: _this2.CSS.element(_this2.baseClass, "bar", state),
					onClick: function onClick(e) {
						_this2.handleClick(e, instance, p, i);
					},
					x: Math.min(x1, x2),
					y: Math.min(y1, y2),
					width: Math.abs(x2 - x1),
					height: Math.abs(y2 - y1),
					style: data.style,
					onMouseMove: mmove,
					onMouseLeave: mleave
				},
				i
			);
		});
	};

	return BarGraph;
})(ColumnBarGraphBase);
BarGraph.prototype.baseClass = "bargraph";
BarGraph.prototype.x0Field = false;
BarGraph.prototype.x0 = 0;
BarGraph.prototype.legendShape = "bar";
BarGraph.prototype.hiddenBase = false;
Widget.alias("bargraph", BarGraph);

var ScatterGraph = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(ScatterGraph, _Widget);

	function ScatterGraph() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = ScatterGraph.prototype;

	_proto.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data
		});

		_Widget.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		var selection = this.selection.configureWidget(this);

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					size: undefined,
					shape: undefined,
					colorIndex: undefined,
					colorMap: undefined,
					colorName: undefined,
					name: undefined,
					active: true
				},
				selection
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (data.name && !data.colorName) data.colorName = data.name;

		_Widget.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		var _this = this;

		_Widget.prototype.explore.call(this, context, instance);

		var xAxis = (instance.xAxis = context.axes[this.xAxis]);
		var yAxis = (instance.yAxis = context.axes[this.yAxis]);
		var data = instance.data;
		instance.colorMap = data.colorMap && context.getColorMap && context.getColorMap(data.colorMap);
		if (instance.colorMap && data.colorName) instance.colorMap.acknowledge(data.colorName);

		if (data.active && isArray(data.data)) {
			data.data.forEach(function(p) {
				xAxis.acknowledge(p[_this.xField]);
				yAxis.acknowledge(p[_this.yField]);
			});
		}
	};

	_proto.prepare = function prepare(context, instance) {
		var _this2 = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			colorMap = instance.colorMap;
		if (xAxis.shouldUpdate || yAxis.shouldUpdate) instance.markShouldUpdate(context);

		if (colorMap && data.name) {
			data.colorIndex = colorMap.map(data.colorName);
			if (instance.cache("colorIndex", data.colorIndex)) instance.markShouldUpdate(context);
		}

		if (data.name && context.addLegendEntry)
			context.addLegendEntry(this.legend, {
				name: data.name,
				active: data.active,
				colorIndex: data.colorIndex,
				disabled: data.disabled,
				style: data.style,
				shape: data.shape,
				onClick: function onClick(e) {
					_this2.onLegendClick(e, instance);
				}
			});
	};

	_proto.onLegendClick = function onLegendClick(e, instance) {
		var allActions = this.legendAction == "auto";
		var data = instance.data;
		if (allActions || this.legendAction == "toggle") instance.set("active", !data.active);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: this.renderData(context, instance)
			},
			key
		);
	};

	_proto.renderData = function renderData(context, instance) {
		var _this3 = this;

		var data = instance.data,
			xAxis = instance.xAxis,
			yAxis = instance.yAxis,
			store = instance.store;
		if (!data.active) return null;
		var shape = getShape(data.shape);
		var isSelected = this.selection.getIsSelectedDelegate(store);
		return (
			isArray(data.data) &&
			data.data.map(function(p, i) {
				var _CSS$element;

				var classes = CSS.element(
					_this3.baseClass,
					"shape",
					((_CSS$element = {
						selected: isSelected(p, i),
						selectable: !_this3.selection.isDummy
					}),
					(_CSS$element["color-" + data.colorIndex] = data.colorIndex != null),
					_CSS$element)
				);
				var cx = xAxis.map(p[_this3.xField]),
					cy = yAxis.map(p[_this3.yField]),
					size = _this3.sizeField ? p[_this3.sizeField] : data.size;
				return shape(cx, cy, size, {
					key: i,
					className: classes,
					style: p.style || data.style,
					onClick: function onClick(e) {
						_this3.handleItemClick(e, instance, i);
					}
				});
			})
		);
	};

	_proto.handleItemClick = function handleItemClick(e, _ref, index) {
		var data = _ref.data,
			store = _ref.store;
		var bubble = data.data[index];
		this.selection.select(store, bubble, index, {
			toggle: e.ctrlKey
		});
	};

	return ScatterGraph;
})(Widget);
ScatterGraph.prototype.baseClass = "scattergraph";
ScatterGraph.prototype.xAxis = "x";
ScatterGraph.prototype.yAxis = "y";
ScatterGraph.prototype.xField = "x";
ScatterGraph.prototype.yField = "y";
ScatterGraph.prototype.sizeField = false;
ScatterGraph.prototype.shape = "circle";
ScatterGraph.prototype.size = 10;
ScatterGraph.prototype.legend = "legend";
ScatterGraph.prototype.legendAction = "auto";
ScatterGraph.prototype.styled = true;
Widget.alias("scatter-graph", ScatterGraph);

var BubbleGraph = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(BubbleGraph, _Widget);

	function BubbleGraph() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = BubbleGraph.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		var selection = this.selection.configureWidget(this);

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: undefined,
					bubbleRadius: undefined,
					bubbleStyle: {
						structured: true
					}
				},
				selection
			])
		);
	};

	_proto.init = function init() {
		this.selection = Selection.create(this.selection, {
			records: this.data
		});

		_Widget.prototype.init.call(this);
	};

	_proto.explore = function explore(context, instance) {
		var _this = this;

		instance.axes = context.axes;

		_Widget.prototype.explore.call(this, context, instance);

		var data = instance.data;

		if (isArray(data.data)) {
			data.data.forEach(function(p) {
				instance.axes[_this.xAxis].acknowledge(p[_this.xField]);

				instance.axes[_this.yAxis].acknowledge(p[_this.yField]);
			});
		}
	};

	_proto.prepare = function prepare(context, instance) {
		_Widget.prototype.prepare.call(this, context, instance);

		if (instance.axes[this.xAxis].shouldUpdate || instance.axes[this.yAxis].shouldUpdate)
			instance.markShouldUpdate(context);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				children: this.renderData(context, instance)
			},
			key
		);
	};

	_proto.renderData = function renderData(context, instance) {
		var _this2 = this;

		var data = instance.data,
			axes = instance.axes,
			store = instance.store;
		var xAxis = axes[this.xAxis];
		var yAxis = axes[this.yAxis];
		return (
			isArray(data.data) &&
			data.data.map(function(p, i) {
				var selected = _this2.selection && _this2.selection.isSelected(store, p, i);

				var classes = CSS.element(_this2.baseClass, "bubble", {
					selected: selected
				});
				return /*#__PURE__*/ jsx(
					"circle",
					{
						className: classes,
						cx: xAxis.map(p[_this2.xField]),
						cy: yAxis.map(p[_this2.yField]),
						r: p[_this2.rField] || data.bubbleRadius,
						style: p.style || data.bubbleStyle,
						onClick: function onClick(e) {
							_this2.onBubbleClick(e, instance, i);
						}
					},
					i
				);
			})
		);
	};

	_proto.onBubbleClick = function onBubbleClick(e, _ref, index) {
		var data = _ref.data,
			store = _ref.store;
		var bubble = data.data[index];
		this.selection.select(store, bubble, index, {
			toggle: e.ctrlKey
		});
	};

	return BubbleGraph;
})(Widget);
BubbleGraph.prototype.baseClass = "bubblegraph";
BubbleGraph.prototype.xAxis = "x";
BubbleGraph.prototype.yAxis = "y";
BubbleGraph.prototype.xField = "x";
BubbleGraph.prototype.yField = "y";
BubbleGraph.prototype.rField = "r";
BubbleGraph.prototype.bubbleRadius = 10;
Widget.alias("bubble-graph", BubbleGraph);

var MouseTracker = /*#__PURE__*/ (function(_BoundedObject) {
	_inheritsLoose(MouseTracker, _BoundedObject);

	function MouseTracker() {
		return _BoundedObject.apply(this, arguments) || this;
	}

	var _proto = MouseTracker.prototype;

	_proto.declareData = function declareData() {
		var _BoundedObject$protot;

		return (_BoundedObject$protot = _BoundedObject.prototype.declareData).call.apply(
			_BoundedObject$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					x: undefined,
					y: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		instance.xAxis = context.axes[this.xAxis];
		instance.yAxis = context.axes[this.yAxis];

		_BoundedObject.prototype.explore.call(this, context, instance);
	};

	_proto.render = function render(context, instance, key) {
		var _this = this;

		var data = instance.data;
		var bounds = data.bounds;
		if (!bounds.valid()) return null;
		return /*#__PURE__*/ jsxs(
			"g",
			{
				className: data.classNames,
				onMouseMove: function onMouseMove(e) {
					_this.handleMouseMove(e, instance);
				},
				onMouseLeave: function onMouseLeave(e) {
					_this.handleMouseLeave(e, instance);
				},
				children: [
					/*#__PURE__*/ jsx("rect", {
						x: bounds.l,
						y: bounds.t,
						width: bounds.width(),
						height: bounds.height(),
						fill: "transparent",
						strokeWidth: "0"
					}),
					this.renderChildren(context, instance)
				]
			},
			key
		);
	};

	_proto.handleMouseMove = function handleMouseMove(e, instance) {
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		var svgEl = closest(e.target, function(el) {
			return el.tagName == "svg";
		});
		var bounds = getTopLevelBoundingClientRect(svgEl);
		if (xAxis) instance.set("x", xAxis.trackValue(e.clientX - bounds.left));
		if (yAxis) instance.set("y", yAxis.trackValue(e.clientY - bounds.top));
		tooltipMouseMove(e, instance, instance.widget.tooltip);
	};

	_proto.handleMouseLeave = function handleMouseLeave(e, instance) {
		var xAxis = instance.xAxis,
			yAxis = instance.yAxis;
		tooltipMouseLeave(e, instance, instance.widget.tooltip);
		if (xAxis) instance.set("x", null);
		if (yAxis) instance.set("y", null);
	};

	return MouseTracker;
})(BoundedObject);
MouseTracker.prototype.xAxis = "x";
MouseTracker.prototype.yAxis = "y";
MouseTracker.prototype.anchors = "0 1 1 0";
MouseTracker.prototype.baseClass = "mousetracker";

var Stack = /*#__PURE__*/ (function() {
	function Stack() {
		this.reset();
	}

	var _proto = Stack.prototype;

	_proto.reset = function reset() {
		this.totals = {};
		this.values = {};
		this.normalized = false;
		this.invalid = {};
	};

	_proto.acknowledge = function acknowledge(ordinal, value) {
		if (value != null) {
			var v = this.totals[ordinal] || 0;
			this.totals[ordinal] = v + value;
		} else {
			this.invalid[ordinal] = true;
		}
	};

	_proto.measure = function measure(normalized) {
		if (normalized) {
			this.normalized = true;
			return [0, 1];
		}

		var max = 0,
			min = 0;

		for (var key in this.totals) {
			if (this.totals[key] > max) max = this.totals[key];
			if (this.totals[key] < min) min = this.totals[key];
		}

		return [min, max];
	};

	_proto.stack = function stack(ordinal, value) {
		if (value == null || this.invalid[ordinal]) return null;
		var base = this.values[ordinal] || 0;
		var result = (this.values[ordinal] = base + value);
		if (!this.normalized) return result;
		var total = this.totals[ordinal];
		if (total > 0) return result / total;
		return null;
	};

	return Stack;
})();

var NumericAxis = /*#__PURE__*/ (function(_Axis) {
	_inheritsLoose(NumericAxis, _Axis);

	function NumericAxis() {
		return _Axis.apply(this, arguments) || this;
	}

	var _proto = NumericAxis.prototype;

	_proto.init = function init() {
		if (this.deadZone) {
			this.lowerDeadZone = this.deadZone;
			this.upperDeadZone = this.deadZone;
		}

		_Axis.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Axis$prototype$decla;

		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					min: undefined,
					max: undefined,
					normalized: undefined,
					inverted: undefined,
					labelDivisor: undefined,
					format: undefined,
					lowerDeadZone: undefined,
					upperDeadZone: undefined
				}
			])
		);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.calculator = new NumericScale();
	};

	_proto.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);

		var _instance$data = instance.data,
			min = _instance$data.min,
			max = _instance$data.max,
			normalized = _instance$data.normalized,
			inverted = _instance$data.inverted,
			lowerDeadZone = _instance$data.lowerDeadZone,
			upperDeadZone = _instance$data.upperDeadZone;
		instance.calculator.reset(
			min,
			max,
			this.snapToTicks,
			this.tickDivisions,
			this.minTickDistance,
			this.minTickStep,
			this.minLabelDistance,
			this.minLabelTickSize,
			normalized,
			inverted,
			lowerDeadZone,
			upperDeadZone
		);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		if (!data.bounds.valid()) return null;
		var baseFormatter = Format.parse(data.format);
		var formatter =
			data.labelDivisor != 1
				? function(v) {
						return baseFormatter(v / data.labelDivisor);
				  }
				: baseFormatter;
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				style: data.style,
				children: this.renderTicksAndLabels(context, instance, formatter)
			},
			key
		);
	};

	NumericAxis.XY = function XY() {
		return {
			x: {
				type: NumericAxis
			},
			y: {
				type: NumericAxis,
				vertical: true
			}
		};
	};

	return NumericAxis;
})(Axis);
NumericAxis.prototype.baseClass = "numericaxis";
NumericAxis.prototype.tickDivisions = [
	[1, 2, 10, 20, 100],
	[1, 5, 10, 20, 100]
];
NumericAxis.prototype.snapToTicks = 1;
NumericAxis.prototype.normalized = false;
NumericAxis.prototype.format = "n";
NumericAxis.prototype.labelDivisor = 1;
NumericAxis.prototype.minLabelTickSize = 0;
NumericAxis.prototype.minTickStep = 0;
Axis.alias("numeric", NumericAxis);

var NumericScale = /*#__PURE__*/ (function() {
	function NumericScale() {}

	var _proto2 = NumericScale.prototype;

	_proto2.reset = function reset(
		min,
		max,
		snapToTicks,
		tickDivisions,
		minTickDistance,
		minTickStep,
		minLabelDistance,
		minLabelTickSize,
		normalized,
		inverted,
		lowerDeadZone,
		upperDeadZone
	) {
		this.min = min;
		this.max = max;
		this.snapToTicks = snapToTicks;
		this.tickDivisions = tickDivisions;
		this.minLabelDistance = minLabelDistance;
		this.minLabelTickSize = minLabelTickSize;
		this.minTickDistance = minTickDistance;
		this.minTickStep = minTickStep;
		this.tickSizes = [];
		this.normalized = normalized;
		this.inverted = inverted;
		delete this.minValue;
		delete this.maxValue;
		this.stacks = {};
		this.lowerDeadZone = lowerDeadZone || 0;
		this.upperDeadZone = upperDeadZone || 0;
	};

	_proto2.map = function map(v, offset) {
		if (offset === void 0) {
			offset = 0;
		}

		return this.origin + (v + offset - this.scale.min + this.scale.minPadding) * this.scale.factor;
	};

	_proto2.decodeValue = function decodeValue(n) {
		return n;
	};

	_proto2.encodeValue = function encodeValue(v) {
		return v;
	};

	_proto2.constrainValue = function constrainValue(v) {
		return Math.max(this.scale.min, Math.min(this.scale.max, v));
	};

	_proto2.trackValue = function trackValue(v, offset, constrain) {
		if (offset === void 0) {
			offset = 0;
		}

		if (constrain === void 0) {
			constrain = false;
		}

		var value = (v - this.origin) / this.scale.factor - offset + this.scale.min - this.scale.minPadding;
		if (constrain) value = this.constrainValue(v);
		return value;
	};

	_proto2.hash = function hash() {
		var _this = this;

		var r = {
			origin: this.origin,
			factor: this.scale.factor,
			min: this.scale.min,
			max: this.scale.max,
			minPadding: this.scale.minPadding,
			maxPadding: this.scale.maxPadding
		};
		r.stacks = Object.keys(this.stacks)
			.map(function(s) {
				return _this.stacks[s].info.join(",");
			})
			.join(":");
		return r;
	};

	_proto2.isSame = function isSame(x) {
		var hash = this.hash();
		var same =
			x &&
			!Object.keys(hash).some(function(k) {
				return x[k] !== hash[k];
			});
		this.shouldUpdate = !same;
		return same;
	};

	_proto2.measure = function measure(a, b) {
		this.a = a;
		this.b = b;

		for (var s in this.stacks) {
			var info = this.stacks[s].measure(this.normalized);
			var min = info[0],
				max = info[1],
				invalid = info[2];
			if (this.min == null || min < this.min) this.min = min;
			if (this.max == null || max > this.max) this.max = max;
			this.stacks[s].info = info;
		}

		if (this.minValue != null && this.min == null) this.min = this.minValue;
		if (this.min == null) this.min = 0;
		if (this.maxValue != null && this.max == null) this.max = this.maxValue;
		if (this.max == null) this.max = this.normalized ? 1 : 100;

		if (this.min == this.max) {
			if (this.min == 0) {
				this.min = -1;
				this.max = 1;
			} else {
				var delta = Math.abs(this.min) * 0.1;
				this.min -= delta;
				this.max += delta;
			}
		}

		this.origin = this.inverted ? this.b : this.a;
		this.scale = this.getScale();
		this.calculateTicks();
	};

	_proto2.getScale = function getScale(tickSizes) {
		var min = this.min,
			max = this.max;
		var smin = min;
		var smax = max;
		var tickSize;

		if (tickSizes && isNumber(this.snapToTicks) && tickSizes.length > 0) {
			tickSize = tickSizes[Math.min(tickSizes.length - 1, this.snapToTicks)];
			smin = Math.floor(smin / tickSize) * tickSize;
			smax = Math.ceil(smax / tickSize) * tickSize;
		} else {
			if (this.minValue === min) smin = this.minValuePadded;
			if (this.maxValue === max) smax = this.maxValuePadded;
		}

		var minPadding = this.minValue === min ? Math.max(0, smin - this.minValuePadded) : 0;
		var maxPadding = this.maxValue === max ? Math.max(0, this.maxValuePadded - smax) : 0;
		var sign = this.b > this.a ? 1 : -1;
		var factor =
			smin < smax
				? (Math.abs(this.b - this.a) - this.lowerDeadZone - this.upperDeadZone) /
				  (smax - smin + minPadding + maxPadding)
				: 0;
		if (factor < 0) factor = 0;

		if (factor > 0 && (this.lowerDeadZone > 0 || this.upperDeadZone > 0)) {
			while (factor * (min - smin) < this.lowerDeadZone) {
				smin -= this.lowerDeadZone / factor;
			}

			while (factor * (smax - max) < this.upperDeadZone) {
				smax += this.upperDeadZone / factor;
			}

			if (tickSize > 0 && isNumber(this.snapToTicks)) {
				smin = Math.floor(smin / tickSize) * tickSize;
				smax = Math.ceil(smax / tickSize) * tickSize;
				minPadding = this.minValue === min ? Math.max(0, smin - this.minValuePadded) : 0;
				maxPadding = this.maxValue === max ? Math.max(0, this.maxValuePadded - smax) : 0;
			}

			factor = smin < smax ? Math.abs(this.b - this.a) / (smax - smin + minPadding + maxPadding) : 0;
		}

		return {
			factor: sign * (this.inverted ? -factor : factor),
			min: smin,
			max: smax,
			minPadding: minPadding,
			maxPadding: maxPadding
		};
	};

	_proto2.acknowledge = function acknowledge(value, width, offset) {
		if (width === void 0) {
			width = 0;
		}

		if (offset === void 0) {
			offset = 0;
		}

		if (value == null) return;

		if (this.minValue == null || value < this.minValue) {
			this.minValue = value;
			this.minValuePadded = value + offset - width / 2;
		}

		if (this.maxValue == null || value > this.maxValue) {
			this.maxValue = value;
			this.maxValuePadded = value + offset + width / 2;
		}
	};

	_proto2.getStack = function getStack(name) {
		var s = this.stacks[name];
		if (!s) s = this.stacks[name] = new Stack();
		return s;
	};

	_proto2.stacknowledge = function stacknowledge(name, ordinal, value) {
		return this.getStack(name).acknowledge(ordinal, value);
	};

	_proto2.stack = function stack(name, ordinal, value) {
		var v = this.getStack(name).stack(ordinal, value);
		return v != null ? this.map(v) : null;
	};

	_proto2.findTickSize = function findTickSize(minPxDist) {
		var _this2 = this;

		return this.tickSizes.find(function(a) {
			return a >= _this2.minLabelTickSize && a * Math.abs(_this2.scale.factor) >= minPxDist;
		});
	};

	_proto2.getTickSizes = function getTickSizes() {
		return this.tickSizes;
	};

	_proto2.calculateTicks = function calculateTicks() {
		var _this3 = this;

		var dist = this.minLabelDistance / Math.abs(this.scale.factor);
		var unit = Math.pow(10, Math.floor(Math.log10(dist)));
		var bestLabelDistance = Infinity;
		var bestTicks = [];
		var bestScale = this.scale;

		var _loop = function _loop(i) {
			var divs = _this3.tickDivisions[i];
			var tickSizes = divs
				.filter(function(ts) {
					return ts >= _this3.minTickStep;
				})
				.map(function(ts) {
					return ts * unit;
				});

			var scale = _this3.getScale(tickSizes);

			tickSizes.forEach(function(size, level) {
				var labelDistance = size * Math.abs(scale.factor);

				if (labelDistance >= _this3.minLabelDistance && labelDistance < bestLabelDistance) {
					bestScale = scale;
					bestTicks = tickSizes;
					bestLabelDistance = labelDistance;
				}
			});
		};

		for (var i = 0; i < this.tickDivisions.length; i++) {
			_loop(i);
		}

		this.scale = bestScale;
		this.tickSizes = bestTicks.filter(function(ts) {
			return ts >= _this3.minTickStep && ts * Math.abs(bestScale.factor) >= _this3.minTickDistance;
		});

		if (this.tickSizes.length > 0) {
			var max = this.tickSizes[this.tickSizes.length - 1];
			this.tickSizes.push(2 * max);
			this.tickSizes.push(5 * max);
			this.tickSizes.push(10 * max);
			var min = this.tickSizes[0];

			var _dist = min * Math.abs(bestScale.factor) >= this.minTickDistance;

			if (min / 10 >= this.minTickStep && _dist / 10 >= this.minTickDistance) this.tickSizes.splice(0, 0, min / 10);
			else if (min / 5 >= this.minTickStep && _dist / 5 >= this.minTickDistance) this.tickSizes.splice(0, 0, min / 5);
			else if (min / 2 >= this.minTickStep && _dist / 2 >= this.minTickDistance) this.tickSizes.splice(0, 0, min / 2);
		}
	};

	_proto2.getTicks = function getTicks(tickSizes) {
		var _this4 = this;

		return tickSizes.map(function(size) {
			var start = Math.ceil((_this4.scale.min - _this4.scale.minPadding) / size);
			var end = Math.floor((_this4.scale.max + _this4.scale.maxPadding) / size);
			var result = [];

			for (var i = start; i <= end; i++) {
				result.push(i * size + 0);
			}

			return result;
		});
	};

	_proto2.mapGridlines = function mapGridlines() {
		var size = this.tickSizes[0];
		var start = Math.ceil((this.scale.min - this.scale.minPadding) / size);
		var end = Math.floor((this.scale.max + this.scale.maxPadding) / size);
		var result = [];

		for (var i = start; i <= end; i++) {
			result.push(this.map(i * size));
		}

		return result;
	};

	return NumericScale;
})();

var CategoryAxis = /*#__PURE__*/ (function(_Axis) {
	_inheritsLoose(CategoryAxis, _Axis);

	function CategoryAxis() {
		return _Axis.apply(this, arguments) || this;
	}

	var _proto = CategoryAxis.prototype;

	_proto.declareData = function declareData() {
		var _Axis$prototype$decla;

		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					inverted: undefined,
					uniform: undefined,
					names: undefined,
					values: undefined,
					minSize: undefined
				}
			])
		);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.calculator = new CategoryScale();
	};

	_proto.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);

		var _instance$data = instance.data,
			values = _instance$data.values,
			names = _instance$data.names,
			inverted = _instance$data.inverted,
			uniform = _instance$data.uniform,
			minSize = _instance$data.minSize;
		instance.calculator.reset(inverted, uniform, values, names, minSize);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			calculator = instance.calculator;
		if (!data.bounds.valid()) return null;

		var formatter = function formatter(v) {
			return calculator.names[v] || v;
		};

		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				style: data.style,
				children: this.renderTicksAndLabels(context, instance, formatter)
			},
			key
		);
	};

	return CategoryAxis;
})(Axis);
CategoryAxis.prototype.baseClass = "categoryaxis";
CategoryAxis.prototype.anchors = "0 1 1 0";
CategoryAxis.prototype.vertical = false;
CategoryAxis.prototype.inverted = false;
CategoryAxis.prototype.uniform = false;
CategoryAxis.prototype.labelOffset = 10;
CategoryAxis.prototype.labelRotation = 0;
CategoryAxis.prototype.labelAnchor = "auto";
CategoryAxis.prototype.labelDx = "auto";
CategoryAxis.prototype.labelDy = "auto";
CategoryAxis.prototype.minSize = 1;
Axis.alias("category", CategoryAxis);

var CategoryScale = /*#__PURE__*/ (function() {
	function CategoryScale() {}

	var _proto2 = CategoryScale.prototype;

	_proto2.reset = function reset(inverted, uniform, values, names, minSize) {
		var _this = this;

		this.padding = 0.5;
		delete this.min;
		delete this.max;
		delete this.minValue;
		delete this.maxValue;
		this.minSize = minSize;
		this.valuesMap = {};
		this.valueList = [];
		this.inverted = inverted;
		this.uniform = uniform;
		this.valueStacks = {};
		this.names = {};

		if (values) {
			if (isArray(values))
				values.forEach(function(v) {
					return _this.acknowledge(v);
				});
			else if (typeof values == "object")
				for (var k in values) {
					this.acknowledge(k);
					this.names[k] = values[k];
				}
		}

		if (names) {
			if (isArray(names)) {
				values = values || [];
				names.forEach(function(name, index) {
					var value = values[index];
					_this.names[value != null ? value : index] = name;
				});
			} else this.names = names;
		}
	};

	_proto2.decodeValue = function decodeValue(n) {
		return n;
	};

	_proto2.encodeValue = function encodeValue(v) {
		return v;
	};

	_proto2.map = function map(v, offset) {
		if (offset === void 0) {
			offset = 0;
		}

		var index = this.valuesMap[v] || 0;
		return this.origin + (index + offset - this.min + this.padding) * this.factor;
	};

	_proto2.measure = function measure(a, b) {
		this.a = a;
		this.b = b;
		if (this.min == null) this.min = this.minValue || 0;
		if (this.max == null) this.max = !isNaN(this.maxValue) ? this.maxValue : 100;
		var sign = this.inverted ? -1 : 1;

		if (this.max - this.min + 1 < this.minSize) {
			this.factor = (sign * (this.b - this.a)) / this.minSize;
			this.origin = (this.b + this.a) * 0.5 - (this.factor * (this.max - this.min + 1)) / 2;
		} else {
			this.factor = (sign * (this.b - this.a)) / (this.max - this.min + 2 * this.padding);
			this.origin = (this.a * (1 + sign)) / 2 + (this.b * (1 - sign)) / 2; //a || b
		}
	};

	_proto2.hash = function hash() {
		return {
			origin: this.origin,
			factor: this.factor,
			min: this.min,
			minSize: this.minSize,
			padding: this.padding,
			values: this.valueList.join(":"),
			names: JSON.stringify(this.names)
		};
	};

	_proto2.isSame = function isSame(x) {
		var h = this.hash();
		var same =
			x &&
			!Object.keys(h).some(function(k) {
				return x[k] !== h[k];
			});
		this.shouldUpdate = !same;
		return same;
	};

	_proto2.acknowledge = function acknowledge(value, width, offset) {
		if (width === void 0) {
			width = 0;
		}

		if (offset === void 0) {
			offset = 0;
		}

		var index = this.valuesMap[value];

		if (isUndefined(index)) {
			index = this.valueList.length;
			this.valueList.push(value);
			this.valuesMap[value] = index;
		}

		if (this.minValue == null || index < this.minValue) {
			this.minValue = index;
			this.padding = Math.max(this.padding, Math.abs(offset - width / 2));
		}

		if (this.maxValue == null || index > this.maxValue) {
			this.maxValue = index;
			this.padding = Math.max(this.padding, Math.abs(offset + width / 2));
		}
	};

	_proto2.book = function book(value, name) {
		if (this.uniform) value = 0;
		var stack = this.valueStacks[value];
		if (!stack)
			stack = this.valueStacks[value] = {
				index: {},
				count: 0
			};
		if (!stack.index.hasOwnProperty(name)) stack.index[name] = stack.count++;
	};

	_proto2.locate = function locate(value, name) {
		if (this.uniform) value = 0;
		var stack = this.valueStacks[value];
		if (!stack) return [0, 1];
		return [stack.index[name], stack.count];
	};

	_proto2.trackValue = function trackValue(v, offset, constrain) {
		if (offset === void 0) {
			offset = 0;
		}

		var index = Math.round((v - this.origin) / this.factor - offset + this.min - this.padding);
		if (index < this.min) index = this.min;
		if (index > this.max) index = this.max;
		return this.valueList[index];
	};

	_proto2.findTickSize = function findTickSize(minPxDist) {
		return 1;
	};

	_proto2.getTickSizes = function getTickSizes() {
		return [1];
	};

	_proto2.getTicks = function getTicks(tickSizes) {
		var _this2 = this;

		return tickSizes.map(function(size) {
			return _this2.valueList;
		});
	};

	_proto2.mapGridlines = function mapGridlines() {
		var _this3 = this;

		return Array.from({
			length: this.valueList.length + 1
		}).map(function(_, index) {
			return _this3.origin + (index - 0.5 - _this3.min + _this3.padding) * _this3.factor;
		});
	};

	return CategoryScale;
})();

Format$1.registerFactory("yearOrMonth", function(format) {
	var year = Format$1.parse("datetime;yyyy");
	var month = Format$1.parse("datetime;MMM");
	return function(date) {
		var d = new Date(date);
		if (d.getMonth() == 0) return year(d);
		else return month(d);
	};
});
Format$1.registerFactory("monthOrDay", function(format) {
	var month = Format$1.parse("datetime;MMM");
	var day = Format$1.parse("datetime;dd");
	return function(date) {
		var d = new Date(date);
		if (d.getDate() == 1) return month(d);
		else return day(d);
	};
});
var TimeAxis = /*#__PURE__*/ (function(_Axis) {
	_inheritsLoose(TimeAxis, _Axis);

	function TimeAxis() {
		return _Axis.apply(this, arguments) || this;
	}

	var _proto = TimeAxis.prototype;

	_proto.init = function init() {
		if (this.labelAnchor == "auto") this.labelAnchor = this.vertical ? (this.secondary ? "start" : "end") : "start";
		if (this.labelDx == "auto") this.labelDx = this.vertical ? 0 : "5px";

		if (this.deadZone) {
			this.lowerDeadZone = this.deadZone;
			this.upperDeadZone = this.deadZone;
		}

		_Axis.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Axis$prototype$decla;

		(_Axis$prototype$decla = _Axis.prototype.declareData).call.apply(
			_Axis$prototype$decla,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					anchors: undefined,
					min: undefined,
					max: undefined,
					inverted: undefined,
					lowerDeadZone: undefined,
					upperDeadZone: undefined
				}
			])
		);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.calculator = new TimeScale();
	};

	_proto.explore = function explore(context, instance) {
		_Axis.prototype.explore.call(this, context, instance);

		var _instance$data = instance.data,
			min = _instance$data.min,
			max = _instance$data.max,
			normalized = _instance$data.normalized,
			inverted = _instance$data.inverted,
			lowerDeadZone = _instance$data.lowerDeadZone,
			upperDeadZone = _instance$data.upperDeadZone;
		instance.calculator.reset(
			min,
			max,
			this.snapToTicks,
			this.tickDivisions,
			this.minTickDistance,
			this.minLabelDistance,
			normalized,
			inverted,
			this.minTickUnit,
			lowerDeadZone,
			upperDeadZone,
			this.decode
		);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			cached = instance.cached,
			calculator = instance.calculator;
		cached.axis = calculator.hash();
		if (!data.bounds.valid()) return null;
		var format = this.format || calculator.getFormat();
		var formatter = Format$1.parse(format);
		return /*#__PURE__*/ jsx(
			"g",
			{
				className: data.classNames,
				style: data.style,
				children: this.renderTicksAndLabels(context, instance, formatter)
			},
			key
		);
	};

	return TimeAxis;
})(Axis);
Axis.alias("time", TimeAxis);
TimeAxis.prototype.baseClass = "timeaxis";
TimeAxis.prototype.tickDivisions = {
	second: [[1, 5, 15, 30]],
	minute: [[1, 5, 15, 30]],
	hour: [
		[1, 2, 4, 8],
		[1, 3, 6, 12]
	],
	day: [[1]],
	week: [[1]],
	month: [[1, 3, 6]],
	year: [
		[1, 2, 10],
		[1, 5, 10],
		[5, 10, 50],
		[10, 50, 100]
	]
};
TimeAxis.prototype.snapToTicks = 0;
TimeAxis.prototype.tickSize = 15;
TimeAxis.prototype.minLabelDistance = 60;
TimeAxis.prototype.minTickDistance = 60;
TimeAxis.prototype.minTickUnit = "second";

function monthNumber(date) {
	return date.getFullYear() * 12 + date.getMonth() + (date.getDate() - 1) / 31;
}

function yearNumber(date) {
	return monthNumber(date) / 12;
}

var miliSeconds = {
	second: 1000,
	minute: 60 * 1000,
	hour: 3600 * 1000,
	day: 3600 * 24 * 1000,
	week: 3600 * 24 * 7 * 1000,
	month: 3600 * 24 * 30 * 1000,
	year: 3600 * 24 * 365 * 1000
};

var TimeScale = /*#__PURE__*/ (function() {
	function TimeScale() {}

	var _proto2 = TimeScale.prototype;

	_proto2.reset = function reset(
		min,
		max,
		snapToTicks,
		tickDivisions,
		minTickDistance,
		minLabelDistance,
		normalized,
		inverted,
		minTickUnit,
		lowerDeadZone,
		upperDeadZone,
		decode
	) {
		this.dateCache = {};
		this.min = min != null ? this.decodeValue(min) : null;
		this.max = max != null ? this.decodeValue(max) : null;
		this.snapToTicks = snapToTicks;
		this.tickDivisions = tickDivisions;
		this.minLabelDistance = minLabelDistance;
		this.minTickDistance = minTickDistance;
		this.tickSizes = [];
		this.normalized = normalized;
		this.minTickUnit = minTickUnit;
		this.inverted = inverted;
		this.lowerDeadZone = lowerDeadZone || 0;
		this.upperDeadZone = upperDeadZone || 0;
		delete this.minValue;
		delete this.maxValue;
		delete this.minValuePadded;
		delete this.maxValuePadded;
		this.stacks = {};
		this.decode = decode;
	};

	_proto2.decodeValue = function decodeValue(date) {
		if (date instanceof Date) return date.getTime();

		switch (typeof date) {
			case "string":
				var v = this.dateCache[date];

				if (!v) {
					if (this.decode) date = this.decode(date);
					v = this.dateCache[date] = Date.parse(date);
				}

				return v;

			case "number":
				return date;
		}
	};

	_proto2.encodeValue = function encodeValue(v) {
		return new Date(v).toISOString();
	};

	_proto2.getFormat = function getFormat() {
		switch (this.tickMeasure) {
			case "year":
				return "datetime;yyyy";

			case "month":
				if (new Date(this.scale.min).getFullYear() != new Date(this.scale.max).getFullYear()) return "yearOrMonth";
				return "datetime;yyyy MMM";

			case "week":
				return "datetime;MMMdd";

			case "day":
				if (
					new Date(this.scale.min).getFullYear() != new Date(this.scale.max).getFullYear() ||
					new Date(this.scale.min).getMonth() != new Date(this.scale.max).getMonth()
				)
					return "monthOrDay";
				return "datetime;yyyy MMM dd";

			case "hour":
				return "datetime;HH mm n";

			case "minute":
				return "datetime;HH mm n";

			case "second":
				return "datetime;mm ss";

			default:
				return "datetime;yyyy MMM dd HH mm ss n";
		}
	};

	_proto2.map = function map(v, offset) {
		if (offset === void 0) {
			offset = 0;
		}

		return this.origin + (this.decodeValue(v) + offset - this.scale.min + this.scale.minPadding) * this.scale.factor;
	};

	_proto2.constrainValue = function constrainValue(v) {
		return Math.max(this.scale.min, Math.min(this.scale.max, v));
	};

	_proto2.trackValue = function trackValue(v, offset, constrain) {
		if (offset === void 0) {
			offset = 0;
		}

		if (constrain === void 0) {
			constrain = false;
		}

		var value = (v - this.origin) / this.scale.factor - offset + this.scale.min - this.scale.minPadding;
		if (constrain) value = this.constrainValue(value);
		return value;
	};

	_proto2.hash = function hash() {
		var _this = this;

		var r = {
			origin: this.origin,
			factor: this.scale.factor,
			min: this.scale.min,
			max: this.scale.max,
			minPadding: this.scale.minPadding,
			maxPadding: this.scale.maxPadding
		};
		r.stacks = Object.keys(this.stacks)
			.map(function(s) {
				return _this.stacks[s].info.join(",");
			})
			.join(":");
		return r;
	};

	_proto2.isSame = function isSame(x) {
		var hash = this.hash();
		var same =
			x &&
			!Object.keys(hash).some(function(k) {
				return x[k] !== hash[k];
			});
		this.shouldUpdate = !same;
		return same;
	};

	_proto2.measure = function measure(a, b) {
		this.a = a;
		this.b = b;

		for (var s in this.stacks) {
			var info = this.stacks[s].measure(this.normalized);
			var min = info[0],
				max = info[1],
				invalid = info[2];
			if (this.minValue == null || min < this.minValue) this.minValue = min;
			if (this.max == null || max > this.maxValue) this.maxValue = max;
			this.stacks[s].info = info;
		}

		if (this.min == null) {
			if (this.minValue != null) this.min = this.minValue;
			else this.min = 0;
		}

		if (this.max == null) {
			if (this.maxValue != null) this.max = this.maxValue;
			else this.max = this.normalized ? 1 : 100;
		}

		this.origin = this.inverted ? this.b : this.a;
		this.scale = this.getScale();
		this.calculateTicks();
	};

	_proto2.getTimezoneOffset = function getTimezoneOffset(date) {
		return date.getTimezoneOffset() * 60 * 1000;
	};

	_proto2.getScale = function getScale(tickSizes, measure) {
		var min = this.min,
			max = this.max,
			upperDeadZone = this.upperDeadZone,
			lowerDeadZone = this.lowerDeadZone;
		var smin = min;
		var smax = max;

		if (isNumber(this.snapToTicks) && measure && tickSizes && 0 <= this.snapToTicks && tickSizes.length > 0) {
			var tickSize = tickSizes[Math.min(tickSizes.length - 1, this.snapToTicks)];
			var minDate = new Date(min);
			var maxDate = new Date(max);

			switch (measure) {
				case "second":
				case "minute":
				case "hours":
				case "day":
				default:
					var minOffset = this.getTimezoneOffset(minDate);
					var maxOffset = this.getTimezoneOffset(maxDate);
					var mondayOffset = 4 * miliSeconds.day; //new Date(0).getDay() => 4

					smin = Math.floor((smin - minOffset - mondayOffset) / tickSize) * tickSize + minOffset + mondayOffset;
					smax = Math.ceil((smax - maxOffset - mondayOffset) / tickSize) * tickSize + maxOffset + mondayOffset;
					break;

				case "month":
					tickSize /= miliSeconds.month;
					var minMonth = monthNumber(minDate);
					var maxMonth = monthNumber(maxDate);
					minMonth = Math.floor(minMonth / tickSize) * tickSize;
					maxMonth = Math.ceil(maxMonth / tickSize) * tickSize;
					smin = new Date(Math.floor(minMonth / 12), minMonth % 12, 1).getTime();
					smax = new Date(Math.floor(maxMonth / 12), maxMonth % 12, 1).getTime();
					break;

				case "year":
					tickSize /= miliSeconds.year;
					var minYear = yearNumber(minDate);
					var maxYear = yearNumber(maxDate);
					minYear = Math.floor(minYear / tickSize) * tickSize;
					maxYear = Math.ceil(maxYear / tickSize) * tickSize;
					smin = new Date(minYear, 0, 1).getTime();
					smax = new Date(maxYear, 0, 1).getTime();
					break;
			}
		} else {
			if (this.minValue == min) smin = this.minValuePadded;
			if (this.maxValue == max) smax = this.maxValuePadded;
		} //padding should be activated only if using min/max obtained from the data

		var minPadding = this.minValue === min ? Math.max(0, smin - this.minValuePadded) : 0;
		var maxPadding = this.maxValue === max ? Math.max(0, this.maxValuePadded - smax) : 0;
		var factor = smin < smax ? Math.abs(this.b - this.a) / (smax - smin + minPadding + maxPadding) : 0;

		if (factor > 0 && (upperDeadZone > 0 || lowerDeadZone > 0)) {
			smin -= lowerDeadZone / factor;
			smax += upperDeadZone / factor;
			minPadding = this.minValuePadded != null ? Math.max(0, smin - this.minValuePadded) : 0;
			maxPadding = this.maxValuePadded != null ? Math.max(0, this.maxValuePadded - smax) : 0;
			factor = smin < smax ? Math.abs(this.b - this.a) / (smax - smin + minPadding + maxPadding) : 0;
		}

		var sign = this.b > this.a ? 1 : -1;
		return {
			factor: sign * (this.inverted ? -factor : factor),
			min: smin,
			max: smax,
			minPadding: minPadding,
			maxPadding: maxPadding
		};
	};

	_proto2.acknowledge = function acknowledge(value, width, offset) {
		if (width === void 0) {
			width = 0;
		}

		if (offset === void 0) {
			offset = 0;
		}

		value = this.decodeValue(value);

		if (this.minValue == null || value + offset - width / 2 < this.minValuePadded) {
			this.minValue = value;
			this.minValuePadded = value + offset - width / 2;
		}

		if (this.maxValue == null || value + offset + width / 2 > this.maxValuePadded) {
			this.maxValue = value;
			this.maxValuePadded = value + offset + width / 2;
		}
	};

	_proto2.getStack = function getStack(name) {
		var s = this.stacks[name];
		if (!s) s = this.stacks[name] = new Stack();
		return s;
	};

	_proto2.stacknowledge = function stacknowledge(name, ordinal, value) {
		return this.getStack(name).acknowledge(ordinal, value);
	};

	_proto2.stack = function stack(name, ordinal, value) {
		var v = this.getStack(name).stack(ordinal, value);
		return v != null ? this.map(v) : null;
	};

	_proto2.findTickSize = function findTickSize(minPxDist) {
		var _this2 = this;

		return this.tickSizes.find(function(a) {
			return a * Math.abs(_this2.scale.factor) >= minPxDist;
		});
	};

	_proto2.getTickSizes = function getTickSizes() {
		return this.tickSizes;
	};

	_proto2.calculateTicks = function calculateTicks() {
		var _this3 = this;

		var minReached = false;

		var _loop = function _loop(unit) {
			if (!minReached) {
				if (unit == _this3.minTickUnit) minReached = true;
				else return "continue";
			}

			var unitSize = miliSeconds[unit];
			var divisions = _this3.tickDivisions[unit];

			if (_this3.tickSizes.length > 0) {
				var _this3$tickSizes;

				//add ticks from higher levels
				(_this3$tickSizes = _this3.tickSizes).push.apply(
					_this3$tickSizes,
					divisions[0].map(function(s) {
						return s * unitSize;
					})
				);

				return "continue";
			}

			var bestLabelDistance = Infinity;
			var bestTicks = [];
			var bestScale = _this3.scale;
			_this3.tickMeasure = unit;

			var _loop2 = function _loop2(i) {
				var divs = divisions[i];
				var tickSizes = divs.map(function(s) {
					return s * unitSize;
				});

				var scale = _this3.getScale(tickSizes, unit);

				tickSizes.forEach(function(size, level) {
					var tickDistance = size * Math.abs(scale.factor);

					if (tickDistance >= _this3.minTickDistance && tickDistance < bestLabelDistance) {
						bestScale = scale;
						bestTicks = tickSizes;
						bestLabelDistance = tickDistance;
					}
				});
			};

			for (var i = 0; i < divisions.length; i++) {
				_loop2(i);
			}

			_this3.scale = bestScale;
			_this3.tickSizes = bestTicks.filter(function(ts) {
				return ts * Math.abs(bestScale.factor) >= _this3.minTickDistance;
			});
		};

		for (var unit in miliSeconds) {
			var _ret = _loop(unit);

			if (_ret === "continue") continue;
		}
	};

	_proto2.getTicks = function getTicks(tickSizes) {
		var _this4 = this;

		return tickSizes.map(function(size) {
			var result = [],
				start,
				end,
				minDate,
				maxDate;

			if (_this4.tickMeasure == "year") {
				size /= miliSeconds.year;
				minDate = new Date(_this4.scale.min - _this4.scale.minPadding);
				maxDate = new Date(_this4.scale.max + _this4.scale.maxPadding);
				start = Math.ceil(yearNumber(minDate) / size) * size;
				end = Math.floor(yearNumber(maxDate) / size) * size;

				for (var i = start; i <= end; i += size) {
					result.push(new Date(i, 0, 1).getTime());
				}
			} else if (_this4.tickMeasure == "month") {
				size /= miliSeconds.month;
				minDate = new Date(_this4.scale.min - _this4.scale.minPadding);
				maxDate = new Date(_this4.scale.max + _this4.scale.maxPadding);
				start = Math.ceil(monthNumber(minDate) / size) * size;
				end = Math.floor(monthNumber(maxDate) / size) * size;

				for (var _i = start; _i <= end; _i += size) {
					result.push(new Date(Math.floor(_i / 12), _i % 12, 1).getTime());
				}
			} else if (_this4.tickMeasure == "day" || _this4.tickMeasure == "week") {
				var multiplier = _this4.tickMeasure == "week" ? 7 : 1;
				size /= miliSeconds.day;
				minDate = new Date(_this4.scale.min - _this4.scale.minPadding);
				maxDate = new Date(_this4.scale.max + _this4.scale.maxPadding);
				var date = zeroTime(minDate);

				if (_this4.tickMeasure == "week") {
					//start on monday
					while (date.getDay() != 1) {
						date.setDate(date.getDate() + 1);
					}
				}

				while (date.getTime() <= maxDate.getTime()) {
					result.push(date);
					date = new Date(date);
					date.setDate(date.getDate() + multiplier);
				}
			} else {
				var minOffset = _this4.getTimezoneOffset(new Date(_this4.scale.min - _this4.scale.minPadding));

				var mondayOffset = 4 * miliSeconds.day;

				var _date =
					Math.ceil((_this4.scale.min - _this4.scale.minPadding - minOffset - mondayOffset) / size) * size +
					minOffset +
					mondayOffset;

				while (_date <= _this4.scale.max + _this4.scale.maxPadding) {
					result.push(_date);
					_date += size;
				}
			}

			return result;
		});
	};

	_proto2.mapGridlines = function mapGridlines() {
		var _this5 = this;

		if (this.tickSizes.length == 0) return [];
		return this.getTicks([this.tickSizes[0]])[0].map(function(x) {
			return _this5.map(x);
		});
	};

	return TimeScale;
})();

var PointReducer = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(PointReducer, _PureContainer);

	function PointReducer() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = PointReducer.prototype;

	_proto.explore = function explore(context, instance) {
		var _this = this;

		var pointReducer = context.pointReducer;
		instance.parentPointTracker = pointReducer;

		if (!instance.pointReducer) {
			var onMap = this.onMap && instance.getCallback("onMap");
			var accumulator = {};

			instance.resetAccumulator = function() {
				accumulator = {};
				if (_this.onInitAccumulator) instance.invoke("onInitAccumulator", accumulator, instance);
			};

			instance.pointReducer = function(x, y, name, data, array, index) {
				onMap(accumulator, x, y, name, data, array, index);
				if (pointReducer) pointReducer(x, y, name, data, array, index);
			};

			instance.write = function() {
				if (_this.onReduce) instance.invoke("onReduce", accumulator, instance);
			};
		}

		instance.resetAccumulator();
		context.push("pointReducer", instance.pointReducer);

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		instance.write();
		context.pop("pointReducer");
	};

	return PointReducer;
})(PureContainer);

var MinMaxFinder = /*#__PURE__*/ (function(_PointReducer) {
	_inheritsLoose(MinMaxFinder, _PointReducer);

	function MinMaxFinder() {
		return _PointReducer.apply(this, arguments) || this;
	}

	var _proto = MinMaxFinder.prototype;

	_proto.declareData = function declareData() {
		var _PointReducer$prototy;

		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					minX: undefined,
					minY: undefined,
					maxX: undefined,
					maxY: undefined,
					params: {
						structured: true
					}
				}
			])
		);
	};

	_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data;
		acc.params = data.params;
		acc.min = {
			x: null,
			y: null
		};
		acc.max = {
			x: null,
			y: null
		};
	};

	_proto.onMap = function onMap(acc, x, y, name, p) {
		if (y != null && (acc.max.y == null || acc.max.y < y))
			acc.max = {
				x: x,
				y: y,
				p: p
			};
		if (y != null && (acc.min.y == null || acc.min.y > y))
			acc.min = {
				x: x,
				y: y,
				p: p
			};
	};

	_proto.onReduce = function onReduce(acc, instance) {
		instance.set("minX", acc.min.x);
		instance.set("minY", acc.min.y);
		instance.set("minRecord", acc.min.p);
		instance.set("maxX", acc.max.x);
		instance.set("maxY", acc.max.y);
		instance.set("maxRecord", acc.max.p);
	};

	return MinMaxFinder;
})(PointReducer);

var SnapPointFinder = /*#__PURE__*/ (function(_PointReducer) {
	_inheritsLoose(SnapPointFinder, _PointReducer);

	function SnapPointFinder() {
		return _PointReducer.apply(this, arguments) || this;
	}

	var _proto = SnapPointFinder.prototype;

	_proto.declareData = function declareData() {
		var _PointReducer$prototy;

		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					cursorX: undefined,
					cursorY: undefined,
					snapX: undefined,
					snapY: undefined,
					snapRecord: undefined,
					maxDistance: undefined
				}
			])
		);
	};

	_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data;
		acc.cursorX = data.cursorX;
		acc.cursorY = data.cursorY;
		acc.dist = data.maxDistance > 0 ? Math.pow(data.maxDistance, 2) : Number.POSITIVE_INFINITY;
		acc.snapX = null;
		acc.snapY = null;
	};

	_proto.onMap = function onMap(acc, x, y, name, p) {
		var d = null;
		if (acc.cursorX != null && x != null) d = (d || 0) + Math.pow(Math.abs(x - acc.cursorX), 2);
		if (acc.cursorY != null && y != null) d = (d || 0) + Math.pow(Math.abs(y - acc.cursorY), 2);

		if (d != null && d < acc.dist) {
			acc.dist = d;
			acc.snapX = x;
			acc.snapY = y;
			acc.snapRecord = p;
		}
	};

	_proto.onReduce = function onReduce(acc, instance) {
		instance.set("snapX", acc.snapX);
		instance.set("snapY", acc.snapY);
		instance.set("snapRecord", acc.snapRecord);
	};

	return SnapPointFinder;
})(PointReducer);
SnapPointFinder.prototype.maxDistance = 50;

var ValueAtFinder = /*#__PURE__*/ (function(_PointReducer) {
	_inheritsLoose(ValueAtFinder, _PointReducer);

	function ValueAtFinder() {
		return _PointReducer.apply(this, arguments) || this;
	}

	var _proto = ValueAtFinder.prototype;

	_proto.declareData = function declareData() {
		var _PointReducer$prototy;

		return (_PointReducer$prototy = _PointReducer.prototype.declareData).call.apply(
			_PointReducer$prototy,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					at: undefined,
					value: undefined
				}
			])
		);
	};

	_proto.onInitAccumulator = function onInitAccumulator(acc, _ref) {
		var data = _ref.data;
		acc.at = this.convert(data.at);
	};

	_proto.onMap = function onMap(acc, x, y, name) {
		var d = this.convert(x) - acc.at;

		if (d <= 0 && (!acc.left || acc.left.d < d)) {
			acc.left = {
				x: x,
				y: y,
				d: d
			};
		}

		if (d >= 0 && (!acc.right || acc.right.d > d)) {
			acc.right = {
				x: x,
				y: y,
				d: d
			};
		}
	};

	_proto.onReduce = function onReduce(acc, instance) {
		var y = null;

		if (acc.left && acc.right) {
			if (acc.left.x == acc.right.x) y = acc.left.y;
			else if (acc.left.y != null && acc.right.y != null) {
				y = acc.left.y + ((acc.right.y - acc.left.y) * (acc.at - acc.left.x)) / (acc.right.x - acc.left.x);
			}
		}

		instance.set("value", y);
	};

	return ValueAtFinder;
})(PointReducer);

ValueAtFinder.prototype.convert = function(x) {
	return x;
};

export {
	Axis,
	Bar,
	BarGraph,
	BubbleGraph,
	CategoryAxis,
	Chart,
	ColorIndex,
	ColorMap,
	ColorMapScope,
	Column,
	ColumnGraph,
	Gridlines,
	Legend,
	LegendEntry,
	LegendScope,
	LineGraph,
	Marker,
	MarkerLine,
	MinMaxFinder,
	MouseTracker,
	NumericAxis,
	Pie,
	PieChart,
	PieSlice,
	PointReducer,
	Range,
	ScatterGraph,
	SnapPointFinder,
	TimeAxis,
	ValueAtFinder,
	bar,
	circle,
	column,
	getAvailableShapes,
	getShape,
	line,
	registerShape,
	square,
	triangle,
	vline
};
