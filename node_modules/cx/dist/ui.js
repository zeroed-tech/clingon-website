import {
	computable,
	StoreProxy,
	StructuredSelector,
	invalidateExpressionCache,
	invalidateStringTemplateCache,
	defaultCompare,
	getAccessor,
	ArrayElementView,
	ReadOnlyDataView,
	sorter,
	getSelector,
	Binding,
	ZoomIntoPropertyView,
	SubscribableView,
	Store,
	NestedDataView,
	Grouper,
	getComparer
} from "cx/data";
export { computable } from "cx/data";
import {
	isArray,
	isFunction,
	Component,
	parseStyle,
	Console,
	isString,
	isDefined,
	innerTextTrim,
	GlobalCacheIdentifier,
	isObject,
	SubscriberList,
	getActiveElement,
	closestParent,
	isFocusable,
	isTouchEvent,
	isSelfOrDescendant,
	findFirst,
	findFirstChild,
	Format as Format$1,
	resolveMinMaxFractionDigits,
	isNonEmptyArray,
	debug,
	processDataFlag,
	renderFlag,
	destroyFlag,
	validatedDebounce,
	throttle,
	isUndefined,
	TraversalStack,
	reverseSlice,
	appDataFlag,
	onIdleCallback,
	shallowEquals,
	now,
	Timing,
	vdomRenderFlag,
	appLoopFlag,
	isPromise,
	dummyCallback,
	isComponentFactory,
	createComponentFactory,
	isNumber
} from "cx/util";
import { VDOM as VDOM$2 } from "cx-react";
import { NumberCulture, DateTimeCulture } from "intl-io";
import { jsx, jsxs } from "react/jsx-runtime";

function _defineProperties(target, props) {
	for (var i = 0; i < props.length; i++) {
		var descriptor = props[i];
		descriptor.enumerable = descriptor.enumerable || false;
		descriptor.configurable = true;
		if ("value" in descriptor) descriptor.writable = true;
		Object.defineProperty(target, descriptor.key, descriptor);
	}
}

function _createClass(Constructor, protoProps, staticProps) {
	if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	if (staticProps) _defineProperties(Constructor, staticProps);
	return Constructor;
}

function _defineProperty(obj, key, value) {
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}

	return obj;
}

function ownKeys(object, enumerableOnly) {
	var keys = Object.keys(object);

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object);
		if (enumerableOnly)
			symbols = symbols.filter(function(sym) {
				return Object.getOwnPropertyDescriptor(object, sym).enumerable;
			});
		keys.push.apply(keys, symbols);
	}

	return keys;
}

function _objectSpread2(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};

		if (i % 2) {
			ownKeys(Object(source), true).forEach(function(key) {
				_defineProperty(target, key, source[key]);
			});
		} else if (Object.getOwnPropertyDescriptors) {
			Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
		} else {
			ownKeys(Object(source)).forEach(function(key) {
				Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
			});
		}
	}

	return target;
}

function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;

	_setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
	_setPrototypeOf =
		Object.setPrototypeOf ||
		function _setPrototypeOf(o, p) {
			o.__proto__ = p;
			return o;
		};

	return _setPrototypeOf(o, p);
}

function _assertThisInitialized(self) {
	if (self === void 0) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	}

	return self;
}

var computablePrefix = "computable-";
var triggerPrefix = "trigger-";
var Controller = /*#__PURE__*/ (function(_Component) {
	_inheritsLoose(Controller, _Component);

	function Controller() {
		return _Component.apply(this, arguments) || this;
	}

	var _proto = Controller.prototype;

	_proto.init = function init(context) {
		if (!this.initialized) {
			this.initialized = true;
			if (this.onInit) this.onInit(context);
		}
	};

	_proto.explore = function explore(context) {
		var store = this.instance.store;
		this.store = store; //in rare cases instance may change its store

		if (!this.initialized) {
			this.init(context); //forgive if the developer forgets to call super.init()

			this.initialized = true;
		}

		if (this.computables) {
			for (var key in this.computables) {
				var x = this.computables[key];
				var v = x.selector(store.getData());
				if (x.type == "computable") store.set(x.name, v);
			}
		}

		if (this.onExplore) {
			this.onExplore(context);
		}
	};

	_proto.prepare = function prepare(context) {
		if (this.onPrepare) {
			this.onPrepare(context);
		}
	};

	_proto.cleanup = function cleanup(context) {
		if (this.onCleanup) {
			this.onCleanup(context);
		}
	};

	_proto.addComputable = function addComputable(name, args, callback) {
		if (!isArray(args)) throw new Error("Second argument to the addComputable method should be an array.");
		var selector = computable.apply(void 0, args.concat([callback])).memoize();
		if (!this.computables) this.computables = {};
		this.computables[computablePrefix + name] = {
			name: name,
			selector: selector,
			type: "computable"
		};
	};

	_proto.addTrigger = function addTrigger(name, args, callback, autoRun) {
		if (!isArray(args)) throw new Error("Second argument to the addTrigger method should be an array.");
		var selector = computable.apply(void 0, args.concat([callback])).memoize(!autoRun && this.store.getData());
		if (!this.computables) this.computables = {};
		this.computables[triggerPrefix + name] = {
			name: name,
			selector: selector,
			type: "trigger"
		};
	};

	_proto.removeTrigger = function removeTrigger(name) {
		if (this.computables) delete this.computables[triggerPrefix + name];
	};

	_proto.removeComputable = function removeComputable(name) {
		if (this.computables) delete this.computables[computablePrefix + name];
	};

	_proto.invokeParentMethod = function invokeParentMethod(methodName) {
		var parent = this.instance.parent;

		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return parent.invokeControllerMethod.apply(parent, [methodName].concat(args));
	};

	_proto.invokeMethod = function invokeMethod(methodName) {
		var _this$instance;

		for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
			args[_key2 - 1] = arguments[_key2];
		}

		return (_this$instance = this.instance).invokeControllerMethod.apply(_this$instance, [methodName].concat(args));
	};

	return Controller;
})(Component);
Controller.namespace = "ui.controller.";

Controller.factory = function(alias, config, more) {
	if (isFunction(alias)) {
		var cfg = _objectSpread2(_objectSpread2({}, config), more);

		if (cfg.instance) {
			//in rare cases instance.store may change, so we cannot rely on the store passed through configuration
			cfg.store = new StoreProxy(function() {
				return cfg.instance.store;
			});
			Object.assign(cfg, cfg.store.getMethods());
		}

		var result = alias(cfg);
		if (result instanceof Controller) return result;
		return Controller.create(_objectSpread2(_objectSpread2(_objectSpread2({}, config), more), result));
	}

	return Controller.create(_objectSpread2(_objectSpread2({}, config), more));
};

var cssHelperCache = {};
var CSSHelper = /*#__PURE__*/ (function() {
	function CSSHelper() {}

	CSSHelper.get = function get(code) {
		var helper = cssHelperCache[code];
		if (!helper) throw new Error("Unknown CSS helper '" + code + "'.");
		return helper;
	};

	CSSHelper.register = function register(code, helper) {
		cssHelperCache[code] = helper;
	};

	CSSHelper.alias = function alias(code, helper) {
		cssHelperCache[code] = helper;
	};

	return CSSHelper;
})();

function push(list, item) {
	if (!item) return list;
	if (!list) list = [];
	list.push(item);
	return list;
}

function pushMore(list, itemArray) {
	if (!itemArray || itemArray.length == 0) return list;
	if (!list) list = [];
	list.push.apply(list, itemArray);
	return list;
}

function pushMap(list, itemArray, mapF) {
	return itemArray ? pushMore(list, itemArray.map(mapF)) : list;
}

function join(list) {
	return list ? list.join(" ") : null;
}

var CSS = /*#__PURE__*/ (function() {
	function CSS() {}

	CSS.resolve = function resolve() {
		var list, type, arg, i, key;

		for (i = 0; i < arguments.length; i++) {
			arg = arguments[i];

			if (arg) {
				type = typeof arg;
				if (type == "string") list = push(list, arg);
				else if (type == "object") {
					if (isArray(arg)) list = pushMore(list, this.resolve.apply(this, arg));
					else
						for (key in arg) {
							if (arg[key]) list = push(list, key);
						}
				}
			}
		}

		return list;
	};

	CSS.block = function block(baseClass, styleModifiers, stateModifiers) {
		var _this = this;

		var list;
		if (baseClass) list = push(list, this.classPrefix + "b-" + baseClass);
		list = pushMap(list, this.resolve(styleModifiers), function(m) {
			return _this.classPrefix + "m-" + m;
		});
		list = pushMap(list, this.resolve(stateModifiers), function(m) {
			return _this.classPrefix + "s-" + m;
		});
		return join(list);
	};

	CSS.element = function element(baseClass, elementClass, stateModifiers) {
		var _this2 = this;

		var list;
		if (baseClass && elementClass) list = push(list, this.classPrefix + "e-" + baseClass + "-" + elementClass);
		list = pushMap(list, this.resolve(stateModifiers), function(m) {
			return _this2.classPrefix + "s-" + m;
		});
		return join(list);
	};

	CSS.state = function state(stateModifiers) {
		var _this3 = this;

		return join(
			pushMap(null, this.resolve(stateModifiers), function(m) {
				return _this3.classPrefix + "s-" + m;
			})
		);
	};

	CSS.mod = function mod(mods) {
		var _this4 = this;

		return join(
			pushMap(null, this.resolve(mods), function(m) {
				return _this4.classPrefix + "m-" + m;
			})
		);
	};

	CSS.expand = function expand() {
		return join(this.resolve.apply(this, arguments));
	};

	CSS.parseStyle = function parseStyle$1(str) {
		return parseStyle(str);
	};

	return CSS;
})();
CSS.classPrefix = "cx";
CSSHelper.alias("cx", CSS);

var VDOM = VDOM$2;

var VDOM$1 = VDOM;
var widgetId = 100;
var Widget = /*#__PURE__*/ (function(_Component) {
	_inheritsLoose(Widget, _Component);

	function Widget(config) {
		var _this;

		_this = _Component.call(this, config) || this;
		_this.widgetId = widgetId++;

		if (isArray(_this.jsxSpread)) {
			if (!_this.jsxAttributes) _this.jsxAttributes = [];

			_this.jsxSpread.forEach(function(spread) {
				for (var key in spread) {
					_this[key] = spread[key];

					_this.jsxAttributes.push(key);
				}
			});
		}

		return _this;
	}

	var _proto = Widget.prototype;

	_proto.init = function init() {
		if (this.styles) this.style = this.styles;
		if (this.styled) this.style = parseStyle(this.style);
		else if (this.style) {
			Console.warn(
				"Components that allow use of the style attribute should set styled = true on their prototype. This will be an error in future versions."
			);
			this.style = parseStyle(this.style);
			this.styled = true;
		}
		if (typeof this["if"] !== "undefined") this.visible = this["if"];
		this.declareData();

		if (this.outerLayout) {
			if (isArray(this.outerLayout)) throw new Error("Only single element outer layout is supported."); //TODO: better handle the case when outer layout is an array. How to get around circular dependency to PureContainer

			this.outerLayout = Widget.create(this.outerLayout);
		}

		if (this.contentFor) this.putInto = this.contentFor;
		if (this.putInto) this.isContent = true;
		if (isString(this.CSS)) this.CSS = CSSHelper.get(this.CSS);
		this.initHelpers();
		this.initComponents();
		this.initialized = true;
	};

	_proto.initComponents = function initComponents() {
		if (arguments.length > 0) {
			this.components = Object.assign.apply(Object, arguments);

			for (var k in this.components) {
				if (!this.components[k]) delete this.components[k];
			}
		}
	};

	_proto.initHelpers = function initHelpers() {
		if (arguments.length > 0) {
			this.helpers = Object.assign.apply(Object, arguments);
		}
	};

	_proto.declareData = function declareData() {
		var options = {};
		if (this.styled)
			options["class"] = options.className = options.style = {
				structured: true
			};

		var props = _objectSpread2(
			{
				visible: undefined,
				mod: {
					structured: true
				}
			},
			options
		);

		Object.assign.apply(Object, [props].concat(Array.prototype.slice.call(arguments)));
		this.selector = new StructuredSelector({
			props: props,
			values: this
		});
		this.nameMap = this.selector.nameMap;
	};

	_proto.prepareCSS = function prepareCSS(context, _ref) {
		var data = _ref.data;
		data.classNames = this.CSS.expand(
			this.CSS.block(this.baseClass, data.mod, data.stateMods),
			data["class"],
			data.className
		);
		data.style = parseStyle(data.style);
	};

	_proto.prepareData = function prepareData(context, instance) {
		if (this.styled) this.prepareCSS(context, instance);
	};

	_proto.initInstance = function initInstance(context, instance) {
		if (this.onInit) this.onInit(context, instance);
	};

	_proto.initState = function initState(context, instance) {};

	_proto.checkVisible = function checkVisible(context, instance, data) {
		return data.visible;
	};

	_proto.explore = function explore(context, instance) {
		if (this.components) instance.components = {};

		for (var cmp in this.components) {
			var ins = instance.getChild(context, this.components[cmp], "cmp-" + cmp, instance.store);
			if (ins.scheduleExploreIfVisible(context)) instance.components[cmp] = ins;
		}
	};

	_proto.render = function render(context, instance, key) {
		Console.log(this);
		throw new Error(
			'Widget\'s render method should be overridden. This error usually happens if with incorrect imports, i.e. import { TextField } from "cx/data". Please check the console for details about the component configuration.'
		);
	};

	_proto.update = function update() {
		this.version = (this.version || 0) + 1;
	};

	Widget.resetCounter = function resetCounter() {
		widgetId = 100;
	};

	return Widget;
})(Component);
Widget.prototype.visible = true;
Widget.prototype.memoize = true; //cache rendered content and use it if possible

Widget.prototype.CSS = "cx";
Widget.prototype.styled = false;
Widget.namespace = "ui.";
Widget.optimizePrepare = true;

Widget.factory = function(type, config, more) {
	throw new Error("Invalid widget type: " + type + ".");
};

function contentAppend(result, w, prependSpace) {
	if (w == null || w === false) return false;
	if (isArray(w))
		w.forEach(function(c) {
			return contentAppend(result, c);
		});
	else if (isDefined(w.content) && !w.atomic) return contentAppend(result, w.content);
	else {
		if (prependSpace) result.push(" ");
		result.push(w);
	}
	return true;
}
function getContentArray(x) {
	var result = [];
	contentAppend(result, x);
	return result;
}
function getContent(x) {
	var result = getContentArray(x);
	if (result.length == 0) return null;
	if (result.length == 1) return result[0];
	return result;
}

var StaticText = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(StaticText, _Widget);

	function StaticText() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = StaticText.prototype;

	_proto.render = function render() {
		return this.text;
	};

	return StaticText;
})(Widget);
Widget.alias("static-text", StaticText);

var Text = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(Text, _Widget);

	function Text() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = Text.prototype;

	_proto.init = function init() {
		if (!this.value && (this.tpl || this.expr || this.bind))
			this.value = {
				tpl: this.tpl,
				expr: this.expr,
				bind: this.bind
			};

		_Widget.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[
				this,
				{
					value: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.render = function render(context, _ref, key) {
		var data = _ref.data;
		return data.value != null ? data.value : "";
	};

	return Text;
})(Widget);
Widget.alias("text", Text);

function exploreChildren(context, instance, children, previousResult, key, store, beforeCallback, afterCallback) {
	var newChildren = previousResult || [];
	var oldChildren = previousResult || newChildren;
	var identical = previousResult ? 0 : -1; // if (children.length)
	//    context.exploreStack.hop();

	for (var c = 0; c < children.length; c++) {
		var cell = instance.getChild(context, children[c], key, store); // if (beforeCallback)
		//    beforeCallback(cell);

		if (cell.checkVisible(context)) {
			if (identical >= 0) {
				if (cell == oldChildren[identical]) identical++;
				else {
					newChildren = newChildren.slice(0, identical);
					identical = -1;
					newChildren.push(cell);
				}
			} else newChildren.push(cell);

			context.exploreStack.push(cell);
			if (cell.needsExploreCleanup) context.exploreStack.push(cell);
		}
	}

	if (identical >= 0 && identical != newChildren.length) newChildren = newChildren.slice(0, identical);
	return newChildren;
}

var Container = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(Container, _Widget);

	function Container() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = Container.prototype;

	_proto.init = function init(context) {
		if (typeof this.ws !== "undefined") this.preserveWhitespace = this.ws;
		if (this.preserveWhitespace) this.trimWhitespace = false;
		var items = this.items || this.children || [];
		delete this.children;
		this.items = [];

		if (this.layout) {
			var layout = Widget.create({
				type: this.layout,
				items: items
			});
			layout.init(context);
			this.layout = null;

			if (layout.noLayout) {
				this.useParentLayout = true;
				this.add(items);
			} else {
				this.add(layout);
				this.layout = layout;
			}
		} else {
			this.add(items);
		}

		_Widget.prototype.init.call(this, context);
	};

	_proto.exploreItems = function exploreItems(context, instance, items) {
		instance.children = exploreChildren(context, instance, items, instance.cached.children);
		if (instance.cache("children", instance.children)) instance.markShouldUpdate(context);
	};

	_proto.explore = function explore(context, instance) {
		_Widget.prototype.explore.call(this, context, instance);

		this.exploreItems(context, instance, this.items);
	};

	_proto.render = function render(context, instance) {
		return this.renderChildren(context, instance);
	};

	_proto.renderChildren = function renderChildren(context, instance) {
		var preserveComplexContent = this.useParentLayout;

		function append(result, r) {
			if (r == null) return; //react element

			if (!r.hasOwnProperty("content")) {
				contentAppend(result, r);
				return;
			}

			if (r.useParentLayout)
				return r.content.forEach(function(x) {
					return append(result, x);
				});

			if (r.atomic || preserveComplexContent) {
				result.push(r);
			} else {
				var first = true;

				for (var k in r) {
					if (contentAppend(result, r[k], !first)) first = false;
				}
			}
		}

		var result = [];

		for (var i = 0; i < instance.children.length; i++) {
			append(result, instance.children[i].vdom);
		}

		if (this.useParentLayout)
			return {
				useParentLayout: true,
				content: result
			};
		return result;
	};

	_proto.clear = function clear() {
		if (this.layout) this.layout.clear();
		else this.items = [];
	};

	_proto.add = function add() {
		var _this$layout,
			_this = this;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		if (this.layout) return (_this$layout = this.layout).add.apply(_this$layout, args);
		args.forEach(function(a) {
			if (!a) return;
			if (isArray(a))
				a.forEach(function(c) {
					return _this.add(c);
				});
			else if (isString(a)) {
				if (_this.trimWhitespace) a = innerTextTrim(a);
				if (a) _this.addText(a);
			} else if (a.isComponent) _this.items.push(_this.wrapItem(a));
			else {
				_this.add(Widget.create(a, _this.itemDefaults));
			}
		});
	};

	_proto.wrapItem = function wrapItem(item) {
		return item;
	};

	_proto.addText = function addText(text) {
		if (this.plainText || text.indexOf("{") == -1 || text.indexOf("}") == -1)
			this.add(
				Widget.create(StaticText, {
					text: text
				})
			);
		else
			this.add(
				Widget.create(Text, {
					text: {
						tpl: text
					}
				})
			);
	};

	_proto.find = function find(filter, options) {
		if (!options) options = {};
		if (!filter || !this.items) return [];
		var alias = filter;
		if (isString(filter))
			filter = function filter(w) {
				return w.componentAlias == alias;
			};
		if (filter.isComponentType)
			filter = function filter(w) {
				return w instanceof alias;
			};
		var results = [];

		for (var i = 0; i < this.items.length; i++) {
			var w = this.items[i];
			if (!w.initialized) w.init();

			if (filter(w)) {
				results.push(w);
				if (options.first) break;
			}

			if (w.find) results.push.apply(results, w.find(filter, options));
		}

		return results;
	};

	_proto.findFirst = function findFirst(filter, options) {
		return this.find(
			filter,
			_objectSpread2(
				_objectSpread2({}, options),
				{},
				{
					first: true
				}
			)
		)[0];
	};

	return Container;
})(Widget);
Container.prototype.trimWhitespace = true;
Container.prototype.plainText = true;
Container.prototype.styled = false;

var PureContainer = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(PureContainer, _Container);

	function PureContainer() {
		return _Container.apply(this, arguments) || this;
	}

	return PureContainer;
})(Container);
PureContainer.prototype.isPureContainer = true;
PureContainer.alias("pure-container", PureContainer);

var DataAdapter = /*#__PURE__*/ (function(_Component) {
	_inheritsLoose(DataAdapter, _Component);

	function DataAdapter() {
		return _Component.apply(this, arguments) || this;
	}

	var _proto = DataAdapter.prototype;

	_proto.getRecords = function getRecords() {
		throw new Error("Abstract method");
	};

	_proto.setFilter = function setFilter() {};

	_proto.sort = function sort() {};

	return DataAdapter;
})(Component);
DataAdapter.prototype.recordName = "$record";
DataAdapter.prototype.indexName = "$index";
DataAdapter.prototype.immutable = false;

var contents = {};
var localizations = {};
var overrides = {};
var defaults = {};
var _trackDefaults = false;
var Localization = /*#__PURE__*/ (function() {
	function Localization() {}

	Localization.register = function register(key) {
		var _this = this;

		return function(type) {
			_this.registerPrototype(key, type);

			return type;
		};
	};

	Localization.registerPrototype = function registerPrototype(key, type) {
		contents[key] = type.prototype;
		if (overrides[key]) this.override(key, overrides[key]);
	};

	Localization.trackDefaults = function trackDefaults() {
		_trackDefaults = true;
	};

	Localization.restoreDefaults = function restoreDefaults() {
		for (var type in defaults) {
			var proto = contents[type];
			if (!proto) continue;
			var d = defaults[type];

			for (var key in d) {
				proto[key] = d[key];
			}
		}

		defaults = {};
	};

	Localization.override = function override(key, values) {
		overrides[key] = values;
		var p = contents[key];

		if (p) {
			if (_trackDefaults && !defaults[key]) {
				var d = (defaults[key] = {});

				for (var _key in values) {
					d[_key] = p[_key];
				}
			}

			Object.assign(p, values);
		}
	};

	Localization.localize = function localize(culture, key, values) {
		var l = localizations[culture];
		if (!l) l = localizations[culture] = {};
		l[key] = _objectSpread2(_objectSpread2({}, l[key]), values);
	};

	Localization.setCulture = function setCulture(culture) {
		var l = localizations[culture];

		if (l) {
			for (var key in l) {
				var content = contents[key];
				if (content) Object.assign(content, l[key]);
			}
		}
	};

	return Localization;
})();

var culture = "en";
var cultureCache = {};
var defaultCurrency = "USD";

var dateEncoding = function dateEncoding(date) {
	return date.toISOString();
};

var Culture = /*#__PURE__*/ (function() {
	function Culture() {}

	Culture.setCulture = function setCulture(cultureCode) {
		culture = cultureCode;
		cultureCache = {};
		Localization.setCulture(cultureCode);
		this.invalidateCache();
	};

	Culture.setDefaultCurrency = function setDefaultCurrency(currencyCode) {
		defaultCurrency = currencyCode;
		this.invalidateCache();
	};

	Culture.invalidateCache = function invalidateCache() {
		GlobalCacheIdentifier.change();
		invalidateExpressionCache();
		invalidateStringTemplateCache();
	};

	Culture.getNumberCulture = function getNumberCulture() {
		if (!cultureCache.numberCulture) cultureCache.numberCulture = new NumberCulture(culture);
		return cultureCache.numberCulture;
	};

	Culture.getDateTimeCulture = function getDateTimeCulture() {
		if (!cultureCache.dateCulture) cultureCache.dateCulture = new DateTimeCulture(culture);
		return cultureCache.dateCulture;
	};

	Culture.getDefaultDateEncoding = function getDefaultDateEncoding() {
		return dateEncoding;
	};

	Culture.setDefaultDateEncoding = function setDefaultDateEncoding(encoding) {
		dateEncoding = encoding;
	};

	Culture.getComparer = function getComparer(options) {
		if (typeof Intl.Collator != "undefined") return new Intl.Collator(culture, options).compare;
		return defaultCompare;
	};

	_createClass(Culture, null, [
		{
			key: "defaultCurrency",
			get: function get() {
				return defaultCurrency;
			}
		},
		{
			key: "culture",
			get: function get() {
				return culture;
			}
		}
	]);

	return Culture;
})();

var ArrayAdapter = /*#__PURE__*/ (function(_DataAdapter) {
	_inheritsLoose(ArrayAdapter, _DataAdapter);

	function ArrayAdapter() {
		return _DataAdapter.apply(this, arguments) || this;
	}

	var _proto = ArrayAdapter.prototype;

	_proto.init = function init() {
		this.recordsAccessor = getAccessor(this.recordsBinding ? this.recordsBinding : this.recordsAccessor);
	};

	_proto.initInstance = function initInstance(context, instance) {
		if (!instance.recordStoreCache) instance.recordStoreCache = new WeakMap();

		if (!instance.recordsAccessor && this.recordsAccessor) {
			instance.recordsAccessor = this.recordsAccessor.bindInstance
				? this.recordsAccessor.bindInstance(instance)
				: this.recordsAccessor;
		}
	};

	_proto.getRecords = function getRecords(context, instance, records, parentStore) {
		if (!instance.recordStoreCache) this.initInstance(context, instance);
		return this.mapRecords(context, instance, records, parentStore, instance.recordsAccessor);
	};

	_proto.mapRecords = function mapRecords(context, instance, records, parentStore, recordsAccessor) {
		var _this = this;

		var result = [];
		if (!instance.recordStoreCache) this.initInstance(context, instance);
		if (isArray(records))
			records.forEach(function(data, index) {
				if (_this.filterFn && !_this.filterFn(data)) return;

				var record = _this.mapRecord(context, instance, data, parentStore, recordsAccessor, index);

				result.push(record);
			});
		if (this.sorter) result = this.sorter(result);
		return result;
	};

	_proto.mapRecord = function mapRecord(context, instance, data, parentStore, recordsAccessor, index) {
		var recordStore = instance.recordStoreCache.get(data);

		if (recordsAccessor) {
			if (!recordStore)
				recordStore = new ArrayElementView({
					store: parentStore,
					arrayAccessor: recordsAccessor,
					itemIndex: index,
					recordAlias: this.recordName,
					indexAlias: this.indexName,
					immutable: this.immutable,
					sealed: this.sealed
				});
			else {
				recordStore.setStore(parentStore);
				recordStore.setIndex(index);
			}
		} else {
			var _data;

			if (!recordStore)
				recordStore = new ReadOnlyDataView({
					store: parentStore,
					data: ((_data = {}), (_data[this.recordName] = data), (_data[this.indexName] = index), _data),
					immutable: this.immutable,
					sealed: this.sealed
				});
			else {
				recordStore.setStore(parentStore);
			}
		}

		if (typeof data == "object") instance.recordStoreCache.set(data, recordStore);
		return {
			store: recordStore,
			index: index,
			data: data,
			type: "data",
			key: this.keyField ? data[this.keyField] : index
		};
	};

	_proto.setFilter = function setFilter(filterFn) {
		this.filterFn = filterFn;
	};

	_proto.getComparer = function getComparer(sortOptions) {
		return sortOptions ? Culture.getComparer(sortOptions) : null;
	};

	_proto.buildSorter = function buildSorter(sorters) {
		var _this2 = this;

		if (isArray(sorters) && sorters.length > 0) {
			var fieldValueMapper;
			var dataAccessor; //if all sorters are based on record fields access data directly (faster)

			if (
				sorters.every(function(x) {
					return x.field && x.value == null;
				})
			) {
				dataAccessor = function dataAccessor(x) {
					return x.data;
				};

				fieldValueMapper = function fieldValueMapper(x) {
					return {
						bind: x.field
					};
				};
			} else {
				dataAccessor = function dataAccessor(x) {
					return x.store.getData();
				};

				fieldValueMapper = function fieldValueMapper(x) {
					return {
						bind: _this2.recordName + "." + x.field
					};
				};
			}

			this.sorter = sorter(
				sorters.map(function(x) {
					var s = Object.assign({}, x);
					if (s.field && s.value == null) s.value = fieldValueMapper(s);
					if (!s.comparer)
						s.comparer = _this2.getComparer(isDefined(s.sortOptions) ? s.sortOptions : _this2.sortOptions);
					return s;
				}),
				dataAccessor
			);
		} else {
			this.sorter = null;
		}
	};

	_proto.sort = function sort(sorters) {
		this.buildSorter(sorters);
	};

	return ArrayAdapter;
})(DataAdapter);
ArrayAdapter.prototype.immutable = false;
ArrayAdapter.prototype.sealed = false;
ArrayAdapter.autoInit = true;

var UseParentLayout = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(UseParentLayout, _PureContainer);

	function UseParentLayout() {
		return _PureContainer.apply(this, arguments) || this;
	}

	return UseParentLayout;
})(PureContainer);
UseParentLayout.prototype.noLayout = true;
UseParentLayout.prototype.useParentLayout = true;

var Repeater = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(Repeater, _Container);

	function Repeater() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = Repeater.prototype;

	_proto.declareData = function declareData() {
		var _Container$prototype$;

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[
				this,
				{
					records: undefined,
					sorters: undefined,
					sortField: undefined,
					sortDirection: undefined,
					filterParams: {
						structured: true
					}
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		this.recordsAccessor = getAccessor(this.records);
		if (this.recordAlias) this.recordName = this.recordAlias;
		if (this.indexAlias) this.indexName = this.indexAlias;
		this.dataAdapter = ArrayAdapter.create(
			_objectSpread2(
				_objectSpread2({}, this.dataAdapter),
				{},
				{
					recordName: this.recordName,
					indexName: this.indexName,
					keyField: this.keyField,
					immutable: this.immutable,
					sealed: this.sealed,
					recordsAccessor: this.recordsAccessor,
					sortOptions: this.sortOptions
				}
			)
		);
		this.item = PureContainer.create({
			children: this.items || this.children,
			layout: UseParentLayout
		});
		delete this.children;
		delete this.items;

		_Container.prototype.init.call(this);
	};

	_proto.initInstance = function initInstance(context, instance) {
		this.dataAdapter.initInstance(context, instance);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var _this = this;

		var data = instance.data;
		if (data.sortField)
			data.sorters = [
				{
					field: data.sortField,
					direction: data.sortDirection || "ASC"
				}
			];
		this.dataAdapter.sort(data.sorters);
		var filter = null;
		if (this.onCreateFilter) filter = instance.invoke("onCreateFilter", data.filterParams, instance);
		else if (this.filter)
			filter = function filter(item) {
				return _this.filter(item, data.filterParams);
			};
		this.dataAdapter.setFilter(filter);
		instance.mappedRecords = this.dataAdapter.getRecords(context, instance, data.records, instance.store);

		_Container.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance, data) {
		var _this2 = this;

		var instances = [];
		instance.mappedRecords.forEach(function(record) {
			var subInstance = instance.getChild(context, _this2.item, record.key, record.store);
			var changed = subInstance.cache("recordData", record.data) || subInstance.cache("key", record.key);
			subInstance.record = record;

			if (_this2.cached && !changed && subInstance.visible && !subInstance.childStateDirty) {
				instances.push(subInstance);
				subInstance.shouldUpdate = false;
			} else if (subInstance.scheduleExploreIfVisible(context)) instances.push(subInstance);
		});
		instance.children = instances;
	};

	return Repeater;
})(Container);
Repeater.prototype.recordName = "$record";
Repeater.prototype.indexName = "$index";
Repeater.prototype.cached = false;
Repeater.prototype.immutable = false;
Repeater.prototype.sealed = false;
Repeater.prototype.isPureContainer = true;
Widget.alias("repeater", Repeater);

var StructuredInstanceDataAccessor = /*#__PURE__*/ (function() {
	function StructuredInstanceDataAccessor(config) {
		this.instance = config.instance;
		this.dataConfig = config.data;
		this.useParentStore = config.useParentStore;
		this.dataSelector = getSelector(config.data);
		if (this.dataSelector.memoize) this.dataSelector = this.dataSelector.memoize();
	}

	var _proto = StructuredInstanceDataAccessor.prototype;

	_proto.getSelector = function getSelector() {
		return this.dataSelector;
	};

	_proto.get = function get() {
		return this.dataSelector.get(this.instance.store.getData());
	};

	_proto.setItem = function setItem(key, value) {
		this.instance.nestedDataSet(key, value, this.dataConfig, this.useParentStore);
	};

	_proto.containsKey = function containsKey(key) {
		return this.dataConfig.hasOwnProperty(key);
	};

	_proto.getKeys = function getKeys() {
		return Object.keys(this.dataConfig);
	};

	return StructuredInstanceDataAccessor;
})();

var Rescope = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(Rescope, _PureContainer);

	function Rescope() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = Rescope.prototype;

	_proto.init = function init() {
		this.binding = Binding.get(this.bind);
		if (this.rootAlias) this.rootName = this.rootAlias;

		_PureContainer.prototype.init.call(this);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.store = new ZoomIntoPropertyView({
			store: instance.store,
			binding: this.binding,
			rootName: this.rootName,
			nestedData: isObject(this.data)
				? new StructuredInstanceDataAccessor({
						instance: instance,
						data: this.data,
						useParentStore: true
				  })
				: null
		});

		instance.setStore = function(store) {
			instance.store.setStore(store);
		};
	};

	return Rescope;
})(PureContainer);
Rescope.prototype.bind = "$page";
Rescope.prototype.rootName = "$root";
Widget.alias("rescope", Rescope);

var isBatching = 0;
var promiseSubscribers = new SubscriberList();
function batchUpdates(callback) {
	if (VDOM$1.DOM.unstable_batchedUpdates)
		VDOM$1.DOM.unstable_batchedUpdates(function() {
			isBatching++;

			try {
				callback();
			} finally {
				isBatching--;
			}
		});
	else callback();
}
function isBatchingUpdates() {
	return isBatching > 0;
}
function notifyBatchedUpdateStarting() {
	promiseSubscribers.execute(function(x) {
		x.pending++;
	});
}
function notifyBatchedUpdateCompleted() {
	promiseSubscribers.execute(function(x) {
		x.finished++;
		if (x.finished >= x.pending) x.complete(true);
	});
}
var updateId = 0;
function batchUpdatesAndNotify(callback, notifyCallback, timeout) {
	if (timeout === void 0) {
		timeout = 1000;
	}

	var update = {
		id: ++updateId,
		pending: 0,
		finished: 0,
		done: false
	};
	update.unsubscribe = promiseSubscribers.subscribe(update);

	update.complete = function(success) {
		if (!update.done) {
			update.done = true;
			if (update.timer) clearInterval(update.timer);
			update.unsubscribe();
			notifyCallback(!!success);
		}
	};

	batchUpdates(callback);
	if (update.pending <= update.finished) update.complete(true);
	else update.timer = setTimeout(update.complete, timeout);
}

/*
 *  Purpose of FocusManager is to provide focusout notifications.
 *  IE and Firefox do not provide relatedTarget info in blur events which makes it impossible
 *  to determine if focus went outside or stayed inside the component.
 */

var subscribers = new SubscriberList(),
	timerInterval = 300,
	timerId = null;
var lastActiveElement = null;
var pending = false;
var FocusManager = /*#__PURE__*/ (function() {
	function FocusManager() {}

	FocusManager.subscribe = function subscribe(callback) {
		var unsubscribe = subscribers.subscribe(callback);
		checkTimer();
		return unsubscribe;
	};

	FocusManager.onFocusOut = function onFocusOut(el, callback) {
		var active = isSelfOrDescendant(el, getActiveElement());
		return this.subscribe(function(focusedEl) {
			if (!active) active = isSelfOrDescendant(el, getActiveElement());
			else if (!isSelfOrDescendant(el, focusedEl)) {
				active = false;
				callback(focusedEl);
			}
		});
	};

	FocusManager.oneFocusOut = function oneFocusOut(el, callback) {
		this.nudge();
		var off = this.subscribe(function(focusedEl) {
			if (!isSelfOrDescendant(el, focusedEl)) {
				callback(focusedEl);
				off();
			}
		});
		return off;
	};

	FocusManager.nudge = function nudge() {
		if (typeof document !== "undefined" && getActiveElement() !== lastActiveElement) {
			if (!pending) {
				pending = true;
				setTimeout(function() {
					pending = false;

					if (getActiveElement() !== lastActiveElement) {
						lastActiveElement = getActiveElement();
						batchUpdates(function() {
							subscribers.notify(lastActiveElement);
						});
						checkTimer();
					}
				}, 0);
			}
		}
	};

	FocusManager.focus = function focus(el) {
		el.focus();
		this.nudge();
	};

	FocusManager.focusFirst = function focusFirst(el) {
		var focusable = findFirst(el, isFocusable);
		if (focusable) this.focus(focusable);
		return focusable;
	};

	FocusManager.focusFirstChild = function focusFirstChild(el) {
		var focusable = findFirstChild(el, isFocusable);
		if (focusable) this.focus(focusable);
		return focusable;
	};

	FocusManager.focusNext = function focusNext(el) {
		var next = el,
			skip = true;

		do {
			if (!skip) {
				var focusable = this.focusFirst(next);
				if (focusable) return focusable;
			}

			if (next.nextSibling) {
				next = next.nextSibling;
				skip = false;
			} else {
				next = next.parentNode;
				skip = true;
			}
		} while (next);
	};

	FocusManager.setInterval = function setInterval(interval) {
		timerInterval = interval;
		checkTimer();
	};

	return FocusManager;
})();
function oneFocusOut(component, el, callback) {
	if (!component.oneFocusOut)
		component.oneFocusOut = FocusManager.oneFocusOut(el, function(focus) {
			delete component.oneFocusOut;
			callback(focus);
		});
}
function offFocusOut(component) {
	if (component.oneFocusOut) {
		component.oneFocusOut();
		delete component.oneFocusOut;
	}
}
function preventFocus(e) {
	//Focus can be prevented only on mousedown event. On touchstart this will not work
	//preventDefault cannot be used as it prevents scrolling
	if (e.type !== "mousedown") return;
	e.preventDefault(); //unfocus activeElement

	var activeElement = getActiveElement();

	if (e.currentTarget !== activeElement) {
		//find the closest focusable parent of the clicked element and focus it instead
		var focusableParent =
			closestParent(e.currentTarget, function(el) {
				return isFocusable(el);
			}) || document.body;
		if (focusableParent === document.body) activeElement.blur();
		else focusableParent.focus();
		FocusManager.nudge();
	}
}

function checkTimer() {
	var shouldRun = !subscribers.isEmpty();
	if (shouldRun && !timerId)
		timerId = setInterval(function() {
			FocusManager.nudge();
		}, timerInterval);

	if (!shouldRun && timerId) {
		clearInterval(timerId);
		timerId = null;
	}
}

function preventFocusOnTouch(e, force) {
	if (force === void 0) {
		force = false;
	}

	if (force || isTouchEvent()) preventFocus(e);
}

var subscribers$1 = new SubscriberList();
var ResizeManager = /*#__PURE__*/ (function() {
	function ResizeManager() {}

	ResizeManager.subscribe = function subscribe(callback) {
		return subscribers$1.subscribe(callback);
	};

	ResizeManager.notify = function notify() {
		batchUpdates(function() {
			subscribers$1.notify();
		});
	};

	ResizeManager.trackElement = function trackElement(el, callback) {
		if (typeof ResizeObserver !== "function") return this.subscribe(callback);
		var obs = new ResizeObserver(callback);
		obs.observe(el);
		return function() {
			obs.disconnect();
		};
	};

	return ResizeManager;
})();
if (typeof window != "undefined")
	window.addEventListener("resize", function() {
		return ResizeManager.notify();
	});

var lastZIndex = 10000;
var ZIndexManager = /*#__PURE__*/ (function() {
	function ZIndexManager() {}

	ZIndexManager.next = function next() {
		return ++lastZIndex;
	};

	ZIndexManager.reset = function reset(zIndex) {
		lastZIndex = zIndex;
	};

	return ZIndexManager;
})();

var Format = Format$1;
var cultureSensitiveFormatsRegistered = false;
function enableCultureSensitiveFormatting() {
	if (cultureSensitiveFormatsRegistered) return;
	cultureSensitiveFormatsRegistered = true;
	Format$1.registerFactory(["number", "n"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits));
		return function(value) {
			return formatter.format(value);
		};
	});
	Format$1.registerFactory("currency", function(format, currency, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		currency = currency || Culture.defaultCurrency;
		var formatter = culture.getFormatter(
			_objectSpread2(
				{
					style: "currency",
					currency: currency
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value);
		};
	});
	Format$1.registerFactory(["percentage", "p", "%"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(
			_objectSpread2(
				{
					style: "percent"
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value);
		};
	});
	Format$1.registerFactory(["percentSign", "ps"], function(format, minimumFractionDigits, maximumFractionDigits) {
		var culture = Culture.getNumberCulture();
		var formatter = culture.getFormatter(
			_objectSpread2(
				{
					style: "percent"
				},
				resolveMinMaxFractionDigits(minimumFractionDigits, maximumFractionDigits)
			)
		);
		return function(value) {
			return formatter.format(value / 100);
		};
	});
	Format$1.registerFactory(["date", "d"], function(fmt, format) {
		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter();
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	Format$1.registerFactory(["time", "t"], function(fmt, format) {
		if (format === void 0) {
			format = "hhmmss";
		}

		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter(format);
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	Format$1.registerFactory(["datetime", "dt"], function(fmt, format) {
		if (format === void 0) {
			format = "yyyyMd hhmm";
		}

		var culture = Culture.getDateTimeCulture();
		var formatter = culture.getFormatter(format);
		return function(value) {
			return formatter.format(new Date(value));
		};
	});
	GlobalCacheIdentifier.change();
}

var instanceId = 1000;
var Instance = /*#__PURE__*/ (function() {
	function Instance(widget, key, parent, store) {
		this.widget = widget;
		this.key = key;
		this.id = String(++instanceId);
		this.cached = {};
		this.parent = parent;
		this.store = store;
	}

	var _proto = Instance.prototype;

	_proto.setStore = function setStore(store) {
		this.store = store;
	};

	_proto.init = function init(context) {
		//widget is initialized when first instance is initialized
		if (!this.widget.initialized) {
			this.widget.init(context);
			this.widget.initialized = true;
		}

		if (!this.dataSelector) {
			this.widget.selector.init(this.store);
			this.dataSelector = this.widget.selector.createStoreSelector();
		} //init instance might change the store, so it must go before the controller

		this.widget.initInstance(context, this);
		this.widget.initState(context, this);
		if (this.widget.controller)
			this.controller = Controller.create(this.widget.controller, {
				widget: this.widget,
				instance: this,
				store: this.store
			});
		if (
			this.widget.exploreCleanup ||
			this.widget.outerLayout ||
			this.widget.isContent ||
			this.widget.controller ||
			this.widget.prepareCleanup
		)
			this.needsExploreCleanup = true;
		if (this.widget.prepare || this.widget.controller) this.needsPrepare = true;
		if (this.widget.cleanup || this.widget.controller) this.needsCleanup = true;
		this.initialized = true;
	};

	_proto.checkVisible = function checkVisible(context) {
		if (!this.initialized) this.init(context);
		var wasVisible = this.visible;
		this.rawData = this.dataSelector(this.store);
		this.visible = this.widget.checkVisible(context, this, this.rawData);
		if (this.visible && !this.detached) this.parent.instanceCache.addChild(this);
		this.explored = false;
		this.prepared = false;
		if (!this.visible && wasVisible) this.destroy();
		return this.visible;
	};

	_proto.scheduleExploreIfVisible = function scheduleExploreIfVisible(context) {
		if (this.checkVisible(context)) {
			context.exploreStack.push(this);
			if (this.needsExploreCleanup) context.exploreStack.push(this);
			return true;
		}

		return false;
	};

	_proto.cache = function cache(key, value) {
		var oldValue = this.cached[key];
		if (oldValue === value) return false;
		if (!this.cacheList) this.cacheList = {};
		this.cacheList[key] = value;
		return true;
	};

	_proto.markShouldUpdate = function markShouldUpdate(context) {
		var ins = this;
		var renderList = this.renderList;
		renderList.markReverseIndex(); //notify all parents that child state changed to bust up caching

		while (ins && !ins.shouldUpdate && ins.explored) {
			if (ins.renderList !== renderList) {
				renderList.reverse();
				renderList = ins.renderList;
				renderList.markReverseIndex();
			}

			ins.shouldUpdate = true;
			renderList.data.push(ins);
			ins = ins.widget.isContent
				? ins.contentPlaceholder
				: ins.parent.outerLayout === ins
				? ins.parent.parent
				: ins.parent;
		}

		renderList.reverse();
	};

	_proto.explore = function explore(context) {
		if (!this.visible) throw new Error("Explore invisible!");

		if (this.explored) {
			if (this.widget.prepareCleanup) context.prepareList.push(this);
			if (this.widget.exploreCleanup) this.widget.exploreCleanup(context, this);
			if (this.parent.outerLayout === this) context.popNamedValue("content", "body");
			if (this.widget.controller) context.pop("controller");
			return;
		}

		this.explored = true;
		if (this.needsPrepare) context.prepareList.push(this);
		else this.prepared = true;
		if (this.needsCleanup) context.cleanupList.push(this);
		if (this.instanceCache) this.instanceCache.mark(); //controller may reconfigure the widget and need to go before shouldUpdate calculation

		this.parentOptions = context.parentOptions;

		if (!this.controller) {
			if (context.controller) this.controller = context.controller;
			else if (this.parent.controller) this.controller = this.parent.controller;
		}

		this.destroyTracked = false;

		if (this.controller) {
			if (this.widget.controller) {
				if (!this.controller.initialized) {
					this.controller.init(context);
					this.controller.initialized = true;
				}

				context.push("controller", this.controller);
				this.controller.explore(context);
				if (this.controller.onDestroy && this.controller.widget == this.widget) this.trackDestroy();
			}
		}

		if (this.widget.onDestroy || isNonEmptyArray(this.destroySubscriptions)) this.trackDestroy();
		this.renderList = this.assignedRenderList || this.parent.renderList || context.getRootRenderList();
		var shouldUpdate =
			this.rawData !== this.cached.rawData ||
			this.state !== this.cached.state ||
			this.widget.version !== this.cached.widgetVersion ||
			this.cached.globalCacheIdentifier !== GlobalCacheIdentifier.get();

		if (shouldUpdate) {
			this.data = _objectSpread2({}, this.rawData);
			this.widget.prepareData(context, this);
			debug(processDataFlag, this.widget);
		} //onExplore might set the outer layout

		if (this.widget.onExplore) this.widget.onExplore(context, this);

		if (this.parent.outerLayout === this) {
			this.renderList = this.renderList.insertRight();
			context.pushNamedValue("content", "body", this.parent);
		}

		if (this.widget.outerLayout) {
			this.outerLayout = this.getChild(context, this.widget.outerLayout, null, this.store);
			this.outerLayout.scheduleExploreIfVisible(context);
			this.renderList = this.renderList.insertLeft();
		}

		if (this.widget.isContent) {
			this.contentPlaceholder = context.contentPlaceholder && context.contentPlaceholder[this.widget.putInto];
			if (this.contentPlaceholder) context.contentPlaceholder[this.widget.putInto](this);
			else {
				this.renderList = this.renderList.insertLeft();
				context.pushNamedValue("content", this.widget.putInto, this);
			}
		}

		this.shouldUpdate = false;
		if (shouldUpdate || this.childStateDirty || !this.widget.memoize) this.markShouldUpdate(context);
		context.exploreStack.hop();

		if (this.widget.helpers) {
			this.helpers = {};

			for (var cmp in this.widget.helpers) {
				var helper = this.widget.helpers[cmp];

				if (helper) {
					var ins = this.getChild(context, helper);
					if (ins.scheduleExploreIfVisible(context)) this.helpers[cmp] = ins;
				}
			}
		}

		this.widget.explore(context, this, this.data);
	};

	_proto.prepare = function prepare(context) {
		if (!this.visible) throw new Error("Prepare invisible!");

		if (this.prepared) {
			if (this.widget.prepareCleanup) this.widget.prepareCleanup(context, this);
			return;
		}

		this.prepared = true;
		if (this.widget.prepare) this.widget.prepare(context, this);
		if (this.widget.controller && this.controller.prepare) this.controller.prepare(context);
	};

	_proto.render = function render(context) {
		if (!this.visible) throw new Error("Render invisible!");

		if (this.shouldUpdate) {
			debug(renderFlag, this.widget, this.key);
			var vdom = renderResultFix(this.widget.render(context, this, this.key));
			if (this.widget.isContent || this.outerLayout) this.contentVDOM = vdom;
			else this.vdom = vdom;
		}

		if (this.cacheList)
			for (var key in this.cacheList) {
				this.cached[key] = this.cacheList[key];
			}
		this.cacheList = null;
		this.cached.rawData = this.rawData;
		this.cached.data = this.data;
		this.cached.state = this.state;
		this.cached.widgetVersion = this.widget.version;
		this.cached.globalCacheIdentifier = GlobalCacheIdentifier.get();
		this.childStateDirty = false;
		if (this.instanceCache) this.instanceCache.sweep();

		if (this.parent.outerLayout === this) {
			//if outer layouts are chained we need to find the originating element (last element with OL set)
			var parent = this.parent;

			while (parent.parent.outerLayout == parent) {
				parent = parent.parent;
			}

			parent.vdom = this.vdom;
		}

		return this.vdom;
	};

	_proto.cleanup = function cleanup(context) {
		if (this.widget.controller && this.controller.cleanup) this.controller.cleanup(context);
		if (this.widget.cleanup) this.widget.cleanup(context, this);
	};

	_proto.trackDestroy = function trackDestroy() {
		if (!this.destroyTracked) {
			this.destroyTracked = true;
			if (this.parent && !this.detached) this.parent.trackDestroyableChild(this);
		}
	};

	_proto.trackDestroyableChild = function trackDestroyableChild(child) {
		this.instanceCache.trackDestroy(child);
		this.trackDestroy();
	};

	_proto.subscribeOnDestroy = function subscribeOnDestroy(callback) {
		var _this = this;

		if (!this.destroySubscriptions) this.destroySubscriptions = [];
		this.destroySubscriptions.push(callback);
		this.trackDestroy();
		return function() {
			_this.destroySubscriptions &&
				_this.destroySubscriptions.filter(function(cb) {
					return cb != callback;
				});
		};
	};

	_proto.destroy = function destroy() {
		if (this.instanceCache) {
			this.instanceCache.destroy();
			this.instanceCache = null;
		}

		if (this.destroySubscriptions) {
			this.destroySubscriptions.forEach(function(cb) {
				return cb();
			});
			this.destroySubscriptions = null;
		}

		if (this.destroyTracked) {
			debug(destroyFlag, this);
			if (this.widget.onDestroy) this.widget.onDestroy(this);
			if (
				this.widget.controller &&
				this.controller &&
				this.controller.onDestroy &&
				this.controller.widget == this.widget
			)
				this.controller.onDestroy();
			this.destroyTracked = false;
		}
	};

	_proto.setState = function setState(state) {
		var _this2 = this;

		var skip = !!this.state;
		if (this.state)
			for (var k in state) {
				if (this.state[k] !== state[k]) {
					skip = false;
					break;
				}
			}
		if (skip) return;
		this.state = Object.assign({}, this.state, state);
		var parent = this.parent; //notify all parents that child state change to bust up caching

		while (parent) {
			parent.childStateDirty = true;
			parent = parent.parent;
		}

		batchUpdates(function() {
			_this2.store.notify();
		});
	};

	_proto.set = function set(prop, value, options) {
		var _this3 = this;

		if (options === void 0) {
			options = {};
		}

		//skip re-rendering (used for reading state from uncontrolled components)
		if (options.internal && this.rawData) {
			this.rawData[prop] = value;
			this.data[prop] = value;
		}

		var setter = this.setters && this.setters[prop];

		if (setter) {
			if (options.immediate && isFunction(setter.reset)) setter.reset(value);
			else setter(value);
			return true;
		}

		var p = this.widget[prop];

		if (p && typeof p == "object") {
			if (p.debounce) {
				this.definePropertySetter(
					prop,
					validatedDebounce(
						function(value) {
							return _this3.doSet(prop, value);
						},
						function() {
							return _this3.dataSelector(_this3.store)[prop];
						},
						p.debounce
					)
				);
				this.set(prop, value, options);
				return true;
			}

			if (p.throttle) {
				this.definePropertySetter(
					prop,
					throttle(function(value) {
						return _this3.doSet(prop, value);
					}, p.throttle)
				);
				this.set(prop, value, options);
				return true;
			}
		}

		return this.doSet(prop, value);
	};

	_proto.definePropertySetter = function definePropertySetter(prop, setter) {
		if (!this.setters) this.setters = {};
		this.setters[prop] = setter;
	};

	_proto.doSet = function doSet(prop, value) {
		var _this4 = this;

		var changed = false;
		batchUpdates(function() {
			var p = _this4.widget[prop];

			if (isObject(p)) {
				if (p.set) {
					if (isFunction(p.set)) {
						p.set(value, _this4);
						changed = true;
					} else if (isString(p.set)) {
						_this4.controller[p.set](value, _this4);

						changed = true;
					}
				} else if (p.action) {
					var action = p.action(value, _this4);

					_this4.store.dispatch(action);

					changed = true;
				} else if (isString(p.bind)) {
					changed = _this4.store.set(p.bind, value);
				}
			}
		});
		return changed;
	};

	_proto.nestedDataSet = function nestedDataSet(key, value, dataConfig, useParentStore) {
		var config = dataConfig[key];
		if (!config)
			throw new Error(
				"Unknown nested data key " + key + ". Known keys are " + Object.keys(dataConfig).join(", ") + "."
			);

		if (config.bind) {
			var store = this.store; //in case of Rescope aor DataProxy, bindings point to the data in the parent store

			if (useParentStore && store.store) store = store.store;
			return isUndefined(value) ? store.deleteItem(config.bind) : store.setItem(config.bind, value);
		}

		if (!config.set)
			throw new Error(
				"Cannot change nested data value for " +
					key +
					" as it's read-only. Either define it as a binding or define a set function."
			);
		if (isString(config.set)) this.getControllerMethod(config.set)(value, this);
		else if (isFunction(config.set)) config.set(value, this);
		else
			throw new Error(
				"Cannot change nested data value for " +
					key +
					" the defined setter is neither a function nor a controller method."
			);
		return true;
	};

	_proto.replaceState = function replaceState(state) {
		this.cached.state = this.state;
		this.state = state;
		this.store.notify();
	};

	_proto.getInstanceCache = function getInstanceCache() {
		if (!this.instanceCache)
			this.instanceCache = new InstanceCache(this, this.widget.isPureContainer ? this.key : null);
		return this.instanceCache;
	};

	_proto.clearChildrenCache = function clearChildrenCache() {
		if (this.instanceCache) this.instanceCache.destroy();
	};

	_proto.getChild = function getChild(context, widget, key, store) {
		return this.getInstanceCache().getChild(widget, store || this.store, key);
	};

	_proto.getDetachedChild = function getDetachedChild(widget, key, store) {
		var child = new Instance(widget, key, this, store || this.store);
		child.detached = true;
		return child;
	};

	_proto.prepareRenderCleanupChild = function prepareRenderCleanupChild(widget, store, keyPrefix, options) {
		return widget.prepareRenderCleanup(store || this.store, options, keyPrefix, this);
	};

	_proto.getJsxEventProps = function getJsxEventProps() {
		var _this5 = this;

		var widget = this.widget;
		if (!isArray(widget.jsxAttributes)) return null;
		var props = {};
		widget.jsxAttributes.forEach(function(attr) {
			if (attr.indexOf("on") == 0 && attr.length > 2)
				props[attr] = function(e) {
					return _this5.invoke(attr, e, _this5);
				};
		});
		return props;
	};

	_proto.getCallback = function getCallback(methodName) {
		var scope = this.widget;
		var callback = scope[methodName];
		if (typeof callback === "string") return this.getControllerMethod(callback);
		if (typeof callback !== "function")
			throw new Error("Cannot invoke callback method " + methodName + " as assigned value is not a function.");
		return callback.bind(scope);
	};

	_proto.getControllerMethod = function getControllerMethod(methodName) {
		if (!this.controller)
			throw new Error(
				'Cannot invoke controller method "' + methodName + '" as controller is not assigned to the widget.'
			);
		var at = this;

		while (at != null && at.controller && !at.controller[methodName]) {
			at = at.parent;
		}

		if (!at || !at.controller || !at.controller[methodName])
			throw new Error(
				'Cannot invoke controller method "' +
					methodName +
					'". The method cannot be found in any of the assigned controllers.'
			);
		return at.controller[methodName].bind(at.controller);
	};

	_proto.invoke = function invoke(methodName) {
		for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
			args[_key - 1] = arguments[_key];
		}

		return this.getCallback(methodName).apply(null, args);
	};

	_proto.invokeControllerMethod = function invokeControllerMethod(methodName) {
		for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
			args[_key2 - 1] = arguments[_key2];
		}

		return this.getControllerMethod(methodName).apply(null, args);
	};

	return Instance;
})();

function renderResultFix(res) {
	return res != null && isDefined(res.content)
		? res
		: {
				content: res
		  };
}

var InstanceCache = /*#__PURE__*/ (function() {
	function InstanceCache(parent, keyPrefix) {
		this.children = {};
		this.parent = parent;
		this.marked = {};
		this.monitored = null;
		this.keyPrefix = keyPrefix != null ? keyPrefix + "-" : "";
	}

	var _proto2 = InstanceCache.prototype;

	_proto2.getChild = function getChild(widget, store, key) {
		var k = this.keyPrefix + (key != null ? key : widget.widgetId);
		var instance = this.children[k];

		if (
			!instance ||
			instance.widget !== widget ||
			(!instance.visible && (instance.widget.controller || instance.widget.onInit))
		) {
			instance = new Instance(widget, k, this.parent);
			this.children[k] = instance;
		}

		if (instance.store !== store) instance.setStore(store);
		return instance;
	};

	_proto2.addChild = function addChild(instance) {
		this.marked[instance.key] = instance;
	};

	_proto2.mark = function mark() {
		this.marked = {};
	};

	_proto2.trackDestroy = function trackDestroy(instance) {
		if (!this.monitored) this.monitored = {};
		this.monitored[instance.key] = instance;
	};

	_proto2.destroy = function destroy() {
		this.children = {};
		this.marked = {};
		if (!this.monitored) return;

		for (var key in this.monitored) {
			this.monitored[key].destroy();
		}

		this.monitored = null;
	};

	_proto2.sweep = function sweep() {
		this.children = this.marked;
		if (!this.monitored) return;
		var activeCount = 0;

		for (var key in this.monitored) {
			var monitoredChild = this.monitored[key];
			var child = this.children[key];

			if (child !== monitoredChild || !monitoredChild.visible) {
				monitoredChild.destroy();
				delete this.monitored[key];
				if (child === monitoredChild) delete this.children[key];
			} else activeCount++;
		}

		if (activeCount === 0) this.monitored = null;
	};

	return InstanceCache;
})();

var RenderingContext = /*#__PURE__*/ (function() {
	function RenderingContext(options) {
		this.options = options || {};
		this.exploreStack = new TraversalStack();
		this.prepareList = [];
		this.cleanupList = [];
		this.stacks = {};
		this.renderList = new LinkedListsNode();
	}

	var _proto = RenderingContext.prototype;

	_proto.getStack = function getStack(key) {
		var stack = this.stacks[key];
		if (!stack) stack = this.stacks[key] = [];
		return stack;
	};

	_proto.push = function push(key, value) {
		var stack = this.getStack(key);
		stack.push(this[key]);
		return (this[key] = value);
	};

	_proto.pop = function pop(key) {
		var stack = this.getStack(key);
		return (this[key] = stack.pop());
	};

	_proto.pushNamedValue = function pushNamedValue(key, name, value) {
		var stack = this.getStack(key + ":" + name);
		if (!this[key]) this[key] = {};
		stack.push(this[key][name]);
		return (this[key][name] = value);
	};

	_proto.popNamedValue = function popNamedValue(key, name) {
		var stack = this.getStack(key + ":" + name);
		return (this[key][name] = stack.pop());
	};

	_proto.get = function get(key) {
		return this[key];
	};

	_proto.getRootRenderList = function getRootRenderList() {
		var rl = this.renderList;

		while (rl.left) {
			rl = rl.left;
		}

		return rl;
	};

	return RenderingContext;
})();

var LinkedListsNode = /*#__PURE__*/ (function() {
	function LinkedListsNode(left, right) {
		this.left = left;
		this.right = right;
		this.data = [];
	}

	var _proto2 = LinkedListsNode.prototype;

	_proto2.insertLeft = function insertLeft() {
		var node = new LinkedListsNode(this.left, this);
		if (this.left) this.left.right = node;
		this.left = node;
		return node;
	};

	_proto2.insertRight = function insertRight() {
		var node = new LinkedListsNode(this, this.right);
		if (this.right) this.right.left = node;
		this.right = node;
		return node;
	};

	_proto2.markReverseIndex = function markReverseIndex() {
		this.reverseIndex = this.data.length;
	};

	_proto2.reverse = function reverse() {
		reverseSlice(this.data, this.reverseIndex);
	};

	return LinkedListsNode;
})();

var Cx = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(Cx, _VDOM$Component);

	function Cx(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;

		if (props.instance) {
			_this.widget = props.instance.widget;
			_this.store = props.instance.store;
		} else {
			_this.widget = PureContainer.create({
				items: props.widget || props.items
			});

			if (props.parentInstance) {
				_this.parentInstance = props.parentInstance;
				_this.store = props.store || _this.parentInstance.store;
			} else {
				_this.parentInstance = new Instance(_this.widget, 0);
				_this.store = props.store;
			}

			if (!_this.store) throw new Error("Cx component requires store.");
		}

		_this.state = {
			deferToken: 0
		};

		if (props.subscribe) {
			_this.unsubscribe = _this.store.subscribe(_this.update.bind(_assertThisInitialized(_this)));
			_this.state.data = _this.store.getData();
		}

		_this.flags = {};
		_this.renderCount = 0;
		if (props.onError) _this.componentDidCatch = _this.componentDidCatchHandler.bind(_assertThisInitialized(_this));
		_this.forceUpdateCallback = _this.forceUpdate.bind(_assertThisInitialized(_this));
		_this.deferCounter = 0;

		_this.waitForIdle();

		return _this;
	}

	var _proto = Cx.prototype;

	_proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var newStore = props.instance ? props.instance.store : props.store ? props.store : props.parentInstance.store;

		if (newStore != this.store) {
			this.store = newStore;
			if (this.unsubscribe) this.unsubscribe();
			if (props.subscribe) this.unsubscribe = this.store.subscribe(this.update.bind(this));
		}

		if (props.subscribe) {
			var data = this.store.getData();

			if (data !== this.state.data) {
				this.waitForIdle();
				this.setState({
					data: data
				});
			}
		}
	};

	_proto.getInstance = function getInstance() {
		if (this.props.instance) return this.props.instance;

		if (this.instance && this.instance.widget === this.widget) {
			if (this.instance.store != this.store) this.instance.setStore(this.store);
			return this.instance;
		}

		if (this.widget && this.parentInstance)
			return (this.instance = this.parentInstance.getDetachedChild(this.widget, 0, this.store));
		throw new Error("Could not resolve a widget instance in the Cx component.");
	};

	_proto.render = function render() {
		if (this.props.deferredUntilIdle && this.state.deferToken < this.deferCounter) return null;
		return /*#__PURE__*/ jsx(CxContext, {
			instance: this.getInstance(),
			flags: this.flags,
			options: this.props.options,
			buster: ++this.renderCount,
			contentFactory: this.props.contentFactory,
			forceUpdate: this.forceUpdateCallback
		});
	};

	_proto.componentDidMount = function componentDidMount() {
		this.componentDidUpdate();
		if (this.props.options && this.props.options.onPipeUpdate) this.props.options.onPipeUpdate(this.update.bind(this));
	};

	_proto.componentDidUpdate = function componentDidUpdate() {
		if (this.flags.dirty) {
			this.update();
		}
	};

	_proto.update = function update() {
		var _this2 = this;

		var data = this.store.getData();
		debug(appDataFlag, data);
		if (this.flags.preparing) this.flags.dirty = true;
		else if (isBatchingUpdates() || this.props.immediate) {
			notifyBatchedUpdateStarting();
			this.setState(
				{
					data: data
				},
				notifyBatchedUpdateCompleted
			);
		} else {
			//in standard mode sequential store commands are batched
			if (!this.pendingUpdateTimer) {
				notifyBatchedUpdateStarting();
				this.pendingUpdateTimer = setTimeout(function() {
					delete _this2.pendingUpdateTimer;

					_this2.setState(
						{
							data: data
						},
						notifyBatchedUpdateCompleted
					);
				}, 0);
			}
		}
	};

	_proto.waitForIdle = function waitForIdle() {
		var _this3 = this;

		if (!this.props.deferredUntilIdle) return;
		if (this.unsubscribeIdleRequest) this.unsubscribeIdleRequest();
		var token = ++this.deferCounter;
		this.unsubscribeIdleRequest = onIdleCallback(
			function() {
				_this3.setState({
					deferToken: token
				});
			},
			{
				timeout: this.props.idleTimeout || 30000
			}
		);
	};

	_proto.componentWillUnmount = function componentWillUnmount() {
		if (this.pendingUpdateTimer) clearTimeout(this.pendingUpdateTimer);
		if (this.unsubscribeIdleRequest) this.unsubscribeIdleRequest();
		if (this.unsubscribe) this.unsubscribe();
		if (this.props.options && this.props.options.onPipeUpdate) this.props.options.onPipeUpdate(null);
	};

	_proto.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
		if (props.deferredUntilIdle && state.deferToken != this.deferCounter) return false;
		return (
			state !== this.state ||
			!props.params ||
			!shallowEquals(props.params, this.props.params) ||
			props.instance !== this.props.instance ||
			props.widget !== this.props.widget ||
			props.store !== this.props.store ||
			props.parentInstance !== this.props.parentInstance
		);
	};

	_proto.componentDidCatchHandler = function componentDidCatchHandler(error, info) {
		this.flags.preparing = false;
		this.props.onError(error, this.getInstance(), info);
	};

	return Cx;
})(VDOM$1.Component);

var CxContext = /*#__PURE__*/ (function(_VDOM$Component2) {
	_inheritsLoose(CxContext, _VDOM$Component2);

	function CxContext(props) {
		var _this4;

		_this4 = _VDOM$Component2.call(this, props) || this;
		_this4.renderCount = 0;

		_this4.UNSAFE_componentWillReceiveProps(props);

		return _this4;
	}

	var _proto2 = CxContext.prototype;

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		this.timings = {
			start: now()
		};
		var instance = props.instance,
			options = props.options,
			contentFactory = props.contentFactory;
		var count = 0,
			visible,
			context; //should not be tracked by parents for destroy

		if (!instance.detached)
			throw new Error("The instance passed to a Cx component should be detached from its parent.");
		if (this.props.instance !== instance && this.props.instance.destroyTracked) this.props.instance.destroy();
		this.props.flags.preparing = true;

		do {
			context = new RenderingContext(options);
			context.forceUpdate = this.props.forceUpdate;
			this.props.flags.dirty = false;
			instance.assignedRenderList = context.getRootRenderList();
			visible = instance.scheduleExploreIfVisible(context);

			if (visible) {
				while (!context.exploreStack.empty()) {
					var inst = context.exploreStack.pop(); //console.log("EXPLORE", inst.widget.constructor.name, inst.widget.tag, inst.widget.widgetId);

					inst.explore(context);
				}
			} else if (instance.destroyTracked) {
				instance.destroy();
				break;
			}
		} while (this.props.flags.dirty && ++count <= 3 && Widget.optimizePrepare && now() - this.timings.start < 8);

		if (visible) {
			this.timings.afterExplore = now();

			for (var i = 0; i < context.prepareList.length; i++) {
				context.prepareList[i].prepare(context);
			}

			this.timings.afterPrepare = now(); //walk in reverse order so children get rendered first

			var renderList = context.getRootRenderList();

			while (renderList) {
				for (var _i = renderList.data.length - 1; _i >= 0; _i--) {
					renderList.data[_i].render(context);
				}

				renderList = renderList.right;
			}

			this.content = getContent(instance.vdom);
			if (contentFactory)
				this.content = contentFactory({
					children: this.content
				});
			this.timings.afterRender = now();

			for (var _i2 = 0; _i2 < context.cleanupList.length; _i2++) {
				context.cleanupList[_i2].cleanup(context);
			}
		} else {
			this.content = null;
			this.timings.afterExplore = this.timings.afterPrepare = this.timings.afterRender = now();
		}

		this.timings.beforeVDOMRender = now();
		this.props.flags.preparing = false;
		this.props.flags.rendering = true;
		this.renderingContext = context;
	};

	_proto2.render = function render() {
		return this.content;
	};

	_proto2.componentDidMount = function componentDidMount() {
		this.componentDidUpdate();
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		this.props.flags.rendering = false;
		this.timings.afterVDOMRender = now(); //let {instance} = this.props;
		//instance.cleanup(this.renderingContext);

		this.timings.afterCleanup = now();
		this.renderCount++;

		if (process.env.NODE_ENV !== "production") {
			var _this$timings = this.timings,
				start = _this$timings.start,
				beforeVDOMRender = _this$timings.beforeVDOMRender,
				afterVDOMRender = _this$timings.afterVDOMRender,
				afterPrepare = _this$timings.afterPrepare,
				afterExplore = _this$timings.afterExplore,
				afterRender = _this$timings.afterRender,
				afterCleanup = _this$timings.afterCleanup;
			Timing.log(
				vdomRenderFlag,
				this.renderCount,
				"cx",
				(beforeVDOMRender - start + afterCleanup - afterVDOMRender).toFixed(2) + "ms",
				"vdom",
				(afterVDOMRender - beforeVDOMRender).toFixed(2) + "ms"
			);
			Timing.log(
				appLoopFlag,
				this.renderCount,
				this.renderingContext.options.name || "main",
				"total",
				(afterCleanup - start).toFixed(1) + "ms",
				"explore",
				(afterExplore - start).toFixed(1) + "ms",
				"prepare",
				(afterPrepare - afterExplore).toFixed(1),
				"render",
				(afterRender - afterPrepare).toFixed(1),
				"vdom",
				(afterVDOMRender - beforeVDOMRender).toFixed(1),
				"cleanup",
				(afterCleanup - afterVDOMRender).toFixed(1)
			);
		}
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		var instance = this.props.instance;
		if (instance.destroyTracked) instance.destroy();
	};

	return CxContext;
})(VDOM$1.Component);

var ContentResolver = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(ContentResolver, _PureContainer);

	function ContentResolver() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = ContentResolver.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					params: {
						structured: true
					},
					loading: undefined
				}
			])
		);
	};

	_proto.init = function init() {
		_PureContainer.prototype.init.call(this);

		this.initialItems = this.layout ? this.layout.items : this.items;
		this.clear();
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.content = this.initialItems;
		instance.cachedParams = {}; //unique value which will never pass the equality check
	};

	_proto.prepareData = function prepareData(context, instance) {
		var _this = this;

		var data = instance.data;

		if (data.params !== instance.cachedParams && this.onResolve) {
			instance.cachedParams = data.params;
			var content = instance.invoke("onResolve", data.params, instance);

			if (isPromise(content)) {
				instance.set("loading", true);
				this.setContent(instance, null);
				content.then(function(cnt) {
					_this.setContent(instance, cnt);

					instance.setState({
						cacheBuster: {}
					});
					instance.set("loading", false);
				});
			} else this.setContent(instance, content);
		}
	};

	_proto.setContent = function setContent(instance, content) {
		if (content) {
			this.clear();

			switch (this.mode) {
				case "prepend":
					this.add(content);
					this.add(this.initialItems);
					break;

				case "append":
					this.add(this.initialItems);
					this.add(content);
					break;

				case "replace":
					this.add(content);
					break;
			}

			instance.content = this.layout ? this.layout.items : this.items;
			this.clear();
		} else instance.content = this.initialItems;
	};

	_proto.explore = function explore(context, instance) {
		//a little bit hacky
		if (this.layout) this.layout.items = instance.content;
		else this.items = instance.content;

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	return ContentResolver;
})(PureContainer);
ContentResolver.prototype.mode = "replace";

var IsolatedScope = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(IsolatedScope, _PureContainer);

	function IsolatedScope() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = IsolatedScope.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					data: {
						structured: true
					}
				}
			])
		);
	};

	_proto.init = function init() {
		var _this = this;

		if (typeof this.bind === "string")
			this.data = {
				bind: this.bind
			};
		else if (isArray(this.bind)) {
			this.data = {};
			this.bind.forEach(function(x, i) {
				_this.data[String(i)] = {
					bind: x
				};
			});
		}

		_PureContainer.prototype.init.call(this);
	};

	_proto.explore = function explore(context, instance) {
		if (instance.shouldUpdate) {
			_PureContainer.prototype.explore.call(this, context, instance);
		}
	};

	return IsolatedScope;
})(PureContainer);

var DetachedScope = /*#__PURE__*/ (function(_IsolatedScope) {
	_inheritsLoose(DetachedScope, _IsolatedScope);

	function DetachedScope() {
		return _IsolatedScope.apply(this, arguments) || this;
	}

	var _proto = DetachedScope.prototype;

	_proto.declareData = function declareData() {
		var _IsolatedScope$protot;

		return (_IsolatedScope$protot = _IsolatedScope.prototype.declareData).call.apply(
			_IsolatedScope$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					exclusiveData: {
						structured: true
					}
				}
			])
		);
	};

	_proto.init = function init() {
		var _this = this;

		if (typeof this.exclusive === "string")
			this.exclusiveData = {
				bind: this.exclusive
			};

		if (Array.isArray(this.exclusive)) {
			this.exclusiveData = {};
			this.exclusive.forEach(function(x, i) {
				_this.exclusiveData[String(i)] = {
					bind: x
				};
			});
		}

		this.container = PureContainer.create({
			type: PureContainer,
			items: this.children || this.items
		});
		delete this.items;
		delete this.children;
		if (this.name)
			this.options = _objectSpread2(
				_objectSpread2({}, this.options),
				{},
				{
					name: this.name
				}
			);

		_IsolatedScope.prototype.init.call(this);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.subStore = new ContainmentStore({
			store: instance.store,
			selector: getSelector(this.exclusiveData || this.data)
		});
	};

	_proto.render = function render(context, instance, key) {
		return /*#__PURE__*/ jsx(
			Cx,
			{
				widget: this.container,
				store: instance.subStore,
				parentInstance: instance,
				subscribe: true,
				options: this.options,
				onError: this.onError
			},
			key
		);
	};

	return DetachedScope;
})(IsolatedScope);

var ContainmentStore = /*#__PURE__*/ (function(_SubscribableView) {
	_inheritsLoose(ContainmentStore, _SubscribableView);

	function ContainmentStore() {
		return _SubscribableView.apply(this, arguments) || this;
	}

	var _proto2 = ContainmentStore.prototype;

	_proto2.getData = function getData() {
		return this.store.getData();
	};

	_proto2.setItem = function setItem() {
		var _this2 = this;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return this.wrapper(function() {
			var _this2$store;

			(_this2$store = _this2.store).setItem.apply(_this2$store, args);
		});
	};

	_proto2.deleteItem = function deleteItem() {
		var _this3 = this;

		for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		return this.wrapper(function() {
			var _this3$store;

			(_this3$store = _this3.store).deleteItem.apply(_this3$store, args);
		});
	};

	_proto2.wrapper = function wrapper(callback) {
		if (this.store.silently(callback)) {
			var data = this.getData();
			var containedData = this.selector(data);

			if (containedData === this.cache.containedData) {
				this.store.notify();
			} else {
				this.cache.containedData = containedData;
				this.notify();
			}

			return true;
		}

		return false;
	};

	return ContainmentStore;
})(SubscribableView);

var persistenceCache = {};
var Restate = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(Restate, _PureContainer);

	function Restate() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = Restate.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					deferredUntilIdle: undefined,
					idleTimeout: undefined,
					cacheKey: undefined
				}
			])
		);
	};

	_proto.init = function init() {
		this.container = PureContainer.create({
			type: PureContainer,
			items: this.children || this.items,
			layout: this.layout,
			controller: this.controller,
			outerLayout: this.outerLayout,
			useParentLayout: !this.detached,
			ws: this.ws
		});
		this.privateDataSelector = new StructuredSelector({
			props: this.data || {},
			values: this.data
		});
		delete this.items;
		delete this.children;
		delete this.controller;
		delete this.outerLayout;
		delete this.layout;
		if (this.useParentLayout == null) this.useParentLayout = !this.detached;

		_PureContainer.prototype.init.call(this);
	};

	_proto.initSubStore = function initSubStore(context, instance) {
		var _this = this;

		var cacheKey = instance.data.cacheKey;
		this.privateDataSelector.init(instance.store);
		instance.subStore = new RestateStore({
			store: instance.store,
			detached: this.detached,
			privateData: this.data || {},
			data: cacheKey ? persistenceCache[cacheKey] || {} : {},
			dataSelector: this.privateDataSelector.create(),
			onSet: function onSet(path, value) {
				return instance.nestedDataSet(path, value, _this.data);
			}
		});

		instance.setStore = function(store) {
			instance.store = store;
			instance.subStore.setStore(store);
		};

		if (cacheKey) {
			instance.subscribeOnDestroy(function() {
				persistenceCache[cacheKey] = instance.subStore.getData();
			});
		}
	};

	_proto.explore = function explore(context, instance) {
		if (!instance.subStore) this.initSubStore(context, instance);
		if (instance.subStore.parentDataCheck()) instance.markShouldUpdate();

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto.exploreItems = function exploreItems(context, instance, items) {
		if (!this.detached) {
			instance.container = instance.getChild(context, this.container, "container", instance.subStore);
			instance.container.scheduleExploreIfVisible(context);
			instance.children = [instance.container];
		}
	};

	_proto.render = function render(context, instance, key) {
		if (!this.detached) return instance.container.render(context);
		return /*#__PURE__*/ jsx(
			Cx,
			{
				widget: this.container,
				parentInstance: instance,
				store: instance.subStore,
				subscribe: true,
				options: this.options,
				onError: this.onError,
				deferredUntilIdle: instance.data.deferredUntilIdle,
				idleTimeout: instance.data.idleTimeout
			},
			key
		);
	};

	return Restate;
})(PureContainer);
Restate.prototype.detached = false;
Restate.prototype.waitForIdle = false;
var PrivateStore = Restate;

var RestateStore = /*#__PURE__*/ (function(_Store) {
	_inheritsLoose(RestateStore, _Store);

	function RestateStore(config) {
		var _this2;

		_this2 = _Store.call(this, config) || this;
		_this2.parentDataVersion = -1; //initial data population should not cause an additional rendering pass

		_this2.silently(function() {
			_this2.parentDataCheck();
		});

		return _this2;
	}

	var _proto2 = RestateStore.prototype;

	_proto2.parentDataCheck = function parentDataCheck() {
		var _this3 = this;

		if (this.parentDataVersion == this.store.meta.version) return false;
		this.parentDataVersion = this.store.meta.version;
		this.parentData = this.dataSelector(this.store.getData());
		return this.batch(function() {
			for (var key in _this3.parentData) {
				_Store.prototype.setItem.call(_this3, key, _this3.parentData[key]);
			}
		});
	};

	_proto2.setItem = function setItem(path, value) {
		var _this4 = this;

		var binding = Binding.get(path);
		var bindingRoot = binding.parts[0];

		if (!isObject(this.privateData) || !this.privateData.hasOwnProperty(bindingRoot)) {
			var changed = isUndefined(value)
				? _Store.prototype.deleteItem.call(this, path)
				: _Store.prototype.setItem.call(this, path, value);
			return changed;
		}

		var newValue = value;
		if (binding.parts.length > 1) newValue = binding.set(this.getData(), value)[bindingRoot];
		this.onSet(bindingRoot, newValue);
		this.batch(function() {
			_Store.prototype.setItem.call(_this4, bindingRoot, newValue);

			_this4.parentDataCheck();
		});
		return true;
	};

	_proto2.deleteItem = function deleteItem(path) {
		return this.setItem(path, undefined);
	};

	_proto2.doNotify = function doNotify() {
		if (!this.detached) this.store.notify();

		_Store.prototype.doNotify.call(this);
	};

	return RestateStore;
})(Store);

var DataProxy = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(DataProxy, _PureContainer);

	function DataProxy() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = DataProxy.prototype;

	_proto.init = function init() {
		if (!this.data) this.data = {};
		if (this.alias) this.data[this.alias] = this.value; //not sure why nesting is needed, commenting for now
		// this.container = PureContainer.create({
		//    type: PureContainer,
		//    items: this.children || this.items,
		//    layout: this.layout,
		//    controller: this.controller,
		//    outerLayout: this.outerLayout,
		//    ws: this.ws,
		// });
		// this.children = [this.container];
		// delete this.items;
		// delete this.controller;
		// delete this.outerLayout;
		// this.layout = UseParentLayout;

		_PureContainer.prototype.init.call(this);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.store = new NestedDataView({
			store: instance.store,
			nestedData: new StructuredInstanceDataAccessor({
				instance: instance,
				data: this.data,
				useParentStore: true
			}),
			immutable: this.immutable,
			sealed: this.sealed
		});

		instance.setStore = function(store) {
			instance.store.setStore(store);
		};
	};

	return DataProxy;
})(PureContainer);
DataProxy.prototype.immutable = false;
DataProxy.prototype.sealed = false;

var subscribers$2,
	eventBan = 0;
function executeKeyboardShortcuts(e) {
	if (Date.now() < eventBan) return; //Avoid duplicate executions as event.stopPropagation() for React events does not stop native events

	eventBan = Date.now() + 5;
	subscribers$2 && subscribers$2.notify(e);
}
function registerKeyboardShortcut(key, callback) {
	var keyCode = isObject(key) ? key.keyCode : key;
	var shiftKey = isObject(key) ? key.shiftKey : false;
	var ctrlKey = isObject(key) ? key.ctrlKey : false;
	var altKey = isObject(key) ? key.altKey : false;

	if (!subscribers$2) {
		subscribers$2 = new SubscriberList();
		document.addEventListener("keydown", function(e) {
			if (e.target == document.body) executeKeyboardShortcuts(e);
		});
	}

	return subscribers$2.subscribe(function(e) {
		if (e.keyCode == keyCode && (!shiftKey || e.shiftKey) && (!ctrlKey || e.ctrlKey) && (!altKey || e.altKey))
			callback(e);
	});
}

var HoverSync = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(HoverSync, _PureContainer);

	function HoverSync() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = HoverSync.prototype;

	_proto.initInstance = function initInstance(context, instance) {
		var channels = {};
		instance.hoverSync = {
			report: function report(channel, hoverId, active) {
				var ch = channels[channel];
				if (!ch) return;
				var state = active && hoverId;

				if (ch.state !== state && (ch.state === hoverId || active)) {
					ch.state = state;
					ch.subscribers.notify(state);
				}
			},
			subscribe: function subscribe(channel, callback) {
				var ch = channels[channel];
				if (!ch)
					ch = channels[channel] = {
						subscribers: new SubscriberList(),
						state: false
					};
				return ch.subscribers.subscribe(callback);
			}
		};
	};

	_proto.explore = function explore(context, instance) {
		context.push("hoverSync", instance.hoverSync);

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("hoverSync");
	};

	return HoverSync;
})(PureContainer);

var HoverSyncChild = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(HoverSyncChild, _VDOM$Component);

	function HoverSyncChild(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			hover: false
		};
		_this.onMouseMove = _this.onMouseMove.bind(_assertThisInitialized(_this));
		_this.onMouseLeave = _this.onMouseLeave.bind(_assertThisInitialized(_this));
		return _this;
	}

	var _proto2 = HoverSyncChild.prototype;

	_proto2.onMouseMove = function onMouseMove() {
		this.props.hoverSync.report(this.props.hoverChannel, this.props.hoverId, true);
	};

	_proto2.onMouseLeave = function onMouseLeave() {
		this.props.hoverSync.report(this.props.hoverChannel, this.props.hoverId, false);
	};

	_proto2.compontentWillUnmount = function compontentWillUnmount() {
		this.unsubscribe();
	};

	_proto2.componentDidMount = function componentDidMount() {
		var _this2 = this;

		this.unsubscribe = this.props.hoverSync.subscribe(this.props.hoverChannel, function(hoverId) {
			var hover = hoverId === _this2.props.hoverId;
			if (hover !== _this2.state.hover)
				_this2.setState({
					hover: hover
				});
		});
	};

	_proto2.render = function render() {
		return this.props.render({
			hover: this.state.hover,
			onMouseLeave: this.onMouseLeave,
			onMouseMove: this.onMouseMove,
			key: "child"
		});
	};

	return HoverSyncChild;
})(VDOM.Component);

function withHoverSync(key, hoverSync, hoverChannel, hoverId, render) {
	if (!hoverSync || !hoverChannel || hoverId == null)
		return render({
			key: key,
			hover: false,
			onMouseLeave: dummyCallback,
			onMouseMove: dummyCallback
		});
	return /*#__PURE__*/ jsx(
		HoverSyncChild,
		{
			hoverSync: hoverSync,
			hoverChannel: hoverChannel,
			hoverId: hoverId,
			render: render
		},
		key
	);
}
var HoverSyncElement = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(HoverSyncElement, _Container);

	function HoverSyncElement() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto3 = HoverSyncElement.prototype;

	_proto3.declareData = function declareData() {
		var _Container$prototype$;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(args, [
				{
					hoverId: undefined,
					hoverClass: {
						structured: true
					},
					hoverStyle: {
						structured: true
					}
				}
			])
		);
	};

	_proto3.prepareData = function prepareData(context, instance) {
		instance.hoverSync = context.hoverSync;
		instance.inSvg = !!context.inSvg;
		var data = instance.data;
		data.hoverStyle = parseStyle(data.hoverStyle);

		_Container.prototype.prepareData.call(this, context, instance);
	};

	_proto3.render = function render(context, instance, key) {
		var data = instance.data,
			inSvg = instance.inSvg;
		var CSS = this.CSS;
		var children = this.renderChildren(context, instance);
		var eventHandlers = instance.getJsxEventProps();
		return withHoverSync(key, instance.hoverSync, this.hoverChannel, data.hoverId, function(_ref) {
			var hover = _ref.hover,
				onMouseMove = _ref.onMouseMove,
				onMouseLeave = _ref.onMouseLeave,
				key = _ref.key;

			var style = _objectSpread2(_objectSpread2({}, data.style), hover && data.hoverStyle);

			return VDOM.createElement(
				inSvg ? "g" : "div",
				_objectSpread2(
					_objectSpread2(
						{
							key: key,
							className: CSS.expand(
								data.classNames,
								CSS.state({
									hover: hover
								}),
								hover && data.hoverClass
							),
							style: style
						},
						eventHandlers
					),
					{},
					{
						onMouseLeave: onMouseLeave,
						onMouseMove: onMouseMove
					}
				),
				children
			);
		});
	};

	return HoverSyncElement;
})(Container);
HoverSyncElement.prototype.baseClass = "hoversyncelement";
HoverSyncElement.prototype.styled = true;
HoverSyncElement.prototype.hoverChannel = "default";

var flattenProps = function flattenProps(props) {
	if (!props) return {};

	if (props.jsxSpread) {
		props = _objectSpread2(
			_objectSpread2({}, props),
			props.jsxSpread.reduce(function(acc, prop) {
				return Object.assign(acc, prop);
			}, {})
		);
	}

	if (props.$props !== undefined) {
		props = _objectSpread2(
			_objectSpread2({}, props.$props),
			{},
			{
				jsxAttributes: props.jsxAttributes,
				children: props.children
			}
		);
	}

	return _objectSpread2({}, props);
};

var currentInstance = null;

var FunctionalComponent = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(FunctionalComponent, _PureContainer);

	function FunctionalComponent() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = FunctionalComponent.prototype;

	_proto.initInstance = function initInstance(context, instance) {
		this.clear();
		currentInstance = instance;
		this.add(this.childrenFactory(this.props));
		instance.content = this.layout ? this.layout.items : this.items;
		this.clear();
		currentInstance = null;
	};

	_proto.explore = function explore(context, instance) {
		if (this.layout) this.layout.items = instance.content;
		else this.items = instance.content;
		this.exploreItems(context, instance, instance.content);

		if (instance.computables) {
			instance.computables.forEach(function(cb) {
				return cb(instance.store.getData());
			});
		}
	};

	return FunctionalComponent;
})(PureContainer);

function createFunctionalComponent(factory) {
	if (isComponentFactory(factory)) return factory;
	return createComponentFactory(factory, function(props) {
		if (props === void 0) {
			props = {};
		}

		var innerProps = flattenProps(props);
		delete innerProps.visible;
		delete innerProps["if"];
		delete innerProps.controller;
		delete innerProps.layout;
		delete innerProps.outerLayout;
		delete innerProps.putInto;
		delete innerProps.contentFor;
		delete innerProps.jsxAttributes;
		delete innerProps.$type;
		return {
			type: FunctionalComponent,
			visible: isDefined(props["if"]) ? props["if"] : isDefined(props.visible) ? props.visible : true,
			layout: props.layout || UseParentLayout,
			controller: props.controller,
			outerLayout: props.outerLayout,
			putInto: props.contentFor || props.putInto,
			childrenFactory: factory,
			props: innerProps
		};
	});
}
function getCurrentInstance() {
	return currentInstance;
}

var Selection = /*#__PURE__*/ (function(_Component) {
	_inheritsLoose(Selection, _Component);

	function Selection() {
		return _Component.apply(this, arguments) || this;
	}

	var _proto = Selection.prototype;

	_proto.isSelected = function isSelected(store, record, index) {
		return this.bind && store.get(this.bind) === record;
	};

	_proto.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
		var _this = this;

		return function(record, index) {
			return _this.isSelected(store, record, index);
		};
	};

	_proto.select = function select(store, record, index, options) {
		this.selectMultiple(store, [record], [index], options);
	};

	_proto.selectMultiple = function selectMultiple(store, records, indexes, options) {
		//abstract
	};

	_proto.declareData = function declareData() {
		var declaration = {
			$selection: {
				structured: true
			}
		};
		return Object.assign.apply(Object, [declaration].concat(Array.prototype.slice.call(arguments)));
	};

	_proto.configureWidget = function configureWidget(widget) {
		if (this.record || this.index) {
			widget.$selection = Object.assign(widget.$selection || {}, {
				record: this.record,
				index: this.index
			});
		}

		return this.declareData();
	};

	_proto.selectInstance = function selectInstance(instance, options) {
		var store = instance.store,
			data = instance.data;
		if (!data.$selection)
			throw new Error(
				"Selection model not properly configured. Using the selectInstance method without specified record and index bindings."
			);
		return this.select(store, data.$selection.record, data.$selection.index, options);
	};

	_proto.isInstanceSelected = function isInstanceSelected(instance) {
		var store = instance.store,
			data = instance.data;
		return data.$selection && this.isSelected(store, data.$selection.record, data.$selection.index);
	};

	return Selection;
})(Component);
Selection.prototype.toggle = false;
Selection.namespace = "ui.selection.";

var SimpleSelection = /*#__PURE__*/ (function(_Selection) {
	_inheritsLoose(SimpleSelection, _Selection);

	function SimpleSelection() {
		return _Selection.apply(this, arguments) || this;
	}

	var _proto2 = SimpleSelection.prototype;

	_proto2.isSelected = function isSelected(store, record, index) {
		return this.getIsSelectedDelegate(store)(record, index);
	};

	_proto2.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
		var selection = this.bind && store.get(this.bind);
		return function(record, index) {
			return record === selection;
		};
	};

	_proto2.selectMultiple = function selectMultiple(store, records, index) {
		if (this.bind) store.set(this.bind, records[0]);
	};

	return SimpleSelection;
})(Selection);

var DummySelection = /*#__PURE__*/ (function(_Selection2) {
	_inheritsLoose(DummySelection, _Selection2);

	function DummySelection() {
		return _Selection2.apply(this, arguments) || this;
	}

	var _proto3 = DummySelection.prototype;

	_proto3.isSelected = function isSelected(store, record, index) {
		return false;
	};

	_proto3.selectMultiple = function selectMultiple() {
		//dummy
	};

	_proto3.selectInstance = function selectInstance() {
		//dummy
	};

	return DummySelection;
})(Selection);

DummySelection.prototype.isDummy = true;

Selection.factory = function(name) {
	if (typeof name == "object") return new SimpleSelection(name);
	return new DummySelection();
};

var PropertySelection = /*#__PURE__*/ (function(_Selection) {
	_inheritsLoose(PropertySelection, _Selection);

	function PropertySelection() {
		return _Selection.apply(this, arguments) || this;
	}

	var _proto = PropertySelection.prototype;

	_proto.selectMultiple = function selectMultiple(store, records, indexes, _temp) {
		var _this = this;

		var _ref = _temp === void 0 ? {} : _temp,
			toggle = _ref.toggle,
			add = _ref.add;

		if (this.toggle) toggle = true;
		if (!this.records || !this.records.bind) return false;
		var array = store.get(this.records.bind);
		var newArray = [].concat(array);
		var dirty = false;

		if (!toggle && !add) {
			newArray.forEach(function(r, i) {
				if (r[_this.selectedField]) {
					var nr = Object.assign({}, r);
					nr[_this.selectedField] = false;
					newArray[i] = nr;
					dirty = true;
				}
			});
		}

		records.forEach(function(record, i) {
			var index = indexes[i];
			var rec = newArray[index];
			if (array[index] !== record) throw new Error("Stale data.");
			var value = rec[_this.selectedField];
			var newValue = add ? true : toggle ? !value : true;
			if (value == newValue) return;
			var newRec = Object.assign({}, rec);
			newRec[_this.selectedField] = newValue;
			newArray[index] = newRec;
			dirty = true;
		});
		if (dirty) store.set(this.records.bind, newArray);
	};

	_proto.isSelected = function isSelected(store, record, index) {
		return record && record[this.selectedField];
	};

	return PropertySelection;
})(Selection);
PropertySelection.prototype.selectedField = "selected";
PropertySelection.prototype.multiple = false;
Selection.alias("property", PropertySelection);

var KeySelection = /*#__PURE__*/ (function(_Selection) {
	_inheritsLoose(KeySelection, _Selection);

	function KeySelection() {
		return _Selection.apply(this, arguments) || this;
	}

	var _proto = KeySelection.prototype;

	_proto.init = function init() {
		if (this.bind && !this.selection)
			this.selection = {
				bind: this.bind
			};
		if (!this.selection) this.selection = {};
		if (isArray(this.keyFields)) this.keyField = false;
		this.initialized = true;
	};

	_proto.getKey = function getKey(record) {
		if (this.key != null) return this.key;
		if (!record) return null;
		if (this.keyField) return record[this.keyField];
		var key = {};
		this.keyFields.forEach(function(k) {
			key[k] = record[k];
		});
		return key;
	};

	_proto.areKeysEqual = function areKeysEqual(key1, key2) {
		if (this.keyField) return key1 === key2 && key1 != null;
		if (!key1 || !key2) return false;
		return !this.keyFields.some(function(k) {
			return key1[k] !== key2[k];
		});
	};

	_proto.declareData = function declareData() {
		var _Selection$prototype$;

		return (_Selection$prototype$ = _Selection.prototype.declareData).call.apply(
			_Selection$prototype$,
			[
				this,
				{
					$selection: {
						structured: true
					}
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.configureWidget = function configureWidget(widget) {
		if (!this.initialized) this.init();
		widget.$selection = Object.assign(widget.$selection || {}, {
			keys: this.selection
		});
		return _Selection.prototype.configureWidget.call(this, widget);
	};

	_proto.selectMultiple = function selectMultiple(store, records, indexes, _temp) {
		var _this = this;

		var _ref = _temp === void 0 ? {} : _temp,
			toggle = _ref.toggle,
			add = _ref.add;

		if (!this.selection.bind) return false;
		if (this.toggle) toggle = true;

		if (!isNonEmptyArray(records)) {
			if (!toggle && !add) return store["delete"](this.selection.bind);
			return false;
		}

		var keys = records.map(function(record) {
			return _this.getKey(record);
		});
		var selection = store.get(this.selection.bind);

		if (!this.multiple) {
			var key = keys[0];
			if (!toggle || !this.areKeysEqual(selection, key)) store.set(this.selection.bind, key);
			else store["delete"](this.selection.bind);
		} else {
			if (this.storage == "array") {
				if (!isArray(selection) || (!toggle && !add)) this.updateSelectionWithShallowEqualsCheck(store, keys);
				else {
					var newSelection = [].concat(selection);
					keys.forEach(function(key) {
						var exists = selection.some(function(x) {
							return _this.areKeysEqual(x, key);
						});
						if (!exists) newSelection.push(key);
						else if (toggle)
							newSelection = newSelection.filter(function(x) {
								return !_this.areKeysEqual(x, key);
							}); //TODO: optimize
					});
					this.updateSelectionWithShallowEqualsCheck(store, newSelection);
				}
			} else if (this.storage == "hash") {
				var _newSelection = toggle ? _objectSpread2({}, selection) : {};

				keys.forEach(function(key) {
					_newSelection[key] = !_newSelection[key];
				});
				this.updateSelectionWithShallowEqualsCheck(store, _newSelection);
			}
		}
	};

	_proto.updateSelectionWithShallowEqualsCheck = function updateSelectionWithShallowEqualsCheck(store, newSelection) {
		store.update(this.selection.bind, function(data) {
			return shallowEquals(data, newSelection) ? data : newSelection;
		});
	};

	_proto.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
		var _this2 = this;

		if (!this.selection.bind)
			return function() {
				return false;
			};
		var selection = store.get(this.selection.bind);

		if (this.multiple) {
			if (this.storage == "array") {
				selection = selection || [];
				return function(record, index) {
					return selection.some(function(k) {
						return _this2.areKeysEqual(_this2.getKey(record), k);
					});
				};
			} else {
				selection = selection || {};
				return function(record, index) {
					return selection[_this2.getKey(record)];
				};
			}
		} else
			return function(record, index) {
				return _this2.areKeysEqual(selection, _this2.getKey(record));
			};
	};

	_proto.isSelected = function isSelected(store, record, index) {
		return this.getIsSelectedDelegate(store)(record, index);
	};

	return KeySelection;
})(Selection);
KeySelection.prototype.multiple = false;
KeySelection.prototype.keyField = "id";
KeySelection.prototype.storage = "array";
KeySelection.autoInit = true;
Selection.alias("key", KeySelection);

function isVisibleDeep(instance) {
	if (instance.visible && (!instance.widget.isPureContainer || !instance.widget.useParentLayout)) return true;

	if (instance.children) {
		for (var i = 0; i < instance.children.length; i++) {
			if (isVisibleDeep(instance.children[i])) return true;
		}
	}

	return false;
}

var FirstVisibleChildItem = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(FirstVisibleChildItem, _PureContainer);

	function FirstVisibleChildItem() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = FirstVisibleChildItem.prototype;

	_proto.checkVisible = function checkVisible(context, instance, data) {
		if (instance.parent.firstVisibleChild) return false;
		return _PureContainer.prototype.checkVisible.call(this, context, instance, data);
	};

	_proto.explore = function explore(context, instance) {
		if (instance.parent.firstVisibleChild) return;

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		if (instance.parent.firstVisibleChild) return;
		if (isVisibleDeep(instance)) instance.parent.firstVisibleChild = instance;
	};

	_proto.render = function render(context, instance, key) {
		if (instance.parent.firstVisibleChild != instance) return null;
		return _PureContainer.prototype.render.call(this, context, instance, key);
	};

	return FirstVisibleChildItem;
})(PureContainer);

FirstVisibleChildItem.prototype.useParentLayout = true;
var FirstVisibleChildLayout = /*#__PURE__*/ (function(_PureContainer2) {
	_inheritsLoose(FirstVisibleChildLayout, _PureContainer2);

	function FirstVisibleChildLayout() {
		return _PureContainer2.apply(this, arguments) || this;
	}

	var _proto2 = FirstVisibleChildLayout.prototype;

	_proto2.explore = function explore(context, instance) {
		instance.firstVisibleChild = null;

		_PureContainer2.prototype.explore.call(this, context, instance);
	};

	_proto2.exploreCleanup = function exploreCleanup(context, instance) {
		var children = instance.children,
			firstVisibleChild = instance.firstVisibleChild;

		if (children) {
			for (var i = 0; i < children.length; i++) {
				if (children[i] != firstVisibleChild) children[i].destroy();
			}
		}

		instance.children = [];
		if (firstVisibleChild) instance.children.push(firstVisibleChild);
	};

	_proto2.wrapItem = function wrapItem(item) {
		return item instanceof FirstVisibleChildItem
			? item
			: FirstVisibleChildItem.create({
					items: item
			  });
	};

	return FirstVisibleChildLayout;
})(PureContainer);

function validContent(r) {
	if (!r.hasOwnProperty("content")) return r;
	var content = [];

	for (var key in r) {
		if (key != "label") contentAppend(content, r[key]);
	}

	return content;
}

var LabelsLeftLayout = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(LabelsLeftLayout, _PureContainer);

	function LabelsLeftLayout() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = LabelsLeftLayout.prototype;

	_proto.init = function init() {
		this.labelStyle = parseStyle(this.labelStyle);

		_PureContainer.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(args, [
				{
					labelStyle: {
						structured: true
					},
					labelClass: {
						structured: true
					}
				}
			])
		);
	};

	_proto.render = function render(context, instance, key) {
		var result = [];
		var children = instance.children,
			data = instance.data;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var labelClass = CSS.expand(CSS.element(baseClass, "label"), data.labelClass);

		var addItem = function addItem(r, key) {
			if (!r) return;
			if (r.useParentLayout && isArray(r.content))
				r.content.forEach(function(x, i) {
					return addItem(x, key + "-" + i);
				});
			else {
				result.push(
					/*#__PURE__*/ jsxs(
						"tr",
						{
							children: [
								/*#__PURE__*/ jsx("td", {
									className: labelClass,
									style: data.labelStyle,
									children: getContent(r.label)
								}),
								/*#__PURE__*/ jsx("td", {
									className: CSS.element(baseClass, "field"),
									children: validContent(r)
								})
							]
						},
						key
					)
				);
			}
		};

		children.forEach(function(c) {
			addItem(c.vdom, c.key);
		});
		return /*#__PURE__*/ jsx(
			"table",
			{
				className: data.classNames,
				style: data.style,
				children: /*#__PURE__*/ jsx("tbody", {
					children: result
				})
			},
			key
		);
	};

	return LabelsLeftLayout;
})(PureContainer);
LabelsLeftLayout.prototype.baseClass = "labelsleftlayout";
LabelsLeftLayout.prototype.styled = true;

function validContent$1(r) {
	var content = [];

	for (var key in r) {
		if (key != "label") contentAppend(content, r[key]);
	}

	return content;
}

var LabelsTopLayout = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(LabelsTopLayout, _Container);

	function LabelsTopLayout() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = LabelsTopLayout.prototype;

	_proto.init = function init() {
		if (this.vertical && isUndefined(this.columns)) this.columns = 1;

		_Container.prototype.init.call(this);
	};

	_proto.render = function render(context, instance, key) {
		var _this = this;

		var children = instance.children,
			data = instance.data;
		var state = {
			rows: [],
			currentRow: 0,
			labelCells: [],
			fieldCells: [],
			rowCapacities: [this.columns]
		};

		var processContent = function processContent(r) {
			if (!r) return;
			if (isArray(r.content) && r.useParentLayout)
				r.content.forEach(function(x) {
					return processContent(x);
				});
			else if (r.atomic && r.type == "layout-cell")
				_this.addItem(state, isArray(r.content) && r.content.length == 1 ? r.content[0] : r.content, r.data);
			else _this.addItem(state, r, {});
		};

		children.forEach(function(item) {
			return processContent(item.vdom);
		});
		this.addRow(state);
		return /*#__PURE__*/ jsx(
			"table",
			{
				className: data.classNames,
				style: data.style,
				children: /*#__PURE__*/ jsx("tbody", {
					children: state.rows
				})
			},
			key
		);
	};

	_proto.addRow = function addRow(state) {
		if (state.labelCells.length > 0)
			state.rows.push(
				/*#__PURE__*/ jsx(
					"tr",
					{
						children: state.labelCells
					},
					state.rows.length
				)
			);
		if (state.fieldCells.length > 0)
			state.rows.push(
				/*#__PURE__*/ jsx(
					"tr",
					{
						children: state.fieldCells
					},
					state.rows.length
				)
			);
		state.labelCells = [];
		state.fieldCells = [];
		state.currentRow++;
		if (state.currentRow == state.rowCapacities.length) state.rowCapacities.push(this.columns);
	};

	_proto.addItem = function addItem(state, item, data) {
		while (state.labelCells.length == state.rowCapacities[state.currentRow]) {
			this.addRow(state);
		}

		if (data.rowSpan > 1) {
			for (var row = state.currentRow + 1; row < state.currentRow + data.rowSpan; row++) {
				if (row == state.rowCapacities.length) state.rowCapacities.push(this.columns);
				state.rowCapacities[row] -= data.colSpan || 1;
			}
		}

		if (data.colSpan > 1) state.rowCapacities[state.currentRow] -= data.colSpan - 1;
		state.labelCells.push(
			/*#__PURE__*/ jsx(
				"td",
				{
					className: this.CSS.element(this.baseClass, "label"),
					colSpan: data.colSpan,
					children: getContent(item.label)
				},
				state.labelCells.length
			)
		);
		state.fieldCells.push(
			/*#__PURE__*/ jsx(
				"td",
				{
					className: this.CSS.element(this.baseClass, "field"),
					colSpan: data.colSpan,
					rowSpan: isNumber(data.rowSpan) ? 2 * data.rowSpan - 1 : undefined,
					style: data.style,
					children: validContent$1(item)
				},
				state.fieldCells.length
			)
		);
	};

	return LabelsTopLayout;
})(Container);
LabelsTopLayout.prototype.baseClass = "labelstoplayout";
LabelsTopLayout.prototype.vertical = false;
LabelsTopLayout.prototype.columns = undefined;
LabelsTopLayout.prototype.styled = true;
var LabelsTopLayoutCell = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(LabelsTopLayoutCell, _PureContainer);

	function LabelsTopLayoutCell() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto2 = LabelsTopLayoutCell.prototype;

	_proto2.declareData = function declareData() {
		var _PureContainer$protot;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(args, [
				{
					colSpan: undefined,
					rowSpan: undefined
				}
			])
		);
	};

	_proto2.render = function render(context, instance, key) {
		var _this$renderChildren = this.renderChildren(context, instance),
			content = _this$renderChildren.content;

		return {
			atomic: true,
			type: "layout-cell",
			data: instance.data,
			content: content
		};
	};

	return LabelsTopLayoutCell;
})(PureContainer);
LabelsTopLayoutCell.prototype.styled = true;
LabelsTopLayoutCell.prototype.useParentLayout = true;

var Content = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(Content, _PureContainer);

	function Content() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = Content.prototype;

	_proto.init = function init() {
		_PureContainer.prototype.init.call(this);

		this.putInto = this["for"] || this.name;
	};

	return Content;
})(PureContainer);
Content.prototype.name = "body";
Content.prototype.isContent = true;
Widget.alias("content", Content);

var ContentPlaceholder = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(ContentPlaceholder, _PureContainer);

	function ContentPlaceholder() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = ContentPlaceholder.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					name: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		var _this = this;

		instance.content = null;
		var data = instance.data;
		var content = context.content && context.content[data.name];
		if (content && !this.scoped) this.setContent(context, instance, content);
		else
			context.pushNamedValue("contentPlaceholder", data.name, function(content) {
				_this.setContent(context, instance, content);
			});
		if (this.scoped)
			instance.unregisterContentPlaceholder = function() {
				context.popNamedValue("contentPlaceholder", data.name);
			};

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto.prepare = function prepare(context, instance) {
		var content = instance.content;
		if (instance.cache("content", content) || (content && content.shouldUpdate)) instance.markShouldUpdate(context);
	};

	_proto.setContent = function setContent(context, instance, content) {
		instance.content = content;
		content.contentPlaceholder = instance;
	};

	_proto.render = function render(context, instance, key) {
		var content = instance.content;
		if (content) return content.contentVDOM;
		return _PureContainer.prototype.render.call(this, context, instance, key);
	};

	return ContentPlaceholder;
})(PureContainer);
ContentPlaceholder.prototype.name = "body";
ContentPlaceholder.prototype.scoped = false;
Widget.alias("content-placeholder", ContentPlaceholder);
var ContentPlaceholderScope = /*#__PURE__*/ (function(_PureContainer2) {
	_inheritsLoose(ContentPlaceholderScope, _PureContainer2);

	function ContentPlaceholderScope() {
		return _PureContainer2.apply(this, arguments) || this;
	}

	var _proto2 = ContentPlaceholderScope.prototype;

	_proto2.init = function init() {
		_PureContainer2.prototype.init.call(this);

		if (isString(this.name)) this.name = [this.name];
	};

	_proto2.explore = function explore(context, instance) {
		this.name.forEach(function(name) {
			context.pushNamedValue("contentPlaceholder", name, null);
			context.pushNamedValue("content", name, null);
		});

		_PureContainer2.prototype.explore.call(this, context, instance);
	};

	_proto2.exploreCleanup = function exploreCleanup(context, instance) {
		this.name.forEach(function(name) {
			context.popNamedValue("contentPlaceholder", name);
			context.popNamedValue("content", name);
		});
	};

	return ContentPlaceholderScope;
})(PureContainer);

function startAppLoop(parentDOMElement, storeOrInstance, widget, options) {
	if (options === void 0) {
		options = {};
	}

	if (!parentDOMElement || parentDOMElement.nodeType !== 1)
		throw new Error("First argument to startAppLoop should be a valid DOM element.");
	var store, instance, parentInstance;
	if (!storeOrInstance) storeOrInstance = new Store();
	if (storeOrInstance.notify) store = storeOrInstance;
	else if (storeOrInstance.getChild) {
		if (storeOrInstance.widget === widget) instance = storeOrInstance;
		else parentInstance = storeOrInstance;
	} else throw new Error("Second argument to startAppLoop should be either of type Store or Instance");

	var root = /*#__PURE__*/ jsx(Cx, {
		store: store,
		widget: widget,
		instance: instance,
		parentInstance: parentInstance,
		options: options,
		subscribe: true
	});

	VDOM$1.DOM.render(root, parentDOMElement);
	var stopped = false;
	return function() {
		if (stopped) return;
		stopped = true;
		if (!options.destroyDelay) destroy(parentDOMElement, options);
		else {
			setTimeout(function() {
				destroy(parentDOMElement, options);
			}, options.destroyDelay);
		}
	};
}

function destroy(parentDOMElement, options) {
	VDOM$1.DOM.unmountComponentAtNode(parentDOMElement);
	if (options.removeParentDOMElement && parentDOMElement.parentNode)
		parentDOMElement.parentNode.removeChild(parentDOMElement);
}

var Url = /*#__PURE__*/ (function() {
	function Url() {}

	Url.resolve = function resolve(path) {
		return path.replace("~/", this.base);
	};

	Url.absolute = function absolute(path) {
		return path.replace("~/", this.absoluteBase);
	};

	Url.unresolve = function unresolve(path) {
		if (path.indexOf("~/") == 0) return path;
		var absBase = this.absoluteBase || ""; //handle paths like /app and /app/

		if (path.length == absBase.length - 1 && absBase == path + "/") return "~/";
		if (path.indexOf(absBase) == 0) return "~/" + path.substring(absBase.length);
		return "~/" + path.substring(this.base.length);
	};

	Url.getAbsoluteBase = function getAbsoluteBase() {
		return this.absoluteBase;
	};

	Url.isLocal = function isLocal(url) {
		var absBase = this.getAbsoluteBase();
		return url.indexOf("~/") == 0 || url.indexOf(absBase) == 0 || url.indexOf(this.base) == 0;
	};

	Url.setBase = function setBase(base) {
		if (!base || base[base.length - 1] != "/") base += "/";
		this.base = base;
		if (typeof window != "undefined")
			this.absoluteBase = window.location.protocol + "//" + window.location.host + this.base;
	};

	Url.getOrigin = function getOrigin() {
		if (typeof window == "undefined") return "";
		return (
			window.location.protocol +
			"//" +
			window.location.hostname +
			(window.location.port ? ":" + window.location.port : "")
		);
	};

	Url.getBaseFromScriptSrc = function getBaseFromScriptSrc(src, scriptPath) {
		if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);
		var index = src.search(scriptPath);
		if (index == -1) return false;
		var origin = this.getOrigin();
		return src.substring(src.indexOf(origin) == 0 ? origin.length : 0, index);
	};

	Url.setBaseFromScript = function setBaseFromScript(scriptPath) {
		var scripts = document.getElementsByTagName("script"),
			base;
		if (!(scriptPath instanceof RegExp)) scriptPath = getBasePathRegex(scriptPath);

		for (var i = 0; i < scripts.length; i++) {
			base = this.getBaseFromScriptSrc(scripts[i].src, scriptPath);

			if (base) {
				this.setBase(base);
				return;
			}
		}

		throw new Error("Could not resolve url base from script matching '" + scriptPath + "'.");
	};

	return Url;
})();
Url.setBase("/");

function getBasePathRegex(str) {
	var regex = "";
	var start = 0;
	if (str.indexOf("~/") == 0) start = 2;

	for (var i = start; i < str.length; i++) {
		switch (str[i]) {
			case ".":
				regex += "\\.";
				break;

			case "*":
				regex += ".*";
				break;

			default:
				regex += str[i];
		}
	}

	return new RegExp(regex + "(\\?.*)?$", "i");
}

var last = 0,
	next = 1,
	transitions = {},
	subscribers$3 = null,
	reload = false,
	navigateConfirmationCallback = null,
	permanentNavigateConfirmation = false;
var History = /*#__PURE__*/ (function() {
	function History() {}

	History.connect = function connect(store, urlBinding, hashBinding) {
		var _this = this;

		this.store = store;
		this.urlBinding = urlBinding;
		this.hashBinding = hashBinding;
		this.updateStore();

		window.onpopstate = function() {
			_this.updateStore();
		};
	};

	History.pushState = function pushState(state, title, url) {
		return this.confirmAndNavigate(state, title, url);
	};

	History.replaceState = function replaceState(state, title, url) {
		return this.navigate(state, title, url, true);
	};

	History.reloadOnNextChange = function reloadOnNextChange() {
		reload = true;
	};

	History.addNavigateConfirmation = function addNavigateConfirmation(callback, permanent) {
		if (permanent === void 0) {
			permanent = false;
		}

		navigateConfirmationCallback = callback;
		permanentNavigateConfirmation = permanent;
	};

	History.confirmAndNavigate = function confirmAndNavigate(state, title, url, replace) {
		var _this2 = this;

		if (!navigateConfirmationCallback) return this.navigate(state, title, url, replace);
		var result = navigateConfirmationCallback(url);
		Promise.resolve(result).then(function(value) {
			if (value) {
				if (!permanentNavigateConfirmation) navigateConfirmationCallback = null;

				_this2.navigate(state, title, url, replace);
			}
		});
		return false;
	};

	History.navigate = function navigate(state, title, url, replace) {
		var _this3 = this;

		if (replace === void 0) {
			replace = false;
		}

		url = Url.resolve(url);

		if (!window.history.pushState || reload) {
			window.location[replace ? "replace" : "assign"](url);
			return true;
		}

		var transition,
			changed = false;
		batchUpdatesAndNotify(
			function() {
				changed = _this3.updateStore(url);
				if (changed)
					transitions[++last] = transition = {
						url: url,
						state: state,
						title: title,
						replace: replace
					};
			},
			function() {
				if (transition) transition.completed = true; //update history once the page is rendered and the title is set

				while (transitions[next] && transitions[next].completed) {
					var tr = transitions[next];
					delete transitions[next];
					next++;
					var op = tr.replace ? "replaceState" : "pushState";
					window.history[op](tr.state, tr.title, tr.url);
					if (subscribers$3) subscribers$3.notify(tr.url, op);
				}
			}
		);
		return changed;
	};

	History.updateStore = function updateStore(href) {
		var url = Url.unresolve(href || document.location.href),
			hash = null;
		var hashIndex = url.indexOf("#");

		if (hashIndex !== -1) {
			hash = url.substring(hashIndex);
			url = url.substring(0, hashIndex);
		}

		if (this.hashBinding) this.store.set(this.hashBinding, hash);
		return this.store.set(this.urlBinding, url);
	};

	History.subscribe = function subscribe(callback) {
		if (!subscribers$3) subscribers$3 = new SubscriberList();
		return subscribers$3.subscribe(callback);
	};

	return History;
})();

function startHotAppLoop(appModule, element, store, widgets, options) {
	var stop; //webpack (HMR)

	if (appModule.hot) {
		// accept itself
		appModule.hot.accept(); // remember data on dispose

		appModule.hot.dispose(function(data) {
			data.state = store.getData();
			if (stop) stop();
		}); //apply data on hot replace

		if (appModule.hot.data) store.load(appModule.hot.data.state);
	}

	Widget.resetCounter(); //app loop

	return (stop = startAppLoop(element, store, widgets, options));
}

var GroupAdapter = /*#__PURE__*/ (function(_ArrayAdapter) {
	_inheritsLoose(GroupAdapter, _ArrayAdapter);

	function GroupAdapter() {
		return _ArrayAdapter.apply(this, arguments) || this;
	}

	var _proto = GroupAdapter.prototype;

	_proto.init = function init() {
		_ArrayAdapter.prototype.init.call(this);

		if (this.groupRecordsAlias) this.groupRecordsName = this.groupRecordsAlias;
		if (this.groupings) this.groupBy(this.groupings);
	};

	_proto.getRecords = function getRecords(context, instance, records, parentStore) {
		var result = _ArrayAdapter.prototype.getRecords.call(this, context, instance, records, parentStore);

		if (this.groupings) {
			var groupedResults = [];
			this.processLevel([], result, groupedResults, parentStore);
			result = groupedResults;
		}

		return result;
	};

	_proto.processLevel = function processLevel(keys, records, result, parentStore) {
		var _this = this;

		var level = keys.length;
		var inverseLevel = this.groupings.length - level;

		if (inverseLevel == 0) {
			for (var i = 0; i < records.length; i++) {
				records[i].store.setStore(parentStore);
				result.push(records[i]);
			}

			return;
		}

		var grouping = this.groupings[level];
		var grouper = grouping.grouper;
		grouper.reset();
		grouper.processAll(records);
		var results = grouper.getResults();
		if (grouping.comparer) results.sort(grouping.comparer);
		results.forEach(function(gr) {
			var _data;

			keys.push(gr.key);
			var key = keys
				.map(function(key) {
					return Object.keys(key)
						.map(function(k) {
							return key[k];
						})
						.join(":");
				})
				.join("|");

			var $group = _objectSpread2(
				_objectSpread2(_objectSpread2({}, gr.key), gr.aggregates),
				{},
				{
					$name: gr.name,
					$level: inverseLevel,
					$records: gr.records || [],
					$key: key
				}
			);

			var data =
				((_data = {}),
				(_data[_this.recordName] = gr.records.length > 0 ? gr.records[0].data : null),
				(_data[_this.groupName] = $group),
				_data);
			var groupStore = new ReadOnlyDataView({
				store: parentStore,
				data: data,
				immutable: _this.immutable
			});
			var group = {
				key: key,
				data: data,
				group: $group,
				grouping: grouping,
				store: groupStore,
				level: inverseLevel
			};
			if (grouping.includeHeader !== false)
				result.push(
					_objectSpread2(
						_objectSpread2({}, group),
						{},
						{
							type: "group-header",
							key: "header:" + group.key
						}
					)
				);

			_this.processLevel(keys, gr.records, result, groupStore);

			if (grouping.includeFooter !== false)
				result.push(
					_objectSpread2(
						_objectSpread2({}, group),
						{},
						{
							type: "group-footer",
							key: "footer:" + group.key
						}
					)
				);
			keys.pop();
		});
	};

	_proto.groupBy = function groupBy(groupings) {
		var _this2 = this;

		if (!groupings) this.groupings = null;
		else if (isArray(groupings)) {
			this.groupings = groupings;
			this.groupings.forEach(function(g) {
				var groupSorters = [];
				var key = {};

				for (var name in g.key) {
					if (!g.key[name] || !isDefined(g.key[name].direction) || !isDefined(g.key[name].value))
						g.key[name] = {
							value: g.key[name],
							direction: "ASC"
						};
					key[name] = g.key[name].value;
					groupSorters.push({
						field: name,
						direction: g.key[name].direction
					});
				}

				g.grouper = new Grouper(
					key,
					_objectSpread2(_objectSpread2({}, _this2.aggregates), g.aggregates),
					function(r) {
						return r.store.getData();
					},
					g.text
				);
				g.comparer = null;
				if (groupSorters.length > 0)
					g.comparer = getComparer(
						groupSorters,
						function(x) {
							return x.key;
						},
						_this2.sortOptions ? Culture.getComparer(_this2.sortOptions) : null
					);
			});
		} else throw new Error("Invalid grouping provided.");
	};

	return GroupAdapter;
})(ArrayAdapter);
GroupAdapter.prototype.groupName = "$group";

var TreeAdapter = /*#__PURE__*/ (function(_ArrayAdapter) {
	_inheritsLoose(TreeAdapter, _ArrayAdapter);

	function TreeAdapter() {
		return _ArrayAdapter.apply(this, arguments) || this;
	}

	var _proto = TreeAdapter.prototype;

	_proto.init = function init() {
		_ArrayAdapter.prototype.init.call(this);

		this.childrenAccessor = getAccessor({
			bind: this.recordName + "." + this.childrenField
		});
	};

	_proto.mapRecords = function mapRecords(context, instance, data, parentStore, recordsAccessor) {
		var nodes = _ArrayAdapter.prototype.mapRecords.call(this, context, instance, data, parentStore, recordsAccessor);

		var result = [];
		this.processList(context, instance, 0, "", nodes, result);
		return result;
	};

	_proto.processList = function processList(context, instance, level, parentKey, nodes, result) {
		var _this = this;

		var nonLeafs = [],
			leafs = [];
		nodes.forEach(function(record) {
			record.key = parentKey + record.key;

			_this.processNode(context, instance, level, record.data.$leaf ? leafs : nonLeafs, record);
		});
		result.push.apply(result, nonLeafs.concat(leafs));
	};

	_proto.processNode = function processNode(context, instance, level, result, record) {
		var _this2 = this;

		result.push(record);
		var data = record.data,
			store = record.store;
		data.$level = level;

		if (!data[this.leafField]) {
			if (data[this.expandedField]) {
				if (data[this.childrenField]) {
					var childNodes = _ArrayAdapter.prototype.mapRecords.call(
						this,
						context,
						instance,
						data[this.childrenField],
						store,
						this.childrenAccessor
					);

					this.processList(context, instance, level + 1, record.key + ":", childNodes, result);
				} else if (this.load && !data[this.loadedField] && !data[this.loadingField]) {
					store.set(this.recordName + "." + this.loadingField, true);
					var response = this.load(context, instance, data);
					Promise.resolve(response)
						.then(function(children) {
							store.set(_this2.recordName + "." + _this2.childrenField, children);
							store.set(_this2.recordName + "." + _this2.loadedField, true);
							store.set(_this2.recordName + "." + _this2.loadingField, false);
						})
						["catch"](function(response) {
							store.set(_this2.recordName + "." + _this2.loadingField, false);
							if (_this2.onLoadError) _this2.onLoadError(response);
						});
				}
			} else data[this.expandedField] = false;
		}
	};

	_proto.sort = function sort(sorters) {
		if (this.foldersFirst) {
			if (!sorters || !isArray(sorters)) sorters = [];
			sorters = [
				{
					field: this.leafField,
					direction: "ASC"
				}
			].concat(sorters);
		}

		_ArrayAdapter.prototype.sort.call(this, sorters);
	};

	return TreeAdapter;
})(ArrayAdapter);
TreeAdapter.prototype.childrenField = "$children";
TreeAdapter.prototype.expandedField = "$expanded";
TreeAdapter.prototype.leafField = "$leaf";
TreeAdapter.prototype.loadingField = "$loading";
TreeAdapter.prototype.loadedField = "$loaded";
TreeAdapter.prototype.foldersFirst = true;
TreeAdapter.prototype.isTreeAdapter = true;

function bind(path, defaultValue) {
	return {
		bind: path,
		defaultValue: defaultValue
	};
}

function tpl(text) {
	return {
		tpl: text
	};
}

function expr(text) {
	return {
		expr: text
	};
}

export {
	ArrayAdapter,
	CSS,
	CSSHelper,
	Container,
	Content,
	ContentPlaceholder,
	ContentPlaceholderScope,
	ContentResolver,
	Controller,
	Culture,
	Cx,
	DataAdapter,
	DataProxy,
	DetachedScope,
	FirstVisibleChildLayout,
	FocusManager,
	Format,
	GroupAdapter,
	History,
	HoverSync,
	HoverSyncElement,
	Instance,
	InstanceCache,
	IsolatedScope,
	KeySelection,
	LabelsLeftLayout,
	LabelsTopLayout,
	LabelsTopLayoutCell,
	Localization,
	PrivateStore,
	PropertySelection,
	PureContainer,
	RenderingContext,
	Repeater,
	Rescope,
	ResizeManager,
	Restate,
	Selection,
	StaticText,
	StructuredInstanceDataAccessor,
	Text,
	TreeAdapter,
	Url,
	UseParentLayout,
	VDOM$1 as VDOM,
	Widget,
	ZIndexManager,
	batchUpdates,
	batchUpdatesAndNotify,
	bind,
	contentAppend,
	createFunctionalComponent,
	enableCultureSensitiveFormatting,
	executeKeyboardShortcuts,
	exploreChildren,
	expr,
	flattenProps,
	getContent,
	getContentArray,
	getCurrentInstance,
	isBatchingUpdates,
	notifyBatchedUpdateCompleted,
	notifyBatchedUpdateStarting,
	offFocusOut,
	oneFocusOut,
	preventFocus,
	preventFocusOnTouch,
	registerKeyboardShortcut,
	startAppLoop,
	startHotAppLoop,
	tpl,
	withHoverSync
};
