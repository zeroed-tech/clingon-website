import {
	FocusManager,
	Url,
	VDOM,
	Container,
	Widget,
	createFunctionalComponent,
	flattenProps,
	preventFocus,
	getContentArray,
	GroupAdapter,
	Selection,
	getContent,
	offFocusOut,
	preventFocusOnTouch,
	batchUpdates,
	oneFocusOut,
	PureContainer,
	ZIndexManager,
	startAppLoop,
	ResizeManager,
	Localization,
	RenderingContext,
	ContentPlaceholder,
	Text,
	History,
	Cx,
	registerKeyboardShortcut,
	Culture,
	enableCultureSensitiveFormatting,
	Format,
	ContentResolver,
	DataProxy,
	KeySelection,
	DataAdapter,
	InstanceCache,
	StaticText
} from "cx/ui";
export {
	ArrayAdapter,
	Content,
	ContentPlaceholder,
	ContentPlaceholderScope,
	ContentResolver,
	DataAdapter,
	DataProxy,
	DetachedScope,
	GroupAdapter,
	IsolatedScope,
	PrivateStore,
	PureContainer,
	Repeater,
	Rescope,
	Restate,
	StaticText,
	Text,
	TreeAdapter,
	Widget
} from "cx/ui";
import {
	isTouchEvent,
	isString,
	isDefined,
	isArray,
	debug,
	isUndefined,
	isFunction,
	isNumber,
	isComponentFactory,
	createComponentFactory,
	deprecatedFlag,
	coalesce,
	addEventListenerWithOptions,
	scrollElementIntoView,
	KeyCode,
	parseStyle,
	getParentFrameBoundingClientRect,
	getSearchQueryHighlighter,
	SubscriberList,
	getTopLevelBoundingClientRect,
	isObject,
	Console,
	getScrollerBoundingClientRect,
	isSelfOrDescendant,
	closest,
	isTouchDevice,
	calculateNaturalElementHeight,
	findFirst,
	isFocusable,
	isNonEmptyArray,
	tooltipsFlag,
	shallowEquals,
	stopPropagation,
	routeAppend,
	menuFlag,
	isTextInputElement,
	getActiveElement,
	findFirstChild,
	isFocused,
	isFocusedDeep,
	getFocusedElement,
	isPromise,
	preventDefault,
	zeroTime,
	dateDiff,
	upperBoundCheck,
	lowerBoundCheck,
	monthStart,
	sameDate,
	getSearchQueryPredicate,
	minDate,
	maxDate,
	rgbToHex,
	parseColor,
	rgbToHsl,
	hslToRgb,
	getVendorPrefix,
	Format as Format$1,
	debounce,
	findScrollableParent
} from "cx/util";
import { jsx, jsxs } from "react/jsx-runtime";
import {
	getAccessor,
	Binding,
	ExposedValueView,
	isBinding,
	isSelector,
	ReadOnlyDataView,
	StringTemplate,
	getSelector,
	enableFatArrowExpansion
} from "cx/data";
import RouteMatcher from "route-parser";
import { DateTimeCulture } from "intl-io";
import { HtmlElement as HtmlElement$1 } from "cx/widgets";
import { parseStyle as parseStyle$1 } from "cx/src/util";

function _defineProperty(obj, key, value) {
	if (key in obj) {
		Object.defineProperty(obj, key, {
			value: value,
			enumerable: true,
			configurable: true,
			writable: true
		});
	} else {
		obj[key] = value;
	}

	return obj;
}

function ownKeys(object, enumerableOnly) {
	var keys = Object.keys(object);

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(object);
		if (enumerableOnly)
			symbols = symbols.filter(function(sym) {
				return Object.getOwnPropertyDescriptor(object, sym).enumerable;
			});
		keys.push.apply(keys, symbols);
	}

	return keys;
}

function _objectSpread2(target) {
	for (var i = 1; i < arguments.length; i++) {
		var source = arguments[i] != null ? arguments[i] : {};

		if (i % 2) {
			ownKeys(Object(source), true).forEach(function(key) {
				_defineProperty(target, key, source[key]);
			});
		} else if (Object.getOwnPropertyDescriptors) {
			Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
		} else {
			ownKeys(Object(source)).forEach(function(key) {
				Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
			});
		}
	}

	return target;
}

function _inheritsLoose(subClass, superClass) {
	subClass.prototype = Object.create(superClass.prototype);
	subClass.prototype.constructor = subClass;

	_setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
	_setPrototypeOf =
		Object.setPrototypeOf ||
		function _setPrototypeOf(o, p) {
			o.__proto__ = p;
			return o;
		};

	return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
	if (source == null) return {};
	var target = {};
	var sourceKeys = Object.keys(source);
	var key, i;

	for (i = 0; i < sourceKeys.length; i++) {
		key = sourceKeys[i];
		if (excluded.indexOf(key) >= 0) continue;
		target[key] = source[key];
	}

	return target;
}

function _assertThisInitialized(self) {
	if (self === void 0) {
		throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	}

	return self;
}

var impl = false;
function tooltipMouseMove(e, parentInstance, tooltip, options) {
	if (options === void 0) {
		options = {};
	}

	return impl && impl.tooltipMouseMove.apply(impl, arguments);
}
function tooltipMouseLeave(e, parentInstance, tooltip, options) {
	return impl && impl.tooltipMouseLeave.apply(impl, arguments);
}
function tooltipParentDidMount(element, parentInstance, tooltip, options) {
	return impl && impl.tooltipParentDidMount.apply(impl, arguments);
}
function tooltipParentWillReceiveProps(element, parentInstance, tooltip, options) {
	return impl && impl.tooltipParentWillReceiveProps.apply(impl, arguments);
}
function tooltipParentWillUnmount(parentInstance) {
	return impl && impl.tooltipParentWillUnmount.apply(impl, arguments);
}
function wireTooltipOps(ops) {
	impl = ops;
}

function autoFocus(el, component) {
	if (isTouchEvent()) return;
	var data = component.props.data || component.props.instance.data;
	var autoFocusValue = el && data.autoFocus;
	if (autoFocusValue && autoFocusValue != component.autoFocusValue) FocusManager.focus(el);
	component.autoFocusValue = autoFocusValue;
}

var isDataAttribute = function isDataAttribute(attr) {
	return attr.indexOf("data-") == 0 ? attr.substring(5) : false;
};

var urlAttributes = {
	"a.href": true,
	"img.src": true,
	"iframe.src": true
};
var HtmlElement = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(HtmlElement, _Container);

	function HtmlElement(config) {
		var _this;

		_this = _Container.call(this, config) || this;
		if (isUndefined(_this.jsxAttributes) && config)
			_this.jsxAttributes = Object.keys(config).filter(_this.isValidHtmlAttribute.bind(_assertThisInitialized(_this)));
		return _this;
	}

	var _proto = HtmlElement.prototype;

	_proto.declareData = function declareData() {
		var _this2 = this,
			_Container$prototype$;

		var data = {
			text: undefined,
			innerHtml: undefined,
			attrs: {
				structured: true
			},
			data: {
				structured: true
			},
			autoFocus: undefined
		};
		var name;
		this.urlAttributes = [];

		if (this.jsxAttributes) {
			this.jsxAttributes.forEach(function(attr) {
				if (urlAttributes[_this2.tag + "." + attr]) _this2.urlAttributes.push(attr);

				if ((name = isDataAttribute(attr))) {
					if (!_this2.data) _this2.data = {};
					_this2.data[name] = _this2[attr];
				} else if ((name = _this2.isValidHtmlAttribute(attr)) && !data.hasOwnProperty(name)) {
					if (name.indexOf("on") == 0) {
						if (_this2[attr]) {
							if (!_this2.events) _this2.events = {};
							_this2.events[name] = _this2[attr];
						}
					} else {
						if (!_this2.attrs) _this2.attrs = {};
						_this2.attrs[name] = _this2[attr];
					}
				}
			});
		}

		if (this.urlAttributes.length == 0) delete this.urlAttributes;

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(Array.prototype.slice.call(arguments), [data])
		);
	};

	_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
		switch (attrName) {
			case "tag":
			case "type":
			case "$type":
			case "$props":
			case "text":
			case "layout":
			case "class":
			case "className":
			case "style":
			case "controller":
			case "outerLayout":
			case "items":
			case "children":
			case "visible":
			case "if":
			case "mod":
			case "putInto":
			case "contentFor":
			case "trimWhitespace":
			case "preserveWhitespace":
			case "ws":
			case "plainText":
			case "vertical":
			case "memoize":
			case "onInit":
			case "onExplore":
			case "onDestroy":
			case "onRef":
			case "html":
			case "innerText":
			case "baseClass":
			case "CSS":
			case "tooltip":
			case "styles":
			case "jsxAttributes":
			case "jsxSpread":
			case "instance":
			case "store":
			case "autoFocus":
				return false;

			default:
				if (isDataAttribute(attrName)) return false;
				break;
		}

		return attrName;
	};

	_proto.init = function init() {
		if (this.html) this.innerHtml = this.html;
		if (this.innerText) this.text = this.innerText;

		_Container.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;

		if (this.urlAttributes && data.attrs) {
			data.attrs = _objectSpread2({}, data.attrs);
			this.urlAttributes.forEach(function(attr) {
				if (isString(data.attrs[attr])) data.attrs[attr] = Url.resolve(data.attrs[attr]);
			});
		}

		_Container.prototype.prepareData.call(this, context, instance);
	};

	_proto.attachProps = function attachProps(context, instance, props) {
		Object.assign(props, this.extraProps);
		if (!isString(this.tag)) props.instance = instance;
	};

	_proto.render = function render(context, instance, key) {
		//rebind events to pass instance
		if (this.events && !instance.events) {
			instance.events = {};

			var _loop = function _loop(eventName) {
				instance.events[eventName] = function(e) {
					return instance.invoke(eventName, e, instance);
				};
			};

			for (var eventName in this.events) {
				_loop(eventName);
			}
		}

		var data = instance.data,
			events = instance.events;
		var props = Object.assign(
			{
				key: key
			},
			data.attrs,
			events
		);
		if (data.classNames) props.className = data.classNames;
		if (data.style) props.style = data.style;
		var children;
		if (isDefined(data.text)) children = data.text;
		else if (isString(data.innerHtml)) {
			props.dangerouslySetInnerHTML = {
				__html: data.innerHtml
			};
		} else {
			children = this.renderChildren(context, instance);
			if (children && isArray(children) && children.length == 0) children = undefined;
		}
		props.children = children;
		this.attachProps(context, instance, props);
		if (this.tooltip || this.onRef || this.autoFocus)
			return /*#__PURE__*/ jsx(
				ContainerComponent,
				{
					tag: this.tag,
					props: props,
					instance: instance,
					data: data,
					children: props.children
				},
				key
			);
		return VDOM.createElement(this.tag, props, props.children);
	};

	return HtmlElement;
})(Container);
HtmlElement.prototype.tag = "div";
HtmlElement.prototype.styled = true;

var ContainerComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(ContainerComponent, _VDOM$Component);

	function ContainerComponent(props) {
		var _this3;

		_this3 = _VDOM$Component.call(this, props) || this;

		_this3.ref = function(c) {
			_this3.el = c;
			var instance = _this3.props.instance;

			if (instance.widget.onRef) {
				instance.invoke("onRef", c, instance);
			}
		};

		return _this3;
	}

	var _proto2 = ContainerComponent.prototype;

	_proto2.render = function render() {
		var _this$props = this.props,
			tag = _this$props.tag,
			props = _this$props.props,
			children = _this$props.children,
			instance = _this$props.instance;
		var widget = instance.widget;
		props.ref = this.ref;

		if (widget.tooltip) {
			var onMouseLeave = props.onMouseLeave,
				onMouseMove = props.onMouseMove;

			props.onMouseLeave = function(e) {
				tooltipMouseLeave(e, instance, widget.tooltip);
				if (onMouseLeave) onMouseLeave(e);
			};

			props.onMouseMove = function(e) {
				tooltipMouseMove(e, instance, widget.tooltip);
				if (onMouseMove) onMouseMove(e);
			};
		}

		return VDOM.createElement(tag, props, children);
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		tooltipParentWillReceiveProps(this.el, props.instance, this.props.instance.widget.tooltip);
	};

	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount(this.el, this.props.instance, this.props.instance.widget.tooltip);
		autoFocus(this.el, this);
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		autoFocus(this.el, this);
	};

	return ContainerComponent;
})(VDOM.Component);

var originalWidgetFactory = Widget.factory; //support for React components

Widget.factory = function(type, config, more) {
	var typeType = typeof type;

	if (typeType == "undefined") {
		debug("Creating a widget of unknown type.", config, more);
		return new HtmlElement(Object.assign({}, config, more));
	}

	if (typeType == "function")
		return HtmlElement.create(
			HtmlElement,
			{
				tag: type
			},
			config
		);
	return originalWidgetFactory.call(Widget, type, config, more);
};

Widget.alias("html-element", HtmlElement);

var htmlFactoryCache = {};

function getHtmlElementFactory(tagName) {
	var factory = htmlFactoryCache[tagName];
	if (factory) return factory;
	return (htmlFactoryCache[tagName] = createComponentFactory(
		function() {},
		function(config) {
			return HtmlElement.create(
				HtmlElement,
				{
					tag: tagName
				},
				flattenProps(config)
			);
		},
		{
			tag: tagName
		}
	));
}

function cx(typeName, props) {
	for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		children[_key - 2] = arguments[_key];
	}

	if (isArray(typeName)) return typeName;
	if (isFunction(typeName) && isUndefined(props))
		return createFunctionalComponent(function(config) {
			return typeName(flattenProps(config));
		});
	if (typeName.type || typeName.$type) return typeName;
	if (children && children.length == 0) children = null;
	if (children && children.length == 1) children = children[0];
	if (typeName == "cx") return children;
	if (typeName == "react") return react(children);
	if (isString(typeName) && typeName[0] == typeName[0].toLowerCase()) typeName = getHtmlElementFactory(typeName);
	return {
		$type: typeName,
		$props: props,
		jsxAttributes: props && Object.keys(props),
		children: children
	};
}
function react(config) {
	if (!config || isString(config) || isNumber(config) || VDOM.isValidElement(config)) return config;
	if (isArray(config)) return config.map(react);
	var type = config.$type;
	if (isComponentFactory(type) && type.$meta && type.$meta.tag) type = type.$meta.tag;
	if (isArray(config.children))
		return VDOM.createElement.apply(VDOM, [type, config.$props].concat(config.children.map(react)));
	return VDOM.createElement(type, config.$props, react(config.children));
}

function getMessage(options) {
	debug(
		deprecatedFlag,
		"Call enableMsgBoxes() on startup to use Cx based message boxes. Message boxes are not auto enabled anymore to reduce the bundle size for apps that do not use them. "
	);
	if (!options) return null;
	if (isString(options)) return options;
	if (options && options.message) return options.message;
	return null;
}

var impl$1 = {
	yesNo: function yesNo(options) {
		var result = window.confirm(getMessage(options));
		return Promise.resolve(result ? "yes" : "no");
	},
	alert: function alert(options) {
		window.alert(getMessage(options));
		return Promise.resolve();
	}
};
function yesNo(options) {
	return impl$1.yesNo.apply(impl$1, arguments);
}
function registerAlertImpl(x) {
	impl$1 = x;
}

var icons = {};
var iconFactory = null;
var defaultIcons = {};
var unregisteredDefaultIcons = {};
function registerIcon(name, icon, defaultIcon) {
	if (defaultIcon === void 0) {
		defaultIcon = false;
	}

	if (!defaultIcon || !unregisteredDefaultIcons[name]) icons[name] = icon;
	if (!defaultIcon) unregisteredDefaultIcons[name] = true;
	else defaultIcons[name] = icon;
	return function(props) {
		return renderIcon(name, props);
	};
}
function unregisterIcon() {
	for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
		args[_key] = arguments[_key];
	}

	args.forEach(function(name) {
		delete icons[name];
		unregisteredDefaultIcons[name] = true;
	});
}
function renderIcon(name, props) {
	if (isFunction(name)) return name(props);
	if (icons[name]) return icons[name](props);
	if (iconFactory) return iconFactory(name, props);
	return null;
}
function clearIcons() {
	icons = {};
}
function registerIconFactory(factory) {
	iconFactory = factory;
}
function restoreDefaultIcons() {
	icons = _objectSpread2({}, defaultIcons);
}

registerIcon(
	"calendar",
	function(props) {
		return /*#__PURE__*/ jsxs(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 32 32",
					children: [
						/*#__PURE__*/ jsx("path", {
							d: "M4 3h6m10 0h6",
							fill: "none",
							stroke: "currentColor",
							strokeWidth: "2"
						}),
						/*#__PURE__*/ jsx("path", {
							d: "M19 21h4v4h-4z",
							fill: "currentColor"
						}),
						/*#__PURE__*/ jsx("path", {
							d: "M3 25h24M3 21h24M3 17h24M7 28V13m-4 0h24M11 28V13.2M15 28V13.27M19 28V13.03M23 28V13.5",
							fill: "none",
							stroke: "currentColor"
						}),
						/*#__PURE__*/ jsx("path", {
							fill: "currentColor",
							d: "M10 8h10v2H10z"
						}),
						/*#__PURE__*/ jsx("path", {
							fill: "none",
							stroke: "currentColor",
							strokeWidth: "2",
							d: "M3 5h24v24H3z"
						})
					]
				}
			)
		);
	},
	true
);

var CheckIcon = registerIcon(
	"check",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 64 64",
					children: /*#__PURE__*/ jsx("path", {
						d: "M7.136 42.94l20.16 14.784 29.568-40.32-9.72-7.128-22.598 30.816-10.44-7.656z",
						fill: "currentColor"
					})
				}
			)
		);
	},
	true
);

var ClearIcon = registerIcon(
	"clear",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 32 32",
					children: /*#__PURE__*/ jsx("path", {
						fill: "currentColor",
						strokeWidth: "1",
						stroke: "currentColor",
						d:
							"M16.9 16l4.92-4.92c.24-.24.24-.6 0-.84s-.6-.24-.84 0l-4.92 4.92-5.04-4.98c-.24-.24-.6-.24-.84 0s-.24.6 0 .84L15.16 16l-4.98 4.98c-.24.24-.24.6 0 .84s.6.24.84 0L16 16.84l4.98 4.98c.24.24.6.24.84 0s.24-.6 0-.84L16.9 16z"
					})
				}
			)
		);
	},
	true
);

registerIcon(
	"close",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 32 32",
					children: /*#__PURE__*/ jsx("path", {
						fill: "currentColor",
						strokeWidth: "1",
						stroke: "currentColor",
						d:
							"M17.8 16l9.84-9.84c.48-.48.48-1.2 0-1.68s-1.2-.48-1.68 0l-9.84 9.84L6.04 4.36c-.48-.48-1.2-.48-1.68 0s-.48 1.2 0 1.68L14.32 16l-9.96 9.96c-.48.48-.48 1.2 0 1.68s1.2.48 1.68 0L16 17.68l9.96 9.96c.48.48 1.2.48 1.68 0s.48-1.2 0-1.68L17.8 16z"
					})
				}
			)
		);
	},
	true
);

var DropdownIcon = registerIcon(
	"drop-down",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 20 20",
					children: /*#__PURE__*/ jsx("path", {
						fill: "currentColor",
						strokeWidth: "0",
						stroke: "currentColor",
						d: "M4.516 8.147L10.01 12.5l5.474-4.33-.473-.65-5 3.98-5-4z"
					})
				}
			)
		);
	},
	true
);

registerIcon(
	"folder",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 16 16",
					children: /*#__PURE__*/ jsx("path", {
						d: "M1 5h13v9H1zm1 0h6L7 3H3z",
						fill: "currentColor",
						stroke: "none"
					})
				}
			)
		);
	},
	true
);

registerIcon(
	"folder-open",
	function(props) {
		return /*#__PURE__*/ jsxs(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 16 16",
					children: [
						/*#__PURE__*/ jsx("path", {
							d: "M0 5v7l2.5-6H13V5zm1 0h6L6 3H2z",
							fill: "currentColor",
							stroke: "none"
						}),
						/*#__PURE__*/ jsx("path", {
							d: "M3 7h13l-3 7H0z",
							fill: "currentColor",
							stroke: "none"
						})
					]
				}
			)
		);
	},
	true
);

registerIcon(
	"menu",
	function(props) {
		return /*#__PURE__*/ jsxs(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 24 24",
					children: [
						/*#__PURE__*/ jsx("path", {
							d: "M0 0h24v24H0z",
							fill: "none"
						}),
						/*#__PURE__*/ jsx("path", {
							d:
								"M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z",
							fill: "currentColor"
						})
					]
				}
			)
		);
	},
	true
);

registerIcon(
	"loading",
	function(props) {
		var style = {
			animation: "linear infinite 0.5s cx-rotate"
		};
		if (props && props.style) Object.assign(style, props.style);
		props = _objectSpread2(
			_objectSpread2({}, props),
			{},
			{
				style: style
			}
		);
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 50 50",
					children: /*#__PURE__*/ jsx("path", {
						fill: "currentColor",
						d:
							"M43.94 25.14c0-10.3-8.37-18.68-18.7-18.68-10.3 0-18.67 8.37-18.67 18.68h4.07c0-8.07 6.54-14.6 14.6-14.6 8.08 0 14.63 6.53 14.63 14.6h4.07z"
					})
				}
			)
		);
	},
	true
);

registerIcon(
	"search",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 32 32",
					children: /*#__PURE__*/ jsx("path", {
						fill: "currentColor",
						d:
							"M25.595 22.036l-5.26-5.075c.75-1.18 1.206-2.56 1.206-4.05 0-4.32-3.63-7.82-8.103-7.82-4.477 0-8.107 3.503-8.107 7.82 0 4.32 3.63 7.825 8.106 7.825 1.544 0 2.972-.44 4.198-1.162l5.26 5.074c.37.356.98.354 1.35 0l1.352-1.304c.37-.357.37-.947 0-1.304zm-12.16-3.91c-2.985 0-5.405-2.336-5.405-5.216 0-2.88 2.42-5.214 5.405-5.214 2.984 0 5.404 2.335 5.404 5.214 0 2.88-2.42 5.215-5.407 5.215z"
					})
				}
			)
		);
	},
	true
);

registerIcon(
	"cx",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "-347 249.7 48 48",
					children: /*#__PURE__*/ jsxs("g", {
						children: [
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-337.1 273.16l-4.23-7.33h8.46z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-318.32 273.16l-4.23-7.33h8.46z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-337.53 273.43h-8.45l4.22-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-309.38 273.43h-8.46l4.23-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-332.4 265.03l-4.22-7.33h8.46z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-304.24 265.03l-4.23-7.33h8.45z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-322.97 265.03l-4.28-7.33h8.5z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-332.87 265.3h-8.46l4.23-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-323.45 265.3h-8.46l4.2-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-314.1 265.3h-8.45l4.23-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-308.9 273.16l-4.23-7.33h8.46z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-304.67 265.3h-8.46l4.23-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-314.1 281.57h-8.45l4.23-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-313.6 281.3l-4.24-7.33h8.46z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-318.32 289.43l-4.23-7.33h8.46z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-304.67 281.57h-8.46l4.23-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-308.9 289.43l-4.23-7.33h8.46z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-341.76 281.3l-4.22-7.33h8.45z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-332.87 281.57h-8.46l4.23-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-337.1 289.43l-4.23-7.33h8.46z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-327.68 289.43l-4.23-7.33h8.43z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								opacity: "0.7",
								d: "M-328.16 289.7h-8.46l4.23-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-318.75 289.7h-8.5l4.28-7.33z"
							}),
							/*#__PURE__*/ jsx("path", {
								fill: "currentColor",
								d: "M-300.02 289.7h-8.45l4.23-7.33z"
							})
						]
					})
				}
			)
		);
	},
	true
);

registerIcon(
	"file",
	function(props) {
		return /*#__PURE__*/ jsxs(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 16 16",
					children: [
						/*#__PURE__*/ jsx("path", {
							d: "M2 2h5v5h5v7H2z",
							fill: "currentColor",
							stroke: "none"
						}),
						/*#__PURE__*/ jsx("path", {
							d: "M8 2v4h4z",
							fill: "currentColor",
							stroke: "none"
						})
					]
				}
			)
		);
	},
	true
);

var Icon = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(Icon, _Widget);

	function Icon() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = Icon.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					name: undefined
				}
			])
		);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return renderIcon(data.name, {
			key: key,
			className: data.classNames,
			style: data.style
		});
	};

	Icon.register = function register(name, icon, defaultIcon) {
		if (defaultIcon === void 0) {
			defaultIcon = false;
		}

		return registerIcon(name, icon, defaultIcon);
	};

	Icon.unregister = function unregister() {
		return unregisterIcon.apply(void 0, arguments);
	};

	Icon.render = function render(name, props) {
		return renderIcon(name, props);
	};

	Icon.clear = function clear() {
		return clearIcons();
	};

	Icon.registerFactory = function registerFactory(factory) {
		return registerIconFactory(factory);
	};

	Icon.restoreDefaultIcons = function restoreDefaultIcons$1() {
		restoreDefaultIcons();
	};

	return Icon;
})(Widget);
Icon.prototype.baseClass = "icon";
Icon.prototype.styled = true;
Widget.alias("icon", Icon);

var Button = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(Button, _HtmlElement);

	function Button() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = Button.prototype;

	_proto.declareData = function declareData() {
		var _HtmlElement$prototyp;

		(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
			_HtmlElement$prototyp,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					confirm: {
						structured: true
					},
					pressed: undefined,
					icon: undefined,
					disabled: undefined,
					enabled: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				pressed: data.pressed
			}
		);
		if (isDefined(data.enabled)) data.disabled = !data.enabled;

		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		instance.data.parentDisabled = context.parentDisabled;
		instance.data.parentStrict = context.parentStrict;
		if (instance.cache("parentDisabled", context.parentDisabled)) instance.markShouldUpdate(context);
		if (instance.cache("parentStrict", context.parentStrict)) instance.markShouldUpdate(context);

		_HtmlElement.prototype.explore.call(this, context, instance);
	};

	_proto.attachProps = function attachProps(context, instance, props) {
		var _this = this;

		_HtmlElement.prototype.attachProps.call(this, context, instance, props);

		if (!this.focusOnMouseDown) {
			props.onMouseDown = function(e) {
				if (_this.onMouseDown && instance.invoke("onMouseDown", e, instance) == false) return;
				preventFocus(e);
			};
		}

		if (this.dismiss) {
			var onClick = props.onClick;

			props.onClick = function() {
				if (onClick && onClick.apply(void 0, arguments) === false) return;
				if (instance.parentOptions && isFunction(instance.parentOptions.dismiss)) instance.parentOptions.dismiss();
			};
		}

		if (this.tag === "button") props.type = this.submit ? "submit" : "button";
		delete props.confirm;
		delete props.dismiss;
		delete props.pressed;
		delete props.submit;
		delete props.focusOnMouseDown;
		delete props.icon;
		delete props.enabled;
		var oldOnClick,
			data = instance.data;
		props.disabled = coalesce(data.parentStrict ? data.parentDisabled : null, data.disabled, data.parentDisabled);

		if (data.confirm) {
			oldOnClick = props.onClick;

			props.onClick = function() {
				yesNo(data.confirm).then(function(btn) {
					if (btn == "yes") oldOnClick.call(_this, null, instance);
				});
			};
		}

		var icon, children;

		if (data.icon) {
			icon = Icon.render(data.icon, {
				key: "icon",
				className: this.CSS.element(this.baseClass, "icon")
			});
			children = getContentArray(props.children);
			props.children = [icon].concat(children);
			props.className = this.CSS.expand(
				props.className,
				this.CSS.state("icon"),
				children.length == 0 && this.CSS.state("empty")
			);

			if (children.length == 0) {
				props.children.push(
					/*#__PURE__*/ jsx(
						"span",
						{
							className: this.CSS.element(this.baseClass, "baseline"),
							children: "\xA0"
						},
						"baseline"
					)
				);
			}
		}
	};

	return Button;
})(HtmlElement);
Button.prototype.tag = "button";
Button.prototype.baseClass = "button";
Button.prototype.icon = false;
Button.prototype.focusOnMouseDown = false;
Button.prototype.submit = false;
Widget.alias("button", Button);

var DocumentTitle = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(DocumentTitle, _Widget);

	function DocumentTitle() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = DocumentTitle.prototype;

	_proto.init = function init() {
		if (this.value) this.text = this.value;
		if (this.append) this.action = "append";

		_Widget.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					value: undefined,
					text: undefined,
					action: undefined,
					separator: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		if (!context.documentTitle) {
			context.documentTitle = {
				activeInstance: instance,
				title: ""
			};
		}

		var data = instance.data;

		if (data.text) {
			switch (data.action) {
				case "append":
					if (context.documentTitle.title) context.documentTitle.title += data.separator;
					context.documentTitle.title += data.text;
					break;

				case "prepend":
					context.documentTitle.title = data.text + data.separator + context.documentTitle.title;
					break;

				default:
				case "replace":
					context.documentTitle.title = data.text;
					break;
			}
		}

		_Widget.prototype.explore.call(this, context, instance);
	};

	_proto.prepare = function prepare(context, instance) {
		if (context.documentTitle.activeInstance == instance) document.title = context.documentTitle.title;
	};

	_proto.render = function render() {
		return null;
	};

	return DocumentTitle;
})(Widget);
DocumentTitle.prototype.action = "append";
DocumentTitle.prototype.separator = "";
Widget.alias("document-title", DocumentTitle);

var List = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(List, _Widget);

	function List() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = List.prototype;

	_proto.init = function init() {
		if (this.recordAlias) this.recordName = this.recordAlias;
		if (this.indexAlias) this.indexName = this.indexAlias;
		this.adapter = GroupAdapter.create(this.adapter || GroupAdapter, {
			recordName: this.recordName,
			indexName: this.indexName,
			recordsAccessor: getAccessor(this.records),
			keyField: this.keyField,
			sortOptions: this.sortOptions
		});
		this.child = ListItem.create(
			_objectSpread2(
				{
					layout: this.layout,
					items: this.items,
					children: this.children,
					styled: true,
					class: this.itemClass,
					className: this.itemClassName,
					style: this.itemStyle,
					disabled: this.itemDisabled
				},
				this.item
			)
		);
		delete this.children;
		this.selection = Selection.create(this.selection, {
			records: this.records
		});

		_Widget.prototype.init.call(this);

		if (this.grouping) {
			this.groupBy(this.grouping);
		}
	};

	_proto.initInstance = function initInstance(context, instance) {
		this.adapter.initInstance(context, instance);
	};

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		var selection = this.selection.configureWidget(this);

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[
				this,
				selection,
				{
					records: undefined,
					sorters: undefined,
					sortField: undefined,
					sortDirection: undefined,
					filterParams: {
						structured: true
					},
					itemStyle: {
						structured: true
					},
					emptyText: undefined,
					tabIndex: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var _this = this;

		var data = instance.data;
		if (data.sortField)
			data.sorters = [
				{
					field: data.sortField,
					direction: data.sortDirection || "ASC"
				}
			];
		this.adapter.sort(data.sorters);
		var filter = null;
		if (this.onCreateFilter) filter = instance.invoke("onCreateFilter", data.filterParams, instance);
		else if (this.filter)
			filter = function filter(item) {
				return _this.filter(item, data.filterParams);
			};
		this.adapter.setFilter(filter);
		instance.mappedRecords = this.adapter.getRecords(context, instance, data.records, instance.store);
		data.stateMods = Object.assign(data.stateMods || {}, {
			selectable: !this.selection.isDummy || this.onItemClick,
			empty: instance.mappedRecords.length == 0
		});

		_Widget.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance, data) {
		var _this2 = this;

		var instances = [];
		var isSelected = this.selection.getIsSelectedDelegate(instance.store);
		instance.mappedRecords.forEach(function(record) {
			if (record.type == "data") {
				var itemInstance = instance.getChild(context, _this2.child, record.key, record.store);
				itemInstance.record = record;
				itemInstance.selected = isSelected(record.data, record.index);
				var changed = false;
				if (itemInstance.cache("recordData", record.data)) changed = true;
				if (itemInstance.cache("selected", itemInstance.selected)) changed = true;

				if (_this2.cached && !changed && itemInstance.visible && !itemInstance.childStateDirty) {
					instances.push(itemInstance);
					itemInstance.shouldUpdate = false;
				} else if (itemInstance.scheduleExploreIfVisible(context)) instances.push(itemInstance);
			} else if (record.type == "group-header" && record.grouping.header) {
				var _itemInstance = instance.getChild(context, record.grouping.header, record.key, record.store);

				_itemInstance.record = record;
				if (_itemInstance.scheduleExploreIfVisible(context)) instances.push(_itemInstance);
			} else if (record.type == "group-footer" && record.grouping.footer) {
				var _itemInstance2 = instance.getChild(context, record.grouping.footer, record.key, record.store);

				_itemInstance2.record = record;
				if (_itemInstance2.scheduleExploreIfVisible(context)) instances.push(_itemInstance2);
			}
		});
		instance.instances = instances;
	};

	_proto.render = function render(context, instance, key) {
		var items = instance.instances.map(function(x, i) {
			return {
				instance: x,
				key: x.record.key,
				type: x.record.type,
				content: getContent(x.render(context))
			};
		});
		return /*#__PURE__*/ jsx(
			ListComponent,
			{
				instance: instance,
				items: items,
				selectable: !this.selection.isDummy || this.onItemClick
			},
			key
		);
	};

	_proto.groupBy = function groupBy(grouping) {
		var _this3 = this;

		if (grouping) {
			if (!isArray(grouping)) {
				if (isString(grouping) || typeof grouping == "object") return this.groupBy([grouping]);
				throw new Error("DynamicGrouping should be an array of grouping objects");
			}

			grouping = grouping.map(function(g, i) {
				if (isString(g)) {
					var _key;

					return {
						key:
							((_key = {}),
							(_key[g] = {
								bind: _this3.recordName + "." + g
							}),
							_key)
					};
				}

				return g;
			});
		}

		grouping.forEach(function(g) {
			if (g.header) g.header = Widget.create(g.header);
			if (g.footer) g.footer = Widget.create(g.footer);
		});
		this.adapter.groupBy(grouping);
		this.update();
	};

	return List;
})(Widget);
List.prototype.recordName = "$record";
List.prototype.indexName = "$index";
List.prototype.baseClass = "list";
List.prototype.focusable = true;
List.prototype.focused = false;
List.prototype.itemPad = true;
List.prototype.cached = false;
List.prototype.styled = true;
List.prototype.scrollSelectionIntoView = false;
List.prototype.selectMode = false;
List.prototype.selectOnTab = false;
Widget.alias("list", List);

var ListComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(ListComponent, _VDOM$Component);

	function ListComponent(props) {
		var _this4;

		_this4 = _VDOM$Component.call(this, props) || this;
		var widget = props.instance.widget;
		var focused = widget.focused;
		_this4.state = {
			cursor: focused && props.selectable ? 0 : -1,
			focused: focused
		};
		_this4.handleItemMouseDown = _this4.handleItemMouseDown.bind(_assertThisInitialized(_this4));
		_this4.handleItemDoubleClick = _this4.handleItemDoubleClick.bind(_assertThisInitialized(_this4));
		_this4.handleItemClick = _this4.handleItemClick.bind(_assertThisInitialized(_this4));
		return _this4;
	}

	var _proto2 = ListComponent.prototype;

	_proto2.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
		return props.instance.shouldUpdate || state != this.state;
	};

	_proto2.componentDidMount = function componentDidMount() {
		var instance = this.props.instance;
		var widget = instance.widget;

		if (widget.pipeKeyDown) {
			instance.invoke("pipeKeyDown", this.handleKeyDown.bind(this), instance);
			this.showCursor();
		}

		if (widget.autoFocus) FocusManager.focus(this.el);

		if (widget.onScroll) {
			this.unsubscribeScroll = addEventListenerWithOptions(
				this.el,
				"scroll",
				function(event) {
					instance.invoke("onScroll", event, instance);
				},
				{
					passive: true
				}
			);
		}

		this.componentDidUpdate();
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		if (this.state.focused && props.instance.widget.selectMode) this.showCursor(true, props.items);
		else if (this.state.cursor >= props.items.length) this.moveCursor(props.items.length - 1);
		else if (this.state.focused && this.state.cursor < 0) this.moveCursor(0);
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		var instance = this.props.instance;
		var widget = instance.widget;
		offFocusOut(this);
		if (widget.pipeKeyDown) instance.invoke("pipeKeyDown", null, instance);
	};

	_proto2.handleItemMouseDown = function handleItemMouseDown(e) {
		var index = Number(e.currentTarget.dataset.recordIndex);
		this.moveCursor(index);
		if (e.shiftKey) e.preventDefault();
		this.moveCursor(index, {
			select: true,
			selectOptions: {
				toggle: e.ctrlKey && !e.shiftKey,
				add: e.ctrlKey && e.shiftKey
			},
			selectRange: e.shiftKey
		});
	};

	_proto2.handleItemClick = function handleItemClick(e) {
		var _this$props = this.props,
			instance = _this$props.instance,
			items = _this$props.items;
		var index = Number(e.currentTarget.dataset.recordIndex);
		var item = items[this.cursorChildIndex[index]];
		if (instance.invoke("onItemClick", e, item.instance) === false) return;
		this.moveCursor(index, {
			select: true,
			selectOptions: {
				toggle: e.ctrlKey && !e.shiftKey,
				add: e.ctrlKey && e.shiftKey
			},
			selectRange: e.shiftKey
		});
	};

	_proto2.handleItemDoubleClick = function handleItemDoubleClick(e) {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			items = _this$props2.items;
		var index = Number(e.currentTarget.dataset.recordIndex);
		var item = items[this.cursorChildIndex[index]];
		instance.invoke("onItemDoubleClick", e, item.instance);
	};

	_proto2.render = function render() {
		var _this5 = this;

		var _this$props3 = this.props,
			instance = _this$props3.instance,
			items = _this$props3.items,
			selectable = _this$props3.selectable;
		var data = instance.data,
			widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var itemStyle = CSS.parseStyle(data.itemStyle);
		this.cursorChildIndex = [];
		var cursorIndex = 0;
		var onDblClick, onClick;
		if (widget.onItemClick) onClick = this.handleItemClick;
		if (widget.onItemDoubleClick) onDblClick = this.handleItemDoubleClick;
		var children =
			items.length > 0 &&
			items.map(function(x, i) {
				var _x$instance = x.instance,
					data = _x$instance.data,
					selected = _x$instance.selected;
				var className;

				if (x.type == "data") {
					var ind = cursorIndex++;

					_this5.cursorChildIndex.push(i);

					className = CSS.element(baseClass, "item", {
						selected: selected,
						cursor: ind == _this5.state.cursor,
						pad: widget.itemPad,
						disabled: data.disabled
					});
					return /*#__PURE__*/ jsx(
						"li",
						{
							className: CSS.expand(className, data.classNames),
							style: itemStyle,
							"data-record-index": ind,
							onMouseDown: _this5.handleItemMouseDown,
							onClick: onClick,
							onDoubleClick: onDblClick,
							children: x.content
						},
						x.key
					);
				} else {
					return /*#__PURE__*/ jsx(
						"li",
						{
							className: CSS.element(baseClass, x.type),
							children: x.content
						},
						x.key
					);
				}
			});

		if (!children && data.emptyText) {
			children = /*#__PURE__*/ jsx("li", {
				className: CSS.element(baseClass, "empty-text"),
				children: data.emptyText
			});
		}

		return /*#__PURE__*/ jsx("ul", {
			ref: function ref(el) {
				_this5.el = el;
			},
			className: CSS.expand(
				data.classNames,
				CSS.state({
					focused: this.state.focused
				})
			),
			style: data.style,
			tabIndex: widget.focusable && selectable && items.length > 0 ? data.tabIndex || 0 : null,
			onMouseDown: preventFocusOnTouch,
			onKeyDown: this.handleKeyDown.bind(this),
			onMouseLeave: this.handleMouseLeave.bind(this),
			onFocus: this.onFocus.bind(this),
			onBlur: this.onBlur.bind(this),
			children: children
		});
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		var _this6 = this;

		var widget = this.props.instance.widget;

		if (widget.scrollSelectionIntoView) {
			//The timeout is reqired for use-cases when parent needs to do some measuring that affect scrollbars, i.e. LookupField.
			setTimeout(function() {
				return _this6.scrollElementIntoView();
			}, 0);
		}
	};

	_proto2.scrollElementIntoView = function scrollElementIntoView$1() {
		if (!this.el) return; //unmount

		var widget = this.props.instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var selectedRowSelector = "." + CSS.element(baseClass, "item") + "." + CSS.state("selected");
		var firstSelectedRow = this.el.querySelector(selectedRowSelector);

		if (firstSelectedRow != this.selectedEl) {
			if (firstSelectedRow) scrollElementIntoView(firstSelectedRow);
			this.selectedEl = firstSelectedRow;
		}
	};

	_proto2.moveCursor = function moveCursor(index, _temp) {
		var _this7 = this;

		var _ref = _temp === void 0 ? {} : _temp,
			focused = _ref.focused,
			hover = _ref.hover,
			scrollIntoView = _ref.scrollIntoView,
			select = _ref.select,
			selectRange = _ref.selectRange,
			selectOptions = _ref.selectOptions;

		var _this$props4 = this.props,
			instance = _this$props4.instance,
			selectable = _this$props4.selectable;
		if (!selectable) return;
		var widget = instance.widget;
		var newState = {};
		if (widget.focused) focused = true;
		if (focused != null && this.state.focused != focused) newState.focused = focused; //ignore mouse enter/leave events (support with a flag if a feature request comes)

		if (!hover) newState.cursor = index; //batch updates to avoid flickering between selection and cursor changes

		batchUpdates(function() {
			if (select || widget.selectMode) {
				var start = selectRange && _this7.state.selectionStart >= 0 ? _this7.state.selectionStart : index;
				if (start < 0) start = index;

				_this7.selectRange(start, index, selectOptions);

				if (!selectRange) newState.selectionStart = index;
			}

			if (Object.keys(newState).length > 0) {
				_this7.setState(newState, function() {
					if (scrollIntoView) {
						var item = _this7.el.children[_this7.cursorChildIndex[index]];
						if (item) scrollElementIntoView(item);
					}
				});
			}
		});
	};

	_proto2.selectRange = function selectRange(from, to, options) {
		var _this$props5 = this.props,
			instance = _this$props5.instance,
			items = _this$props5.items;
		var widget = instance.widget;

		if (from > to) {
			var tmp = from;
			from = to;
			to = tmp;
		}

		var selection = [],
			indexes = [];

		for (var cursor = from; cursor <= to; cursor++) {
			var item = items[this.cursorChildIndex[cursor]];

			if (item) {
				var _item$instance = item.instance,
					record = _item$instance.record,
					data = _item$instance.data;
				if (data.disabled) continue;
				selection.push(record.data);
				indexes.push(record.index);
			}
		}

		widget.selection.selectMultiple(instance.store, selection, indexes, options);
	};

	_proto2.showCursor = function showCursor(force, newItems) {
		if (!force && this.state.cursor >= 0) return;
		var items = newItems || this.props.items;
		var index = -1,
			firstSelected = -1,
			firstValid = -1;

		for (var i = 0; i < items.length; i++) {
			var item = items[i];

			if (isItemSelectable(item)) {
				index++;
				if (firstValid == -1) firstValid = index;

				if (item.instance.selected) {
					firstSelected = index;
					break;
				}
			}
		}

		this.moveCursor(firstSelected != -1 ? firstSelected : firstValid, {
			focusedport: true
		});
	};

	_proto2.onFocus = function onFocus() {
		var _this8 = this;

		var widget = this.props.instance.widget;
		FocusManager.nudge();
		this.showCursor(widget.selectMode);
		if (!widget.focused)
			oneFocusOut(this, this.el, function() {
				_this8.moveCursor(-1, {
					focused: false
				});
			});
		this.setState({
			focused: true
		});
	};

	_proto2.onBlur = function onBlur() {
		FocusManager.nudge();
	};

	_proto2.handleMouseLeave = function handleMouseLeave() {
		var widget = this.props.instance.widget;
		if (!widget.focused)
			this.moveCursor(-1, {
				hover: true
			});
	};

	_proto2.handleKeyDown = function handleKeyDown(e) {
		var _this$props6 = this.props,
			instance = _this$props6.instance,
			items = _this$props6.items;
		var widget = instance.widget;
		if (this.onKeyDown && instance.invoke("onKeyDown", e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.tab:
			case KeyCode.enter:
				if (!widget.selectOnTab && e.keyCode == KeyCode.tab) break;
				var item = items[this.cursorChildIndex[this.state.cursor]];
				if (item && widget.onItemClick && instance.invoke("onItemClick", e, item.instance) === false) return;
				this.moveCursor(this.state.cursor, {
					select: true,
					selectOptions: {
						toggle: e.ctrlKey && !e.shiftKey,
						add: e.ctrlKey && e.shiftKey
					},
					selectRange: e.shiftKey
				});
				break;

			case KeyCode.down:
				for (var index = this.state.cursor + 1; index < this.cursorChildIndex.length; index++) {
					var _item = items[this.cursorChildIndex[index]];
					if (!isItemSelectable(_item)) continue;
					this.moveCursor(index, {
						focused: true,
						scrollIntoView: true,
						select: e.shiftKey,
						selectRange: e.shiftKey
					});
					e.stopPropagation();
					e.preventDefault();
					break;
				}

				break;

			case KeyCode.up:
				for (var _index = this.state.cursor - 1; _index >= 0; _index--) {
					var _item2 = items[this.cursorChildIndex[_index]];
					if (!isItemSelectable(_item2)) continue;
					this.moveCursor(_index, {
						focused: true,
						scrollIntoView: true,
						select: e.shiftKey,
						selectRange: e.shiftKey
					});
					e.stopPropagation();
					e.preventDefault();
					break;
				}

				break;

			case KeyCode.a:
				if (!e.ctrlKey || !widget.selection.multiple) return;
				this.selectRange(0, this.cursorChildIndex.length);
				e.stopPropagation();
				e.preventDefault();
				break;
		}
	};

	return ListComponent;
})(VDOM.Component);

var ListItem = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(ListItem, _Container);

	function ListItem() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto3 = ListItem.prototype;

	_proto3.declareData = function declareData() {
		var _Container$prototype$;

		for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
			args[_key2] = arguments[_key2];
		}

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(args, [
				{
					disabled: undefined
				}
			])
		);
	};

	return ListItem;
})(Container);

function isItemSelectable(item) {
	return item && item.type == "data" && !item.instance.data.disabled;
}

var Sandbox = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(Sandbox, _PureContainer);

	function Sandbox() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = Sandbox.prototype;

	_proto.init = function init() {
		if (this.recordAlias) this.recordName = this.recordAlias;
		if (this.accessKey) this.key = this.accessKey;
		this.storageBinding = Binding.get(this.storage.bind);

		_PureContainer.prototype.init.call(this);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.store = new ExposedValueView({
			store: instance.store,
			containerBinding: this.storageBinding,
			key: null,
			recordName: this.recordName,
			immutable: this.immutable
		});

		instance.setStore = function(store) {
			instance.store.setStore(store);
		};
	};

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[
				this,
				{
					storage: undefined,
					key: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var store = instance.store,
			data = instance.data;

		if (store.getKey() !== data.key) {
			instance.store = new ExposedValueView({
				store: store,
				containerBinding: this.storageBinding,
				key: data.key,
				recordName: this.recordName,
				immutable: this.immutable
			}); //when navigating to a page using the same widget tree as the previous page
			//everything needs to be reinstantiated, e.g. user/1 => user/2

			instance.clearChildrenCache();
		}

		_PureContainer.prototype.prepareData.call(this, context, instance);
	};

	return Sandbox;
})(PureContainer);
Sandbox.prototype.recordName = "$page";
Sandbox.prototype.immutable = false;
Widget.alias("sandbox", Sandbox);

var CxCredit = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(CxCredit, _HtmlElement);

	function CxCredit() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = CxCredit.prototype;

	_proto.init = function init() {
		this.tooltip = {
			mouseTrap: true,
			title: "Credits",
			items: {
				$type: HtmlElement,
				tag: "div",
				ws: true,
				jsxAttributes: ["ws"],
				children: [
					"\n               User interface of this project is implemented using the CxJS framework.\n               For more information about CxJS, please visit\n               ",
					{
						$type: HtmlElement,
						tag: "a",
						href: "https://cxjs.io/",
						target: "_blank",
						jsxAttributes: ["href", "target"],
						children: ["the CxJS homepage"]
					},
					".\n            "
				]
			}
		};

		_HtmlElement.prototype.init.call(this);
	};

	_proto.attachProps = function attachProps(context, instance, props) {
		props.children = Icon.render("cx", {
			className: this.CSS.element(this.baseClass, "icon")
		});
	};

	return CxCredit;
})(HtmlElement);
CxCredit.prototype.baseClass = "cxcredit";
CxCredit.prototype.tag = "div";
Widget.alias("cx-credit", CxCredit);

var Heading = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(Heading, _HtmlElement);

	function Heading() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = Heading.prototype;

	_proto.init = function init() {
		this.tag = "h" + this.level;

		_HtmlElement.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var _objectSpread2$1;

		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			((_objectSpread2$1 = {}), (_objectSpread2$1["level-" + this.level] = true), _objectSpread2$1)
		);

		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
		switch (attrName) {
			case "level":
				return false;

			default:
				return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
		}
	};

	return Heading;
})(HtmlElement);
Heading.prototype.level = 3;
Heading.prototype.baseClass = "heading";

var Section = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(Section, _Container);

	function Section() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = Section.prototype;

	_proto.init = function init() {
		if (isString(this.headerStyle)) this.headerStyle = parseStyle(this.headerStyle);
		if (isString(this.footerStyle)) this.footerStyle = parseStyle(this.footerStyle);
		if (isString(this.bodyStyle)) this.bodyStyle = parseStyle(this.bodyStyle);

		_Container.prototype.init.call(this);
	};

	_proto.add = function add(item) {
		if (item && item.putInto == "header")
			this.header = _objectSpread2(
				_objectSpread2({}, item),
				{},
				{
					putInto: null
				}
			);
		else if (item && item.putInto == "footer")
			this.footer = _objectSpread2(
				_objectSpread2({}, item),
				{},
				{
					putInto: null
				}
			);
		else _Container.prototype.add.apply(this, arguments);
	};

	_proto.declareData = function declareData() {
		return _Container.prototype.declareData.call(this, {
			id: undefined,
			headerStyle: {
				structured: true
			},
			headerClass: {
				structured: true
			},
			bodyStyle: {
				structured: true
			},
			bodyClass: {
				structured: true
			},
			footerStyle: {
				structured: true
			},
			footerClass: {
				structured: true
			}
		});
	};

	_proto.initComponents = function initComponents() {
		_Container.prototype.initComponents.call(this, {
			header: this.getHeader(),
			footer: this.getFooter()
		});
	};

	_proto.getHeader = function getHeader() {
		if (this.title)
			return Widget.create(Heading, {
				text: this.title,
				level: this.hLevel
			});
		if (this.header) return Heading.create(this.header);
		return null;
	};

	_proto.getFooter = function getFooter() {
		if (this.footer) return Widget.create(this.footer);
		return null;
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				pad: this.pad
			}
		);

		_Container.prototype.prepareData.call(this, context, instance);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.eventHandlers = instance.getJsxEventProps();

		_Container.prototype.initInstance.call(this, context, instance);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			components = instance.components,
			eventHandlers = instance.eventHandlers;
		var header, footer;
		var CSS = this.CSS,
			baseClass = this.baseClass;

		if (components.header) {
			header = /*#__PURE__*/ jsx("header", {
				className: CSS.expand(CSS.element(baseClass, "header"), data.headerClass),
				style: data.headerStyle,
				children: getContent(components.header.render(context))
			});
		}

		if (components.footer) {
			footer = /*#__PURE__*/ jsx("footer", {
				className: CSS.expand(CSS.element(baseClass, "footer"), data.footerClass),
				style: data.footerStyle,
				children: getContent(components.footer.render(context))
			});
		}

		return /*#__PURE__*/ jsxs(
			"section",
			_objectSpread2(
				_objectSpread2(
					{
						className: data.classNames,
						style: data.style,
						id: data.id
					},
					eventHandlers
				),
				{},
				{
					children: [
						header,
						/*#__PURE__*/ jsx("div", {
							className: CSS.expand(CSS.element(this.baseClass, "body"), data.bodyClass),
							style: data.bodyStyle,
							children: this.renderChildren(context, instance)
						}),
						footer
					]
				}
			),
			key
		);
	};

	return Section;
})(Container);
Section.prototype.styled = true;
Section.prototype.pad = true;
Section.prototype.baseClass = "section";
Section.prototype.hLevel = 3;

var FlexBox = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(FlexBox, _Container);

	function FlexBox() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = FlexBox.prototype;

	_proto.init = function init() {
		if (this.padding) this.pad = this.padding;
		if (this.hpadding) this.hpad = this.hpadding;
		if (this.vpadding) this.vpad = this.vpadding;
		this.hpad = isUndefined(this.hpad) ? this.pad : this.hpad;
		this.vpad = isUndefined(this.vpad) ? this.pad : this.hpad;
		if (this.hpad === true) this.hpad = "medium";
		if (this.vpad === true) this.vpad = "medium";
		this.hspacing = isUndefined(this.hspacing) ? this.spacing : this.hspacing;
		this.vspacing = isUndefined(this.vspacing) ? this.spacing : this.vspacing;
		if (this.hspacing === true) this.hspacing = "medium";
		if (this.vspacing === true) this.vspacing = "medium";

		_Container.prototype.init.call(this);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.eventHandlers = instance.getJsxEventProps();

		_Container.prototype.initInstance.call(this, context, instance);
	};

	_proto.prepareCSS = function prepareCSS(context, instance) {
		var _objectSpread2$1;

		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			((_objectSpread2$1 = {}),
			(_objectSpread2$1[this.hpad + "-hpad"] = this.hpad),
			(_objectSpread2$1[this.vpad + "-vpad"] = this.vpad),
			(_objectSpread2$1.nested = this.nested),
			_objectSpread2$1)
		);

		_Container.prototype.prepareCSS.call(this, context, instance);
	};

	_proto.render = function render(context, instance, key) {
		var _flexboxMods;

		var data = instance.data,
			eventHandlers = instance.eventHandlers;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var flexboxMods =
			((_flexboxMods = {}),
			(_flexboxMods[this.hspacing + "-hspacing"] = this.hspacing),
			(_flexboxMods[this.vspacing + "-vspacing"] = this.vspacing),
			(_flexboxMods["align-" + this.align] = this.align),
			(_flexboxMods["justify-" + this.justify] = this.justify),
			(_flexboxMods.wrap = this.wrap),
			(_flexboxMods["target-" + this.target] = true),
			(_flexboxMods[this.direction] = true),
			_flexboxMods);
		return /*#__PURE__*/ jsx(
			"div",
			_objectSpread2(
				_objectSpread2(
					{
						className: data.classNames,
						style: data.style
					},
					eventHandlers
				),
				{},
				{
					children: /*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "flexbox", flexboxMods),
						children: this.renderChildren(context, instance)
					})
				}
			),
			key
		);
	};

	return FlexBox;
})(Container);
FlexBox.prototype.baseClass = "flexbox";
FlexBox.prototype.styled = true;
FlexBox.prototype.direction = "row";
FlexBox.prototype.spacing = false;
FlexBox.prototype.hspacing = undefined;
FlexBox.prototype.vspacing = undefined;
FlexBox.prototype.pad = false;
FlexBox.prototype.hpad = undefined;
FlexBox.prototype.vpad = undefined;
FlexBox.prototype.wrap = false;
FlexBox.prototype.align = false;
FlexBox.prototype.justify = false;
FlexBox.prototype.target = "any";
FlexBox.prototype.nested = false;
var FlexRow = /*#__PURE__*/ (function(_FlexBox) {
	_inheritsLoose(FlexRow, _FlexBox);

	function FlexRow() {
		return _FlexBox.apply(this, arguments) || this;
	}

	return FlexRow;
})(FlexBox);
var FlexCol = /*#__PURE__*/ (function(_FlexBox2) {
	_inheritsLoose(FlexCol, _FlexBox2);

	function FlexCol() {
		return _FlexBox2.apply(this, arguments) || this;
	}

	return FlexCol;
})(FlexBox);
FlexCol.prototype.direction = "column";

var ProgressBar = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(ProgressBar, _Widget);

	function ProgressBar() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = ProgressBar.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		return (_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[
				this,
				{
					disabled: undefined,
					text: undefined,
					value: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.render = function render(context, instance, key) {
		var widget = instance.widget,
			data = instance.data;
		var text = data.text,
			value = data.value,
			disabled = data.disabled;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		if (!isNumber(value)) value = 0;
		return /*#__PURE__*/ jsxs(
			"div",
			{
				className: CSS.expand(
					data.classNames,
					CSS.state({
						disabled: disabled
					})
				),
				style: data.style,
				children: [
					/*#__PURE__*/ jsx("div", {
						className: CSS.element(this.baseClass, "indicator"),
						style: {
							width: (value > 1 ? 1 : value < 0 ? 0 : value) * 100 + "%"
						}
					}),
					/*#__PURE__*/ jsx("div", {
						className: CSS.element(this.baseClass, "label"),
						children: text
					})
				]
			},
			key
		);
	};

	return ProgressBar;
})(Widget);
ProgressBar.prototype.styled = true;
ProgressBar.prototype.disabled = false;
ProgressBar.prototype.baseClass = "progressbar";

function captureMouse2(e, _ref) {
	var onMouseMove = _ref.onMouseMove,
		onMouseUp = _ref.onMouseUp,
		onDblClick = _ref.onDblClick,
		captureData = _ref.captureData,
		cursor = _ref.cursor;
	var surface = document.createElement("div");
	surface.className = "cxb-mousecapture";
	surface.style.cursor = cursor || getComputedStyle(e.currentTarget).cursor;
	document.body.appendChild(surface);
	var active = true;
	surface.addEventListener("mousemove", move);
	surface.addEventListener("mouseup", end);
	if (onDblClick) surface.addEventListener("dblclick", doubleClick);

	function tear() {
		if (surface == null) return;
		surface.removeEventListener("mousemove", move);
		surface.removeEventListener("mouseup", end);
		if (onDblClick) surface.removeEventListener("dblclick", onDblClick);
		document.body.removeChild(surface);
		surface = null;
	}

	function doubleClick(e) {
		try {
			onDblClick(e);
		} finally {
			tear();
		}
	}

	e.stopPropagation();

	function move(e) {
		if (!active) {
			tear();
			return;
		} //if mouse moves double clicking is off

		onDblClick = null;
		batchUpdates(function() {
			if (onMouseMove) onMouseMove(e, captureData);
			e.stopPropagation();
			e.preventDefault(); //disable text selection
		});
	}

	function end(e) {
		active = false;
		batchUpdates(function() {
			// if (surface.releaseCapture)
			//    surface.releaseCapture();
			if (!onDblClick) surface.style.display = "none";

			try {
				if (onMouseUp) onMouseUp(e, captureData);
			} finally {
				if (onDblClick) {
					//keep the surface a little longer to detect double clicks
					setTimeout(tear, 1500);
				} else tear();
			}
		});
	}
}
function captureMouseOrTouch2(e, _ref2) {
	var onMouseMove = _ref2.onMouseMove,
		onMouseUp = _ref2.onMouseUp,
		onDblClick = _ref2.onDblClick,
		captureData = _ref2.captureData,
		cursor = _ref2.cursor;

	if (e.type.indexOf("touch") == 0) {
		var el = e.currentTarget;

		var move = function move(e) {
			batchUpdates(function() {
				if (onMouseMove) onMouseMove(e, captureData);
				e.preventDefault();
			});
		};

		var end = function end(e) {
			batchUpdates(function() {
				el.removeEventListener("touchmove", move);
				el.removeEventListener("touchend", end);
				if (onMouseUp) onMouseUp(e);
				e.preventDefault();
			});
		};

		el.addEventListener("touchmove", move);
		el.addEventListener("touchend", end);
		e.stopPropagation();
	} else
		captureMouse2(e, {
			onMouseMove: onMouseMove,
			onMouseUp: onMouseUp,
			captureData: captureData,
			onDblClick: onDblClick,
			cursor: cursor
		});
}
function captureMouse(e, onMouseMove, onMouseUp, captureData, cursor) {
	captureMouse2(e, {
		onMouseMove: onMouseMove,
		onMouseUp: onMouseUp,
		captureData: captureData,
		cursor: cursor
	});
}
function captureMouseOrTouch(e, onMouseMove, onMouseUp, captureData, cursor) {
	captureMouseOrTouch2(e, {
		onMouseMove: onMouseMove,
		onMouseUp: onMouseUp,
		captureData: captureData,
		cursor: cursor
	});
}
function getCursorPos(e) {
	var p = (e.touches && e.touches[0]) || e;
	var offset = getParentFrameBoundingClientRect(e.target);
	return {
		clientX: p.clientX + offset.left,
		clientY: p.clientY + offset.top
	};
}

var Resizer = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(Resizer, _Widget);

	function Resizer() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = Resizer.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(args, [
				{
					size: undefined,
					defaultSize: undefined,
					minSize: undefined,
					maxSize: undefined
				}
			])
		);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			ResizerCmp,
			{
				instance: instance,
				data: data
			},
			key
		);
	};

	return Resizer;
})(Widget);
Resizer.prototype.baseClass = "resizer";
Resizer.prototype.styled = true;
Resizer.prototype.horizontal = false;
Resizer.prototype.forNextElement = false;
Resizer.prototype.defaultSize = null;
Resizer.prototype.minSize = 0;
Resizer.prototype.maxSize = 1e6;

var ResizerCmp = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(ResizerCmp, _VDOM$Component);

	function ResizerCmp(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			dragged: false,
			offset: 0
		};
		return _this;
	}

	var _proto2 = ResizerCmp.prototype;

	_proto2.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
		return state != this.state;
	};

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			data = _this$props.data;
		var widget = instance.widget;
		var baseClass = widget.baseClass,
			CSS = widget.CSS;
		return /*#__PURE__*/ jsx("div", {
			ref: function ref(el) {
				_this2.el = el;
			},
			className: CSS.expand(
				data.classNames,
				CSS.state({
					vertical: !widget.horizontal,
					horizontal: widget.horizontal
				})
			),
			style: data.style,
			onDoubleClick: function onDoubleClick(e) {
				instance.set("size", data.defaultSize);
			},
			onMouseDown: function onMouseDown(e) {
				var initialPosition = getCursorPos(e);

				_this2.setState({
					dragged: true,
					initialPosition: initialPosition
				});
			},
			onMouseUp: function onMouseUp(e) {
				_this2.setState({
					dragged: false
				});
			},
			onMouseMove: this.startCapture.bind(this),
			onMouseLeave: this.startCapture.bind(this),
			children: /*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "handle", {
					dragged: this.state.dragged
				}),
				style: {
					left: !widget.horizontal ? this.state.offset : 0,
					top: widget.horizontal ? this.state.offset : 0
				}
			})
		});
	};

	_proto2.startCapture = function startCapture(e) {
		var instance = this.props.instance;
		var widget = instance.widget;

		if (this.state.dragged && !this.hasCapture) {
			this.hasCapture = true;
			captureMouseOrTouch(
				e,
				this.onHandleMove.bind(this),
				this.onDragComplete.bind(this),
				this.state.initialPosition,
				widget.horizontal ? "row-resize" : "col-resize"
			);
		}
	};

	_proto2.onHandleMove = function onHandleMove(e, initialPosition) {
		var instance = this.props.instance;
		var widget = instance.widget;
		var currentPosition = getCursorPos(e);
		var offset = !widget.horizontal
			? currentPosition.clientX - initialPosition.clientX
			: currentPosition.clientY - initialPosition.clientY;
		var size = this.getNewSize(0);
		var newSize = this.getNewSize(offset);
		var allowedOffset = widget.forNextElement ? size - newSize : newSize - size;
		this.setState({
			offset: allowedOffset
		});
	};

	_proto2.getNewSize = function getNewSize(offset) {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data;
		var _instance$widget = instance.widget,
			horizontal = _instance$widget.horizontal,
			forNextElement = _instance$widget.forNextElement;
		if (
			!this.el ||
			(!forNextElement && !this.el.previousElementSibling) ||
			(forNextElement && !this.el.nextElementSibling)
		)
			return 0;
		var newSize;

		if (horizontal) {
			if (forNextElement) newSize = this.el.nextElementSibling.offsetHeight - offset;
			else newSize = this.el.previousElementSibling.offsetHeight + offset;
		} else {
			if (forNextElement) newSize = this.el.nextElementSibling.offsetWidth - offset;
			else newSize = this.el.previousElementSibling.offsetWidth + offset;
		}

		return Math.max(data.minSize, Math.min(newSize, data.maxSize));
	};

	_proto2.onDragComplete = function onDragComplete() {
		this.hasCapture = false;
		var instance = this.props.instance;
		instance.set("size", this.getNewSize(this.state.offset));
		this.setState({
			dragged: false,
			offset: 0
		});
	};

	return ResizerCmp;
})(VDOM.Component);

var HighlightedSearchText = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(HighlightedSearchText, _Widget);

	function HighlightedSearchText() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = HighlightedSearchText.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(args, [
				{
					text: undefined,
					chunks: undefined,
					query: undefined
				}
			])
		);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		var text = data.text,
			chunks = data.chunks,
			query = data.query,
			classNames = data.classNames,
			style = data.style;

		if (!chunks && text && query) {
			var highligher = getSearchQueryHighlighter(query, {
				cache: true
			});
			chunks = highligher(text);
		}

		if (!chunks) return text;
		return chunks.map(function(text, i) {
			if (i % 2 == 0) return text;
			return /*#__PURE__*/ jsx(
				"span",
				{
					className: classNames,
					style: style,
					children: text
				},
				key + "-" + i
			);
		});
	};

	return HighlightedSearchText;
})(Widget);
HighlightedSearchText.prototype.styled = true;
HighlightedSearchText.prototype.baseClass = "highlighedsearchtext";

var dropZones = new SubscriberList(),
	dragStartedZones,
	activeZone,
	nearZones,
	puppet,
	scrollTimer,
	vscrollParent,
	hscrollParent;
function registerDropZone(dropZone) {
	return dropZones.subscribe(dropZone);
}
function initiateDragDrop(e, options, onDragEnd) {
	if (options === void 0) {
		options = {};
	}

	if (puppet) {
		//last operation didn't finish properly
		notifyDragDrop(e);
	}

	var sourceEl = options.sourceEl || e.currentTarget;
	var sourceBounds = getTopLevelBoundingClientRect(sourceEl);
	var cursor = getCursorPos(e);

	var clone = _objectSpread2({}, options.clone);

	var cloneEl = document.createElement("div");
	cloneEl.classList.add("cxb-dragclone");
	if (isString(clone["class"])) cloneEl.classList.add(clone["class"]);
	if (isObject(clone.style)) Object.assign(cloneEl.style, clone.style);
	cloneEl.style.left = "-1000px";
	cloneEl.style.top = "-1000px";
	if (clone.matchSize || clone.matchWidth) cloneEl.style.width = Math.ceil(sourceBounds.width) + "px";
	if (clone.matchSize || clone.matchHeight) cloneEl.style.height = Math.ceil(sourceBounds.height) + "px";
	cloneEl.style.zIndex = ZIndexManager.next() + 1000;

	if (clone.cloneContent) {
		cloneEl.appendChild(sourceEl.cloneNode(true));
	}

	document.body.appendChild(cloneEl);
	var styles = getComputedStyle(sourceEl);
	var deltaX = clone.matchCursorOffset ? cursor.clientX - sourceBounds.left : -3;
	var deltaY = clone.matchCursorOffset ? cursor.clientY - sourceBounds.top : -3;

	var source = _objectSpread2(
		_objectSpread2({}, options.source),
		{},
		{
			width: sourceBounds.width,
			height: sourceBounds.height,
			deltaX: deltaX,
			deltaY: deltaY,
			margin: [
				styles.getPropertyValue("margin-top"),
				styles.getPropertyValue("margin-right"),
				styles.getPropertyValue("margin-bottom"),
				styles.getPropertyValue("margin-left")
			]
		}
	);

	puppet = {
		deltaX: deltaX,
		deltaY: deltaY,
		el: cloneEl,
		clone: clone,
		source: source,
		onDragEnd: onDragEnd
	};

	if (clone.widget && clone.store && !clone.cloneContent) {
		var content = {
			$type: ContextWrap,
			value: {
				disabled: true
			},
			jsxAttributes: ["value"],
			children: [clone.widget]
		};
		puppet.stop = startAppLoop(cloneEl, clone.store, content, {
			removeParentDOMElement: true
		});
	} else {
		puppet.stop = function() {
			document.body.removeChild(cloneEl);
		};
	}

	var event = getDragEvent(e, "dragstart");
	dragStartedZones = new WeakMap();
	dropZones.execute(function(zone) {
		if (zone.onDropTest)
			try {
				if (!zone.onDropTest(event)) return;
			} catch (err) {
				Console.warn("Drop zone onDropTest failed. Error: ", err, zone);
				return;
			}
		if (zone.onDragStart) zone.onDragStart(event);
		dragStartedZones.set(zone, true);
	});
	notifyDragMove(e);
	captureMouseOrTouch(e, notifyDragMove, notifyDragDrop);
}

function notifyDragMove(e, captureData) {
	var event = getDragEvent(e, "dragmove");
	var over = null,
		overTest = null,
		best = null;
	var near = [],
		away = [];
	dropZones.execute(function(zone) {
		var test;

		try {
			test = zone.onDropTest && zone.onDropTest(event);
			if (!test) return;
		} catch (err) {
			//the problem is already reported, so here we just swallow the bug to avoid spammming the console too much
			return;
		}

		if (zone.onDragMeasure) {
			var result =
				zone.onDragMeasure(event, {
					test: test
				}) || {};
			if (result.near) near.push(zone);
			else away.push(zone);

			if (isNumber(result.over) && (best == null || result.over < best)) {
				over = zone;
				overTest = test;
				best = result.over;
			}
		}
	});
	var newNear = new WeakMap();

	if (nearZones != null) {
		away.forEach(function(z) {
			if (z.onDragAway && nearZones.has(z)) z.onDragAway(z);
		});
	}

	near.forEach(function(z) {
		if (z.onDragNear && z != over && (nearZones == null || !nearZones.has(z))) {
			z.onDragNear(z);
			newNear.set(z, true);
		}
	});
	nearZones = newNear;

	if (over != activeZone) {
		vscrollParent = null;
		hscrollParent = null;
	}

	if (over != activeZone && activeZone && activeZone.onDragLeave) activeZone.onDragLeave(event);

	if (over != activeZone && over) {
		if (over.onDragEnter) over.onDragEnter(event);
		vscrollParent =
			over.onGetVScrollParent &&
			over.onGetVScrollParent({
				test: overTest
			});
		hscrollParent =
			over.onGetHScrollParent &&
			over.onGetHScrollParent({
				test: overTest
			});
	}

	activeZone = over;

	if (over && over.onDragOver) {
		over.onDragOver(event, {
			test: overTest
		});
	} //do it last to avoid forced redraw if nothing changed

	var cursor = getCursorPos(e);
	puppet.el.style.left = cursor.clientX - puppet.deltaX + "px";
	puppet.el.style.top = cursor.clientY - puppet.deltaY + "px";

	if (vscrollParent || hscrollParent) {
		var scrollX = 0,
			scrollY = 0;
		var vscrollBounds = vscrollParent && getScrollerBoundingClientRect(vscrollParent, true);
		var hscrollBounds =
			hscrollParent == vscrollParent
				? vscrollBounds
				: hscrollParent && getScrollerBoundingClientRect(hscrollParent, true);

		if (vscrollBounds) {
			if (cursor.clientY < vscrollBounds.top + 20) scrollY = -1;
			else if (cursor.clientY >= vscrollBounds.bottom - 20) scrollY = 1;
		}

		if (hscrollBounds) {
			if (cursor.clientX < hscrollBounds.left + 20) scrollX = -1;
			else if (cursor.clientX >= hscrollBounds.right - 20) scrollX = 1;
		}

		if (scrollY || scrollX) {
			if (!scrollTimer) {
				var cb = function cb() {
					if (scrollY) {
						var current = vscrollParent.scrollTop;
						var next = Math.min(
							vscrollParent.scrollHeight,
							Math.max(0, current + (scrollY * 5 * Math.min(200, Math.max(50, event.source.height))) / 60)
						); //60 FPS

						vscrollParent.scrollTop = next;
					}

					if (scrollX) {
						var _current = hscrollParent.scrollLeft;

						var _next = Math.min(
							hscrollParent.scrollWidth,
							Math.max(0, _current + (scrollX * 5 * Math.min(200, Math.max(50, event.source.width))) / 60)
						); //60 FPS

						hscrollParent.scrollLeft = _next;
					}

					scrollTimer = requestAnimationFrame(cb);
				};

				scrollTimer = requestAnimationFrame(cb);
			}
		} else {
			clearScrollTimer();
		}
	} else clearScrollTimer();
}

function clearScrollTimer() {
	if (scrollTimer) {
		cancelAnimationFrame(scrollTimer);
		scrollTimer = null;
	}
}

function notifyDragDrop(e) {
	clearScrollTimer();
	var event = getDragEvent(e, "dragdrop");
	if (puppet.stop) puppet.stop();
	if (activeZone && activeZone.onDrop) event.result = activeZone.onDrop(event);
	dropZones.execute(function(zone) {
		if (nearZones != null && zone.onDragAway && nearZones.has(zone)) zone.onDragAway(e);
		if (!dragStartedZones.has(zone)) return;
		if (zone.onDragEnd) zone.onDragEnd(event);
	});
	if (puppet.onDragEnd) puppet.onDragEnd(event);
	nearZones = null;
	activeZone = null;
	puppet = null;
	dragStartedZones = null;
}

function getDragEvent(e, type) {
	return {
		type: type,
		event: e,
		cursor: getCursorPos(e),
		source: puppet.source
	};
}

var dragCandidate = {};
function ddMouseDown(e) {
	//do not allow that the same event is processed by multiple drag sources
	//the first (top-level) source should be a drag-candidate
	if (e.timeStamp <= dragCandidate.timeStamp) return;
	dragCandidate = {
		el: e.currentTarget,
		start: _objectSpread2({}, getCursorPos(e)),
		timeStamp: e.timeStamp
	};
}
function ddMouseUp() {
	dragCandidate = {};
}
function ddDetect(e) {
	var cursor = getCursorPos(e);

	if (
		e.currentTarget == dragCandidate.el &&
		Math.abs(cursor.clientX - dragCandidate.start.clientX) + Math.abs(cursor.clientY - dragCandidate.start.clientY) >= 2
	) {
		dragCandidate = {};
		return true;
	}
}
var lastDragHandle;
function ddHandle(e) {
	lastDragHandle = e.currentTarget;
}
function isDragHandleEvent(e) {
	return lastDragHandle && (e.target == lastDragHandle || lastDragHandle.contains(e.target));
}
var DragDropContext = VDOM.createContext
	? VDOM.createContext({
			disabled: false
	  })
	: function(_ref) {
			var children = _ref.children;
			return children;
	  };

var ContextWrap = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(ContextWrap, _Container);

	function ContextWrap() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = ContextWrap.prototype;

	_proto.render = function render(context, instance, key) {
		return /*#__PURE__*/ jsx(
			DragDropContext.Provider,
			{
				value: this.value,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	return ContextWrap;
})(Container);

var Overlay = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(Overlay, _Container);

	function Overlay() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = Overlay.prototype;

	_proto.init = function init() {
		if (this.center) this.centerX = this.centerY = this.center;

		_Container.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Container$prototype$;

		return (_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					shadowStyle: {
						structured: true
					},
					resizable: undefined,
					draggable: undefined,
					zIndex: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				inline: this.inline,
				modal: this.modal,
				pad: this.pad,
				resizable: data.resizable,
				draggable: data.draggable,
				animate: this.animate,
				shadow: this.modal || this.backdrop
			}
		);

		_Container.prototype.prepareData.call(this, context, instance);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.positionChangeSubcribers = new SubscriberList();

		_Container.prototype.initInstance.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		if (isBinding(this.visible)) {
			if (!instance.dismiss) {
				instance.dismiss = function() {
					if (instance.onBeforeDismiss && instance.onBeforeDismiss() === false) return;
					instance.set("visible", false);
				};
			}
		} else if (context.options.dismiss) instance.dismiss = context.options.dismiss;

		if (instance.dismiss) {
			context.push(
				"parentOptions",
				_objectSpread2(
					_objectSpread2({}, context.parentOptions),
					{},
					{
						dismiss: instance.dismiss
					}
				)
			);
		}

		if (instance.cache("dismiss", instance.dismiss)) instance.markShouldUpdate(context);
		context.push("parentPositionChangeEvent", instance.positionChangeSubcribers);

		_Container.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		if (instance.dismiss) context.pop("parentOptions");
		context.pop("parentPositionChangeEvent");
	};

	_proto.render = function render(context, instance, key) {
		return /*#__PURE__*/ jsx(
			OverlayComponent,
			{
				instance: instance,
				subscribeToBeforeDismiss: context.options.subscribeToBeforeDismiss,
				parentEl: context.options.parentEl,
				children: this.renderContents(context, instance)
			},
			key
		);
	};

	_proto.renderContents = function renderContents(context, instance) {
		return this.renderChildren(context, instance);
	};

	_proto.overlayDidMount = function overlayDidMount(instance, component) {
		var el = component.el;
		if (this.centerX) if (!el.style.left) el.style.left = (window.innerWidth - el.offsetWidth) / 2 + "px";
		if (this.centerY) if (!el.style.top) el.style.top = Math.max(0, (window.innerHeight - el.offsetHeight) / 2) + "px";
	};

	_proto.overlayDidUpdate = function overlayDidUpdate(instance, component) {};

	_proto.overlayWillUnmount = function overlayWillUnmount(instance, component) {};

	_proto.handleFocusOut = function handleFocusOut(instance, component) {
		if (this.onFocusOut) instance.invoke("onFocusOut", instance, component);
		if (this.dismissOnFocusOut && instance.dismiss) instance.dismiss();
	};

	_proto.handleKeyDown = function handleKeyDown(e, instance, component) {
		if (this.onKeyDown && instance.invoke("onKeyDown", e, instance, component) === false) return false;

		if (this.closeOnEscape && e.keyCode == KeyCode.esc && instance.dismiss) {
			instance.dismiss();
			e.stopPropagation();
		}
	};

	_proto.handleMouseLeave = function handleMouseLeave(instance, component) {
		if (this.onMouseLeave) instance.invoke("onMouseLeave", instance, component);
	};

	_proto.handleMouseEnter = function handleMouseEnter(instance, component) {
		if (this.onMouseEnter) instance.invoke("onMouseEnter", instance, component);
	};

	_proto.containerFactory = function containerFactory() {
		var el = document.createElement("div");
		document.body.appendChild(el);
		el.style.position = "absolute";
		if (this.containerStyle) Object.assign(el.style, parseStyle(this.containerStyle));
		return el;
	};

	_proto.open = function open(storeOrInstance, options) {
		if (!this.initialized) this.init();
		var el = this.containerFactory();
		el.style.display = "hidden";
		var beforeDismiss, stop;
		options = _objectSpread2(
			_objectSpread2(
				{
					destroyDelay: this.destroyDelay,
					removeParentDOMElement: true
				},
				options
			),
			{},
			{
				parentEl: el,
				dismiss: function dismiss() {
					if (beforeDismiss && beforeDismiss() === false) return;
					stop();
					beforeDismiss = null;
				},
				subscribeToBeforeDismiss: function subscribeToBeforeDismiss(cb) {
					beforeDismiss = cb;
				}
			}
		);
		options.name = options.name || "overlay";
		stop = startAppLoop(el, storeOrInstance, this, options);
		return options.dismiss;
	};

	_proto.handleMove = function handleMove(e, instance, component) {
		var _this = this;

		var widget = instance.widget;

		if (!widget.onMove || instance.invoke("onMove", e, instance, component) !== false) {
			instance.store.silently(function() {
				if (isObject(_this.style) && isObject(_this.style.top) && _this.style.top.bind) {
					instance.store.set(_this.style.top.bind, component.el.style.top);
				}

				if (isObject(_this.style) && isObject(_this.style.left) && _this.style.left.bind) {
					instance.store.set(_this.style.left.bind, component.el.style.left);
				}
			});
		}

		instance.positionChangeSubcribers.notify();
	};

	_proto.handleResize = function handleResize(e, instance, component) {
		var _this2 = this;

		var widget = instance.widget;

		if (!widget.onResize || instance.invoke("onResize", e, instance, component) !== false) {
			instance.store.silently(function() {
				if (isObject(_this2.style) && isObject(_this2.style.width) && _this2.style.width.bind) {
					instance.store.set(_this2.style.width.bind, component.el.style.width);
				}

				if (isObject(_this2.style) && isObject(_this2.style.height) && _this2.style.height.bind) {
					instance.store.set(_this2.style.height.bind, component.el.style.height);
				}
			});
		}

		instance.positionChangeSubcribers.notify();
	};

	return Overlay;
})(Container);
Overlay.prototype.styled = true;
Overlay.prototype.baseClass = "overlay";
Overlay.prototype.resizable = false;
Overlay.prototype.resizeWidth = 7;
Overlay.prototype.center = false;
Overlay.prototype.centerX = false;
Overlay.prototype.centerY = false;
Overlay.prototype.modal = false;
Overlay.prototype.backdrop = false;
Overlay.prototype.inline = false;
Overlay.prototype.autoFocus = false;
Overlay.prototype.autoFocusFirstChild = false;
Overlay.prototype.animate = false;
Overlay.prototype.draggable = false;
Overlay.prototype.destroyDelay = 0;
Overlay.prototype.dismissOnFocusOut = false;
Overlay.prototype.focusable = false;
Overlay.prototype.containerStyle = null;
Overlay.prototype.dismissOnPopState = false;
Overlay.prototype.closeOnEscape = false;
Widget.alias("overlay", Overlay); //TODO: all el related logic should be moved here

var OverlayContent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(OverlayContent, _VDOM$Component);

	function OverlayContent() {
		return _VDOM$Component.apply(this, arguments) || this;
	}

	var _proto2 = OverlayContent.prototype;

	_proto2.render = function render() {
		return /*#__PURE__*/ jsx("div", {
			ref: this.props.onRef,
			className: this.props.className,
			style: this.props.style,
			tabIndex: this.props.tabIndex,
			onFocus: this.props.onFocus,
			onBlur: this.props.onBlur,
			onKeyDown: this.props.onKeyDown,
			onMouseMove: this.props.onMouseMove,
			onMouseUp: this.props.onMouseUp,
			onMouseDown: this.props.onMouseDown,
			onTouchStart: this.props.onTouchStart,
			onTouchEnd: this.props.onTouchEnd,
			onTouchMove: this.props.onTouchMove,
			onMouseEnter: this.props.onMouseEnter,
			onMouseLeave: this.props.onMouseLeave,
			onClick: this.props.onClick,
			children: this.props.children
		});
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		this.props.onDidUpdate();
	};

	return OverlayContent;
})(VDOM.Component); //TODO: This should be called OverlayPortal

var OverlayComponent = /*#__PURE__*/ (function(_VDOM$Component2) {
	_inheritsLoose(OverlayComponent, _VDOM$Component2);

	function OverlayComponent(props) {
		var _this3;

		_this3 = _VDOM$Component2.call(this, props) || this;
		_this3.state = {};
		_this3.customStyle = {};
		return _this3;
	}

	var _proto3 = OverlayComponent.prototype;

	_proto3.render = function render() {
		var _this$props = this.props,
			instance = _this$props.instance,
			parentEl = _this$props.parentEl;
		var widget = instance.widget;
		if (widget.inline || parentEl) return this.renderOverlay();

		if (!this.containerEl) {
			this.ownedEl = widget.containerFactory();
			this.ownedEl.style.display = "hidden";
			this.containerEl = this.ownedEl;
		}

		if (VDOM.DOM.createPortal) return VDOM.DOM.createPortal(this.renderOverlay(), this.containerEl); //rendered in componentDidUpdate if portals are not supported

		return null;
	};

	_proto3.renderOverlay = function renderOverlay() {
		var _this4 = this;

		var _this$props$instance = this.props.instance,
			widget = _this$props$instance.widget,
			data = _this$props$instance.data;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		if (!this.onOverlayRef)
			this.onOverlayRef = function(el) {
				_this4.el = el;
			};

		var content = /*#__PURE__*/ jsxs(OverlayContent, {
			onRef: this.onOverlayRef,
			className: data.classNames,
			style: data.style,
			tabIndex: widget.focusable ? 0 : null,
			onFocus: this.onFocus.bind(this),
			onBlur: this.onBlur.bind(this),
			onKeyDown: this.onKeyDown.bind(this),
			onMouseDown: this.onMouseDown.bind(this),
			onMouseUp: this.onMouseUp.bind(this),
			onMouseMove: this.onMouseMove.bind(this),
			onTouchStart: this.onMouseDown.bind(this),
			onTouchEnd: this.onMouseUp.bind(this),
			onTouchMove: this.onMouseMove.bind(this),
			onMouseLeave: this.onMouseLeave.bind(this),
			onMouseEnter: this.onMouseEnter.bind(this),
			onClick: this.onClick.bind(this),
			onDidUpdate: this.overlayDidUpdate.bind(this),
			children: [
				widget.modal ||
					(widget.backdrop &&
						/*#__PURE__*/ jsx(
							"div",
							{
								className: CSS.element(baseClass, "modal-backdrop"),
								onClick: this.onBackdropClick.bind(this)
							},
							"backdrop"
						)),
				this.renderOverlayBody()
			]
		});

		var result = content;

		if (widget.modal || widget.backdrop) {
			result = /*#__PURE__*/ jsx(
				"div",
				{
					ref: function ref(el) {
						_this4.shadowEl = el;
					},
					className: CSS.element(baseClass, "shadow", {
						animated: this.state.animated,
						"animate-enter": this.state.animated && !this.dismissed,
						animate: widget.animate
					}),
					style: parseStyle(data.shadowStyle),
					children: content
				},
				"shadow"
			);
		}

		return result;
	};

	_proto3.renderOverlayBody = function renderOverlayBody() {
		return this.props.children;
	};

	_proto3.onFocus = function onFocus() {
		FocusManager.nudge();
		this.onFocusIn();
		if (this.el) oneFocusOut(this, this.el, this.onFocusOut.bind(this));
	};

	_proto3.onBlur = function onBlur() {
		FocusManager.nudge();
	};

	_proto3.onFocusIn = function onFocusIn() {};

	_proto3.onFocusOut = function onFocusOut() {
		var widget = this.props.instance.widget;
		widget.handleFocusOut(this.props.instance, this);
	};

	_proto3.onMouseEnter = function onMouseEnter(e) {
		var widget = this.props.instance.widget;
		widget.handleMouseEnter(this.props.instance, this);
	};

	_proto3.onMouseLeave = function onMouseLeave(e) {
		var widget = this.props.instance.widget;
		widget.handleMouseLeave(this.props.instance, this);
	};

	_proto3.onClick = function onClick(e) {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onClick) instance.invoke("onClick", e, instance, this);
	};

	_proto3.onKeyDown = function onKeyDown(e) {
		var widget = this.props.instance.widget;
		widget.handleKeyDown(e, this.props.instance, this);
	};

	_proto3.getResizePrefix = function getResizePrefix(e) {
		var _this$props$instance2 = this.props.instance,
			widget = _this$props$instance2.widget,
			data = _this$props$instance2.data;
		if (!data.resizable) return "";
		var cursor = this.getCursorPos(e);
		var bounds = getTopLevelBoundingClientRect(this.el);
		var leftMargin = cursor.clientX - bounds.left;
		var rightMargin = bounds.right - cursor.clientX;
		var topMargin = cursor.clientY - bounds.top;
		var bottomMargin = bounds.bottom - cursor.clientY;
		var prefix = "";
		if (topMargin >= 0 && topMargin < widget.resizeWidth) prefix += "n";
		else if (bottomMargin >= 0 && bottomMargin < widget.resizeWidth) prefix += "s";
		if (leftMargin >= 0 && leftMargin < widget.resizeWidth) prefix += "w";
		else if (rightMargin >= 0 && rightMargin < widget.resizeWidth) prefix += "e";
		return prefix;
	};

	_proto3.onMouseDown = function onMouseDown(e) {
		var data = this.props.instance.data;
		var prefix = this.getResizePrefix(e);

		if (prefix) {
			//e.preventDefault();
			var rect = getTopLevelBoundingClientRect(this.el);
			var cursor = this.getCursorPos(e);
			var captureData = {
				prefix: prefix,
				dl: cursor.clientX - rect.left,
				dt: cursor.clientY - rect.top,
				dr: cursor.clientX - rect.right,
				db: cursor.clientY - rect.bottom,
				rect: rect
			};
			captureMouseOrTouch(e, this.onMouseMove.bind(this), null, captureData, prefix + "-resize");
		} else if (data.draggable) {
			ddMouseDown(e);
		}

		e.stopPropagation();
	};

	_proto3.onBackdropClick = function onBackdropClick(e) {
		e.stopPropagation();
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onBackdropClick) instance.invoke("onBackdropClick", e, instance);

		if (widget.backdrop) {
			if (instance.dismiss) instance.dismiss();
		}
	};

	_proto3.onMouseUp = function onMouseUp(e) {
		ddMouseUp();
		e.stopPropagation();
	};

	_proto3.onMouseMove = function onMouseMove(e, captureData) {
		// handle dragging
		var instance = this.props.instance;
		var data = instance.data,
			widget = instance.widget;
		var detect = ddDetect(e);

		if (data.draggable && detect) {
			this.startMoveOperation(e);
			return;
		}

		if (captureData && captureData.prefix) {
			var prefix = captureData.prefix,
				rect = captureData.rect,
				dl = captureData.dl,
				dt = captureData.dt,
				dr = captureData.dr,
				db = captureData.db;
			var cursor = this.getCursorPos(e);
			if (prefix.indexOf("w") != -1)
				this.setCustomStyle({
					left: cursor.clientX - dl + "px",
					width: rect.right - cursor.clientX + dl + "px",
					right: "auto"
				});
			if (prefix.indexOf("n") != -1)
				this.setCustomStyle({
					top: cursor.clientY - dt + "px",
					height: rect.bottom - cursor.clientY + dt + "px",
					bottom: "auto"
				});
			if (prefix.indexOf("e") != -1)
				this.setCustomStyle({
					width: cursor.clientX - dr - rect.left + "px",
					left: rect.left + "px",
					right: "auto"
				});
			if (prefix.indexOf("s") != -1)
				this.setCustomStyle({
					height: cursor.clientY - db - rect.top + "px",
					top: rect.top + "px",
					bottom: "auto"
				});
			if (prefix.indexOf("w") >= 0 || prefix.indexOf("n") >= 0) widget.handleMove(e, instance, this);
			widget.handleResize(e, instance, this);
		} else {
			var _prefix = this.getResizePrefix(e);

			this.setCustomStyle({
				cursor: _prefix ? _prefix + "-resize" : null
			});
		}
	};

	_proto3.getCursorPos = function getCursorPos(e) {
		var x = (e.touches && e.touches[0]) || e;
		return {
			clientX: x.clientX,
			clientY: x.clientY
		};
	};

	_proto3.startMoveOperation = function startMoveOperation(e) {
		if (this.el && !this.getResizePrefix(e)) {
			e.stopPropagation();
			var rect = getTopLevelBoundingClientRect(this.el);
			var cursor = this.getCursorPos(e);
			var data = {
				dx: cursor.clientX - rect.left,
				dy: cursor.clientY - rect.top
			};
			captureMouseOrTouch(e, this.onMove.bind(this), null, data, getComputedStyle(e.target).cursor);
		}
	};

	_proto3.onMove = function onMove(e, data) {
		if (data) {
			var cursor = this.getCursorPos(e);
			e.preventDefault();
			this.setCustomStyle({
				left: cursor.clientX - data.dx + "px",
				top: cursor.clientY - data.dy + "px",
				right: "auto",
				bottom: "auto"
			});
			var instance = this.props.instance;
			var widget = instance.widget;
			widget.handleMove(e, instance, this);
		}
	};

	_proto3.onBeforeDismiss = function onBeforeDismiss() {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.overlayWillDismiss && widget.overlayWillDismiss(instance, this) === false) return false;
		this.dismissed = true; //this.el might be null if visible is set to false

		if (this.el) {
			this.el.className = this.getOverlayCssClass(); // if (widget.animate)
			//    this.setState({
			//       animated: false
			//    });
		}

		return true;
	};

	_proto3.componentDidMount = function componentDidMount() {
		var _this5 = this;

		var _this$props2 = this.props,
			instance = _this$props2.instance,
			subscribeToBeforeDismiss = _this$props2.subscribeToBeforeDismiss,
			parentEl = _this$props2.parentEl;
		var widget = instance.widget,
			data = instance.data;
		this.setZIndex(isNumber(data.zIndex) ? data.zIndex : ZIndexManager.next());
		this.componentDidUpdate();
		widget.overlayDidMount(instance, this);
		if (this.containerEl) this.containerEl.style.display = null;
		else if (parentEl) parentEl.style.display = null;
		var childHasFocus = isSelfOrDescendant(this.el, document.activeElement);
		if (childHasFocus) oneFocusOut(this, this.el, this.onFocusOut.bind(this));
		else {
			if (!widget.autoFocusFirstChild || !FocusManager.focusFirstChild(this.el))
				if (widget.focusable && widget.autoFocus) FocusManager.focus(this.el);
		}
		instance.onBeforeDismiss = this.onBeforeDismiss.bind(this);

		if (subscribeToBeforeDismiss) {
			subscribeToBeforeDismiss(instance.onBeforeDismiss);
		}

		if (widget.animate) {
			setTimeout(function() {
				if (!_this5.unmounting)
					_this5.setState({
						animated: true
					});
			}, 0);
		}

		if (widget.dismissOnPopState) {
			this.onPopState = function() {
				_this5.props.instance.dismiss();
			};

			window.addEventListener("popstate", this.onPopState);
		}

		if (this.shadowEl)
			this.unsubscribeWheelBlock = addEventListenerWithOptions(
				this.shadowEl,
				"wheel",
				function(e) {
					if (e.shiftKey) return; //check if there is a scrollable element within the shadow or overlay contents
					//such that its scrollbar is not at the very end

					var scrollAllowed = false;
					closest(e.target, function(el) {
						if (
							(e.deltaY > 0 && el.scrollTop < el.scrollHeight - el.clientHeight) ||
							(e.deltaY < 0 && el.scrollTop > 0)
						) {
							scrollAllowed = true;
							return true;
						}

						if (el == e.currentTarget) return true;
					});
					if (!scrollAllowed) e.preventDefault();
				},
				{
					passive: false
				}
			);
	};

	_proto3.componentWillUnmount = function componentWillUnmount() {
		var _this6 = this;

		if (this.onPopState) window.removeEventListener("popstate", this.onPopState);
		if (this.unsubscribeWheelBlock) this.unsubscribeWheelBlock();
		offFocusOut(this);
		this.unmounting = true;
		var widget = this.props.instance.widget;
		var baseClass = widget.baseClass,
			CSS = widget.CSS; // //we didn't have a chance to call onBeforeDismiss

		if (this.state.animated && this.el) {
			this.el.className = this.getOverlayCssClass();
			if (this.shadowEl)
				this.shadowEl.className = CSS.element(baseClass, "shadow", {
					animate: widget.animate,
					"animate-leave": true
				});
		}

		widget.overlayWillUnmount(this.props.instance, this);

		if (this.ownedEl) {
			setTimeout(function() {
				if (_this6.ownedEl.parentNode) _this6.ownedEl.parentNode.removeChild(_this6.ownedEl);
				_this6.ownedEl = null;
			}, widget.destroyDelay);
		}

		delete this.containerEl;
	};

	_proto3.setZIndex = function setZIndex(zIndex) {
		if (this.shadowEl) this.shadowEl.style.zIndex = zIndex;
		this.setCustomStyle({
			zIndex: zIndex
		});
	};

	_proto3.setCustomStyle = function setCustomStyle(style) {
		Object.assign(this.customStyle, style);
		if (this.el) Object.assign(this.el.style, this.customStyle);
	};

	_proto3.getOverlayStyle = function getOverlayStyle() {
		var data = this.props.instance.data;
		return _objectSpread2(_objectSpread2({}, data.style), this.customStyle);
	};

	_proto3.setCSSState = function setCSSState(mods) {
		var m = _objectSpread2({}, this.state.mods);

		var changed = false;

		for (var k in mods) {
			if (m[k] !== mods[k]) {
				m[k] = mods[k];
				changed = true;
			}
		}

		if (changed)
			this.setState({
				mods: mods
			});
	};

	_proto3.getOverlayCssClass = function getOverlayCssClass() {
		var _this$props$instance3 = this.props.instance,
			data = _this$props$instance3.data,
			widget = _this$props$instance3.widget;
		var CSS = widget.CSS;
		return CSS.expand(
			data.classNames,
			CSS.state(
				_objectSpread2(
					_objectSpread2({}, this.state.mods),
					{},
					{
						animated: this.state.animated && !this.unmounting && !this.dismissed,
						"animate-enter": this.state.animated && !this.dismissed,
						"animate-leave": widget.animate && this.dismissed
					}
				)
			)
		);
	};

	_proto3.overlayDidUpdate = function overlayDidUpdate() {
		if (this.el && !this.dismissed) {
			var widget = this.props.instance.widget;
			widget.overlayDidUpdate(this.props.instance, this);
			this.el.className = this.getOverlayCssClass();
			Object.assign(this.el.style, this.getOverlayStyle());
		}
	};

	_proto3.componentDidUpdate = function componentDidUpdate() {
		if (this.containerEl && !VDOM.DOM.createPortal) {
			VDOM.DOM.render(this.renderOverlay(), this.containerEl);
		}

		this.overlayDidUpdate();
	};

	return OverlayComponent;
})(VDOM.Component);

var Dropdown = /*#__PURE__*/ (function(_Overlay) {
	_inheritsLoose(Dropdown, _Overlay);

	function Dropdown() {
		return _Overlay.apply(this, arguments) || this;
	}

	var _proto = Dropdown.prototype;

	_proto.init = function init() {
		if (this.trackMouse) {
			this.trackMouseX = true;
			this.trackMouseY = true;
		}

		if (this.autoFocus && !this.hasOwnProperty(this.focusable)) this.focusable = true;

		_Overlay.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Overlay$prototype$de;

		return (_Overlay$prototype$de = _Overlay.prototype.declareData).call.apply(
			_Overlay$prototype$de,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					placement: undefined
				}
			])
		);
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.mousePosition = this.mousePosition;
		instance.parentPositionChangeEvent = context.parentPositionChangeEvent;

		_Overlay.prototype.initInstance.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		context.push("lastDropdown", instance);

		_Overlay.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("lastDropdown");

		_Overlay.prototype.exploreCleanup.call(this, context, instance);
	};

	_proto.overlayDidMount = function overlayDidMount(instance, component) {
		var _this = this;

		_Overlay.prototype.overlayDidMount.call(this, instance, component);

		var scrollableParents = (component.scrollableParents = [window]);

		component.updateDropdownPosition = function(e) {
			return _this.updateDropdownPosition(instance, component);
		};

		var el = instance.relatedElement.parentElement;

		while (el) {
			scrollableParents.push(el);
			el = el.parentElement;
		}

		scrollableParents.forEach(function(el) {
			el.addEventListener("scroll", component.updateDropdownPosition);
		});
		component.offResize = ResizeManager.subscribe(component.updateDropdownPosition);
		if (this.onDropdownDidMount) instance.invoke("onDropdownDidMount", instance, component);
		if (this.pipeValidateDropdownPosition)
			instance.invoke("pipeValidateDropdownPosition", component.updateDropdownPosition, instance);
		if (instance.parentPositionChangeEvent)
			component.offParentPositionChange = instance.parentPositionChangeEvent.subscribe(
				component.updateDropdownPosition
			);
	};

	_proto.overlayDidUpdate = function overlayDidUpdate(instance, component) {
		this.updateDropdownPosition(instance, component);
	};

	_proto.overlayWillUnmount = function overlayWillUnmount(instance, component) {
		var scrollableParents = component.scrollableParents;

		if (scrollableParents) {
			scrollableParents.forEach(function(el) {
				el.removeEventListener("scroll", component.updateDropdownPosition);
			});
			delete component.scrollableParents;
			delete component.updateDropdownPosition;
		}

		if (component.offResize) component.offResize();
		if (this.pipeValidateDropdownPosition) instance.invoke("pipeValidateDropdownPosition", null, instance);
		if (component.offParentPositionChange) component.offParentPositionChange();
		delete component.parentBounds;
	};

	_proto.updateDropdownPosition = function updateDropdownPosition(instance, component) {
		var el = component.el;
		var data = instance.data,
			relatedElement = instance.relatedElement;
		var parentBounds = (component.parentBounds = getTopLevelBoundingClientRect(relatedElement)); //getBoundingClientRect() will return an empty rect if the element is hidden or removed

		if (parentBounds.left == 0 && parentBounds.top == 0 && parentBounds.bottom == 0 && parentBounds.right == 0) return;

		if (this.trackMouseX && instance.mousePosition) {
			parentBounds = {
				top: parentBounds.top,
				bottom: parentBounds.bottom,
				left: instance.mousePosition.x,
				right: instance.mousePosition.x
			};
		}

		if (this.trackMouseY && instance.mousePosition) {
			parentBounds = {
				left: parentBounds.left,
				right: parentBounds.right,
				top: instance.mousePosition.y,
				bottom: instance.mousePosition.y
			};
		}

		var explode = this.pad && typeof this.elementExplode === "number" ? this.elementExplode : 0;

		if (explode) {
			parentBounds = {
				left: Math.round(parentBounds.left - explode),
				right: Math.round(parentBounds.right + explode),
				top: Math.round(parentBounds.top - explode),
				bottom: Math.round(parentBounds.bottom + explode)
			};
		}

		var style = {};
		if (this.matchWidth) style.minWidth = parentBounds.right - parentBounds.left + "px";
		if (this.matchMaxWidth) style.maxWidth = parentBounds.right - parentBounds.left + "px";
		var contentSize = this.measureNaturalDropdownSize(instance, component);
		var placement = this.findOptimalPlacement(contentSize, parentBounds, data.placement, component.lastPlacement);
		this.applyPositioningPlacementStyles(style, placement, contentSize, parentBounds, el, false);
		component.setCustomStyle(style);
		this.setDirectionClass(component, placement);

		if (this.constrain) {
			//recheck content size for changes as sometimes when auto is used the size can change
			var newContentSize = this.measureNaturalDropdownSize(instance, component);

			if (newContentSize.width != contentSize.width || newContentSize.height != contentSize.height) {
				var newStyle = {};
				this.applyPositioningPlacementStyles(newStyle, placement, newContentSize, parentBounds, el, true);
				component.setCustomStyle(newStyle);
			}
		}

		var params = {
			style: style,
			placement: placement,
			parentBounds: parentBounds
		};
		if (this.onDropdownPositionDidUpdate) instance.invoke("onDropdownPositionDidUpdate", params, instance, component);
		instance.positionChangeSubcribers.notify();
	};

	_proto.applyFixedPositioningPlacementStyles = function applyFixedPositioningPlacementStyles(
		style,
		placement,
		contentSize,
		rel,
		el,
		noAuto
	) {
		var viewport = getViewportRect(this.screenPadding);
		style.position = "fixed";

		if (placement.startsWith("down")) {
			style.top = (this.cover ? rel.top : rel.bottom) + this.offset + "px";
			var bottom = viewport.bottom - (rel.bottom + this.offset + contentSize.height);
			style.bottom =
				this.constrain && (noAuto || bottom < this.screenPadding + 10)
					? Math.max(this.screenPadding, bottom) + "px"
					: "auto";
		} else if (placement.startsWith("up")) {
			var top = rel.top - this.offset - contentSize.height - viewport.top;
			style.top =
				this.constrain && (noAuto || top < this.screenPadding + 10) ? Math.max(this.screenPadding, top) + "px" : "auto";
			style.bottom = document.documentElement.offsetHeight - (this.cover ? rel.bottom : rel.top) + this.offset + "px";
		}

		switch (placement) {
			case "down":
			case "down-center":
				style.right = "auto";
				style.left = Math.round((rel.left + rel.right - el.offsetWidth) / 2) + "px";
				break;

			case "down-right":
				style.right = "auto";
				style.left = rel.left + "px";
				break;

			case "down-left":
				style.right = document.documentElement.offsetWidth - rel.right + "px";
				style.left = "auto";
				break;

			case "up":
			case "up-center":
				style.right = "auto";
				style.left = Math.round((rel.left + rel.right - el.offsetWidth) / 2) + "px";
				break;

			case "up-right":
				style.right = "auto";
				style.left = rel.left + "px";
				break;

			case "up-left":
				style.right = document.documentElement.offsetWidth - rel.right + "px";
				style.left = "auto";
				break;

			case "right":
			case "right-center":
				style.top = Math.round((rel.top + rel.bottom - el.offsetHeight) / 2) + "px";
				style.right = "auto";
				style.bottom = "auto";
				style.left = rel.right + this.offset + "px";
				break;

			case "right-down":
				style.top = rel.top + "px";
				style.right = "auto";
				style.bottom = "auto";
				style.left = rel.right + this.offset + "px";
				break;

			case "right-up":
				style.top = "auto";
				style.right = "auto";
				style.bottom = document.documentElement.offsetHeight - rel.bottom + "px";
				style.left = rel.right + this.offset + "px";
				break;

			case "left":
			case "left-center":
				style.top = Math.round((rel.top + rel.bottom - el.offsetHeight) / 2) + "px";
				style.right = document.documentElement.offsetWidth - rel.left + this.offset + "px";
				style.bottom = "auto";
				style.left = "auto";
				break;

			case "left-down":
				style.top = rel.top + "px";
				style.right = document.documentElement.offsetWidth - rel.left + this.offset + "px";
				style.bottom = "auto";
				style.left = "auto";
				break;

			case "left-up":
				style.top = "auto";
				style.right = document.documentElement.offsetWidth - rel.left + this.offset + "px";
				style.bottom = document.documentElement.offsetHeight - rel.bottom + "px";
				style.left = "auto";
				break;

			case "screen-center":
				var w = Math.min(contentSize.width, document.documentElement.offsetWidth - 2 * this.screenPadding);
				var h = Math.min(contentSize.height, document.documentElement.offsetHeight - 2 * this.screenPadding);
				style.top = Math.round((document.documentElement.offsetHeight - h) / 2) + "px";
				style.right = Math.round((document.documentElement.offsetWidth - w) / 2) + "px";
				style.bottom = Math.round((document.documentElement.offsetHeight - h) / 2) + "px";
				style.left = Math.round((document.documentElement.offsetWidth - w) / 2) + "px";
				break;
		}
	};

	_proto.applyAbsolutePositioningPlacementStyles = function applyAbsolutePositioningPlacementStyles(
		style,
		placement,
		contentSize,
		rel,
		el,
		noAuto
	) {
		var viewport = getViewportRect(this.screenPadding);
		style.position = "absolute";

		if (placement.startsWith("down")) {
			style.top = rel.bottom - rel.top + this.offset + "px";
			var room = viewport.bottom - rel.bottom + this.offset;
			style.bottom =
				this.constrain && (noAuto || contentSize.height >= room - 10)
					? -Math.min(room, contentSize.height) + "px"
					: "auto";
		} else if (placement.startsWith("up")) {
			var _room = rel.top - this.offset - viewport.top;

			style.top =
				this.constrain && (noAuto || contentSize.height >= _room - 10)
					? -Math.min(_room, contentSize.height) + "px"
					: "auto";
			style.bottom = rel.bottom - rel.top - this.offset + "px";
		}

		switch (placement) {
			case "down":
			case "down-center":
				style.right = "auto";
				style.left = Math.round((rel.right - rel.left - el.offsetWidth) / 2) + "px";
				break;

			case "down-right":
				style.right = "auto";
				style.left = "0";
				break;

			case "down-left":
				style.right = "0";
				style.left = "auto";
				break;

			case "up":
			case "up-center":
				style.right = "auto";
				style.left = Math.round((rel.right - rel.left - el.offsetWidth) / 2) + "px";
				break;

			case "up-right":
				style.right = "auto";
				style.left = "0";
				break;

			case "up-left":
				style.right = "0";
				style.left = "auto";
				break;

			case "right":
			case "right-center":
				style.top = Math.round((rel.bottom - rel.top - el.offsetHeight) / 2) + "px";
				style.right = "auto";
				style.bottom = "auto";
				style.left = rel.right - rel.left + this.offset + "px";
				break;

			case "right-down":
				style.top = "0";
				style.right = "auto";
				style.bottom = "auto";
				style.left = rel.right - rel.left + this.offset + "px";
				break;

			case "right-up":
				style.top = "auto";
				style.right = "auto";
				style.bottom = "0";
				style.left = rel.right - rel.left + this.offset + "px";
				break;

			case "left":
			case "left-center":
				style.top = Math.round((rel.bottom - rel.top - el.offsetHeight) / 2) + "px";
				style.right = rel.right - rel.left + this.offset + "px";
				style.bottom = "auto";
				style.left = "auto";
				break;

			case "left-down":
				style.top = "0";
				style.right = rel.right - rel.left + this.offset + "px";
				style.bottom = "auto";
				style.left = "auto";
				break;

			case "left-up":
				style.top = "auto";
				style.right = rel.right - rel.left + this.offset + "px";
				style.bottom = "0";
				style.left = "auto";
				break;
		}
	};

	_proto.applyPositioningPlacementStyles = function applyPositioningPlacementStyles(
		style,
		placement,
		contentSize,
		parentBounds,
		el,
		noAuto
	) {
		switch (this.positioning) {
			case "absolute":
				this.applyAbsolutePositioningPlacementStyles(style, placement, contentSize, parentBounds, el, noAuto);
				break;

			case "auto":
				if (isTouchDevice())
					this.applyAbsolutePositioningPlacementStyles(style, placement, contentSize, parentBounds, el, noAuto);
				else this.applyFixedPositioningPlacementStyles(style, placement, contentSize, parentBounds, el, noAuto);
				break;

			default:
				this.applyFixedPositioningPlacementStyles(style, placement, contentSize, parentBounds, el, noAuto);
				break;
		}
	};

	_proto.setDirectionClass = function setDirectionClass(component, placement) {
		var _objectSpread2$1;

		var state = {
			"place-left": false,
			"place-right": false,
			"place-up": false,
			"place-down": false
		};
		component.lastPlacement = placement;
		component.setCSSState(
			_objectSpread2(
				_objectSpread2({}, state),
				{},
				((_objectSpread2$1 = {}), (_objectSpread2$1["place-" + placement] = true), _objectSpread2$1)
			)
		);
	};

	_proto.measureNaturalDropdownSize = function measureNaturalDropdownSize(instance, component) {
		var el = component.el;
		var size = {
			width: el.offsetWidth,
			height: this.constrain ? calculateNaturalElementHeight(el) : el.offsetHeight - el.clientHeight + el.scrollHeight
		};

		if (this.firstChildDefinesHeight && el.firstChild) {
			size.height = el.firstChild.offsetHeight;
		}

		if (this.firstChildDefinesWidth && el.firstChild) {
			size.width = el.firstChild.offsetWidth;
		}

		if (this.onMeasureNaturalContentSize) {
			var more = instance.invoke("onMeasureNaturalContentSize", el, instance, component);
			Object.assign(size, more);
		}

		return size;
	};

	_proto.findOptimalPlacement = function findOptimalPlacement(contentSize, target, placement, lastPlacement) {
		var placementOrder = this.placementOrder.split(" ");
		var best = lastPlacement || placement;
		var first;
		var score = {};
		var viewport = getViewportRect();

		for (var i = 0; i < placementOrder.length; i++) {
			var p = placementOrder[i];
			if (!first) first = p;
			var parts = p.split("-");
			var primary = parts[0];
			var secondary = parts[1] || "center";
			score[p] = 0;
			var vertical = true;

			switch (primary) {
				case "down":
					score[p] += 3 * Math.min(1, (viewport.bottom - target.bottom - this.offset) / contentSize.height);
					break;

				case "up":
					score[p] += 3 * Math.min(1, (target.top - viewport.top - this.offset) / contentSize.height);
					break;

				case "right":
					score[p] += target.right + contentSize.width + this.offset < viewport.right ? 3 : 0;
					vertical = false;
					break;

				case "left":
					score[p] += target.left - contentSize.width - this.offset >= viewport.left ? 3 : 0;
					vertical = false;
					break;
			}

			switch (secondary) {
				case "center":
					if (vertical) {
						score[p] += (target.right + target.left - contentSize.width) / 2 >= viewport.left ? 1 : 0;
						score[p] += (target.right + target.left + contentSize.width) / 2 < viewport.right ? 1 : 0;
					} else {
						score[p] += (target.bottom + target.top - contentSize.height) / 2 >= viewport.top ? 1 : 0;
						score[p] += (target.bottom + target.top + contentSize.height) / 2 < viewport.bottom ? 1 : 0;
					}

					break;

				case "right":
					score[p] += target.left + contentSize.width < viewport.right ? 2 : 0;
					break;

				case "left":
					score[p] += target.right - contentSize.width >= viewport.left ? 2 : 0;
					break;

				case "up":
					score[p] += target.bottom - contentSize.height >= viewport.top ? 2 : 0;
					break;

				case "down":
					score[p] += target.top + contentSize.height < viewport.bottom ? 2 : 0;
					break;
			}
		}

		if (!(best in score)) best = first;

		for (var k in score) {
			if (score[k] > score[best]) best = k;
		}

		if (this.touchFriendly && isTouchDevice() && score[best] < 5) return "screen-center";
		return best;
	};

	_proto.handleKeyDown = function handleKeyDown(e, instance) {
		switch (e.keyCode) {
			case 27:
				//esc
				var focusable = findFirst(instance.relatedElement, isFocusable);
				if (focusable) focusable.focus();
				e.stopPropagation();
				e.preventDefault();
				break;
		}

		if (this.onKeyDown) instance.invoke("onKeyDown", e, instance);
	};

	_proto.renderContents = function renderContents(context, instance) {
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var result = [_Overlay.prototype.renderContents.call(this, context, instance)];

		if (this.arrow) {
			result.push(
				/*#__PURE__*/ jsx(
					"div",
					{
						className: CSS.element(baseClass, "arrow-border")
					},
					"arrow-border"
				),
				/*#__PURE__*/ jsx(
					"div",
					{
						className: CSS.element(baseClass, "arrow-fill")
					},
					"arrow-back"
				)
			);
		}

		return result;
	};

	_proto.render = function render(context, instance, key) {
		var _this2 = this;

		var CSS = this.CSS,
			baseClass = this.baseClass; //if relatedElement is not provided, a beacon is rendered to and used to resolve a nearby element as a target
		//if onResolveTarget doesn't provide another element, the beacon itself is used as a target

		var beacon = null;
		if (this.relatedElement) instance.relatedElement = this.relatedElement;

		if (!this.relatedElement || instance.needsBeacon) {
			beacon = /*#__PURE__*/ jsx(
				"div",
				{
					className: CSS.element(baseClass, "beacon"),
					ref: function ref(el) {
						if (instance.relatedElement) return;
						var target = el;
						if (_this2.onResolveRelatedElement) target = instance.invoke("onResolveRelatedElement", el, instance);
						else target = el.previousElementSibling;
						if (!target) target = el;
						if (target == el) instance.needsBeacon = true;
						instance.relatedElement = target;
						instance.setState({
							dummy: {}
						});
					}
				},
				key + "-beacon"
			);
		}

		return [beacon, instance.relatedElement && _Overlay.prototype.render.call(this, context, instance, key)];
	};

	return Dropdown;
})(Overlay);
Dropdown.prototype.offset = 0;
Dropdown.prototype.baseClass = "dropdown";
Dropdown.prototype.matchWidth = true;
Dropdown.prototype.matchMaxWidth = false;
Dropdown.prototype.placementOrder = "up down right left";
Dropdown.prototype.placement = null; //default placement

Dropdown.prototype.constrain = false;
Dropdown.prototype.positioning = "fixed";
Dropdown.prototype.touchFriendly = false;
Dropdown.prototype.arrow = false;
Dropdown.prototype.pad = false;
Dropdown.prototype.elementExplode = 0;
Dropdown.prototype.screenPadding = 5;
Dropdown.prototype.firstChildDefinesHeight = false;
Dropdown.prototype.firstChildDefinesWidth = false;
Dropdown.prototype.cover = false;
Widget.alias("dropdown", Dropdown);
Localization.registerPrototype("cx/widgets/Dropdown", Dropdown);

function getViewportRect(padding) {
	if (padding === void 0) {
		padding = 0;
	}

	return {
		left: padding,
		top: padding,
		right: document.documentElement.offsetWidth - padding,
		bottom: document.documentElement.offsetHeight - padding
	};
}

var Tooltip = /*#__PURE__*/ (function(_Dropdown) {
	_inheritsLoose(Tooltip, _Dropdown);

	function Tooltip() {
		return _Dropdown.apply(this, arguments) || this;
	}

	var _proto = Tooltip.prototype;

	_proto.declareData = function declareData() {
		var _Dropdown$prototype$d;

		(_Dropdown$prototype$d = _Dropdown.prototype.declareData).call.apply(
			_Dropdown$prototype$d,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					text: undefined,
					title: undefined,
					alwaysVisible: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				"mouse-trap": this.mouseTrap
			}
		);

		_Dropdown.prototype.prepareData.call(this, context, instance);
	};

	_proto.renderContents = function renderContents(context, instance) {
		var data = instance.data;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		return [
			data.title &&
				/*#__PURE__*/ jsx(
					"div",
					{
						className: CSS.element(baseClass, "title"),
						children: data.title
					},
					"title"
				),
			data.text
		].concat(_Dropdown.prototype.renderContents.call(this, context, instance));
	};

	_proto.initInstance = function initInstance(context, instance) {
		var _this = this;

		_Dropdown.prototype.initInstance.call(this, context, instance);

		if (this.trackMouseX || this.trackMouseY) {
			instance.trackMouse = function(e) {
				var pos = getCursorPos(e);
				instance.mousePosition = {
					x: pos.clientX,
					y: pos.clientY
				};
				if (instance.tooltipComponent) _this.updateDropdownPosition(instance, instance.tooltipComponent);
			};
		}
	};

	_proto.overlayDidMount = function overlayDidMount(instance, component) {
		var _this2 = this;

		instance.tooltipComponent = component;

		_Dropdown.prototype.overlayDidMount.call(this, instance, component);

		instance.parentValidityCheckTimer = setInterval(function() {
			if (!_this2.relatedElement.ownerDocument.body.contains(_this2.relatedElement)) {
				if (instance.dismissTooltip) {
					instance.dismissTooltip();
					instance.dismissTooltip = null;
				}
			} else {
				if (instance.tooltipComponent) _this2.updateDropdownPosition(instance, instance.tooltipComponent);
			}
		}, 500);

		if (instance.widget.globalMouseTracking && instance.trackMouse) {
			document.addEventListener("mousemove", instance.trackMouse);
		}
	};

	_proto.overlayWillUnmount = function overlayWillUnmount(instance, component) {
		clearInterval(instance.parentValidityCheckTimer);

		_Dropdown.prototype.overlayWillUnmount.call(this, instance, component);

		instance.tooltipComponent = null;

		if (instance.widget.globalMouseTracking && instance.trackMouse) {
			document.removeEventListener("mousemove", instance.trackMouse);
		}
	};

	_proto.handleMouseEnter = function handleMouseEnter(instance, component) {
		instance.mouseOverTooltip = true;

		_Dropdown.prototype.handleMouseEnter.call(this, instance, component);
	};

	_proto.handleMouseLeave = function handleMouseLeave(instance, component) {
		instance.mouseOverTooltip = false;
		if (this.mouseTrap) this.handleMouseLeavesParent(instance);

		_Dropdown.prototype.handleMouseLeave.call(this, instance, component);
	};

	_proto.handleMouseLeavesParent = function handleMouseLeavesParent(instance) {
		var _this3 = this;

		var timeout = this.mouseTrap ? 200 : 0;
		setTimeout(function() {
			if (!instance.mouseOverTarget && !(_this3.mouseTrap && instance.mouseOverTooltip))
				_this3.dismissTooltip(instance);
		}, timeout);
	};

	_proto.dismissTooltip = function dismissTooltip(instance) {
		if (instance && instance.dismissTooltip) {
			if (
				instance.data &&
				instance.data.alwaysVisible &&
				this.relatedElement.ownerDocument.body.contains(this.relatedElement)
			)
				return;
			instance.dismissTooltip();
			instance.dismissTooltip = null;
		}
	};

	_proto.checkVisible = function checkVisible(context, instance, data) {
		if (!isNonEmptyArray(this.items) && !data.title && !data.text) return false;
		return _Dropdown.prototype.checkVisible.call(this, context, instance, data);
	};

	return Tooltip;
})(Dropdown);
Widget.alias("tooltip", Tooltip);
Tooltip.prototype.baseClass = "tooltip";
Tooltip.prototype.offset = 8;
Tooltip.prototype.placementOrder =
	"right up down left up-right up-left right-up right-down down-right down-left left-up left-down";
Tooltip.prototype.animate = true;
Tooltip.prototype.destroyDelay = 300;
Tooltip.prototype.createDelay = 200;
Tooltip.prototype.matchWidth = false;
Tooltip.prototype.trackMouse = false;
Tooltip.prototype.trackMouseX = false;
Tooltip.prototype.trackMouseY = false;
Tooltip.prototype.touchFriendly = false; //rename to positioningMode

Tooltip.prototype.touchBehavior = "toggle";
Tooltip.prototype.arrow = true;
Tooltip.prototype.alwaysVisible = false;
Tooltip.prototype.globalMouseTracking = false;
function getTooltipInstance(e, parentInstance, tooltip, options) {
	if (options === void 0) {
		options = {};
	}

	var target = options.target || (e && e.currentTarget) || e;
	debug(tooltipsFlag, "mouse-move", target, parentInstance);
	var name = options.tooltipName || "tooltip";
	if (!parentInstance.tooltips) parentInstance.tooltips = {};
	var tooltipInstance = parentInstance.tooltips[name]; //no tooltips on disabled elements

	if (parentInstance != null && parentInstance.data.disabled) {
		if (tooltipInstance && tooltipInstance.dismissTooltip) tooltipInstance.dismissTooltip();
		return;
	}

	if (tooltipInstance && (tooltipInstance.widget.relatedElement != target || tooltipInstance.config != tooltip)) {
		if (tooltipInstance.dismissTooltip) tooltipInstance.dismissTooltip();
		delete parentInstance.tooltips[name];
		tooltipInstance = null;
	}

	if (!tooltip || !target) return;

	if (!tooltipInstance) {
		var config = tooltip;

		if (isSelector(tooltip)) {
			config = {
				text: tooltip
			};
		}

		var tooltipWidget = Tooltip.create(
			{
				relatedElement: target
			},
			config
		);
		var store = new ReadOnlyDataView({
			store: parentInstance.store
		});
		tooltipInstance = parentInstance.tooltips[name] = parentInstance.getDetachedChild(tooltipWidget, name, store);
		tooltipInstance.config = tooltip;

		if (tooltip.alwaysVisible || tooltip.trackMouse || tooltip.trackMouseX || tooltip.trackMouseY) {
			tooltipInstance.init(new RenderingContext());
			tooltipInstance.data = tooltipInstance.dataSelector(store);
		}
	}

	return tooltipInstance;
}

function tooltipMouseMove$1(e, parentInstance, tooltip, options) {
	if (options === void 0) {
		options = {};
	}

	var instance = getTooltipInstance(e, parentInstance, tooltip, options);
	if (!instance) return;
	if (isTouchEvent() && instance.widget.touchBehavior == "ignore") return false;
	var dirty = !shallowEquals(options.data, instance.store.data);
	instance.store.setData(options.data);
	instance.mouseOverTarget = true;

	if (!instance.dismissTooltip) {
		var canceled = false;

		var dismiss = function dismiss() {
			canceled = true;
		};

		var unsubscribeDismiss = instance.parent.subscribeOnDestroy(function() {
			dismiss();
		});

		instance.dismissTooltip = function() {
			unsubscribeDismiss();
			dismiss();
		};

		setTimeout(function() {
			var relatedElement = instance.widget.relatedElement;

			if (!canceled && instance.mouseOverTarget && relatedElement.ownerDocument.body.contains(relatedElement)) {
				dismiss = instance.widget.open(instance, {
					onPipeUpdate: function onPipeUpdate(cb) {
						instance.update = cb;
					}
				});
			}
		}, instance.widget.createDelay);
	} else {
		if (isTouchEvent() && instance.widget.touchBehavior == "toggle") {
			instance.dismissTooltip();
			instance.dismissTooltip = null;
		} else if (dirty && instance.update) instance.update();
	}

	if (instance.trackMouse && e && e.target) instance.trackMouse(e);
}

function tooltipMouseLeave$1(e, parentInstance, tooltip, options) {
	var instance = getTooltipInstance(e, parentInstance, tooltip, options);

	if (instance) {
		instance.mouseOverTarget = false;
		instance.widget.handleMouseLeavesParent(instance);
	}
}

function tooltipParentDidMount$1(element, parentInstance, tooltip, options) {
	if (tooltip && tooltip.alwaysVisible) {
		var instance = getTooltipInstance(element, parentInstance, tooltip, options);
		if (instance && instance.data.alwaysVisible) tooltipMouseMove$1(element, parentInstance, tooltip, options);
	}
}

function tooltipParentWillReceiveProps$1(element, parentInstance, tooltip, options) {
	var instance = getTooltipInstance(element, parentInstance, tooltip, options);

	if (instance && options) {
		instance.store.setData(options.data);
		if (instance.update) instance.update();
		if (instance.mouseOverTarget || (instance.data && instance.data.alwaysVisible))
			tooltipMouseMove$1(element, parentInstance, tooltip, options);
	}
}

function tooltipParentWillUnmount$1(parentInstance) {
	if (parentInstance.tooltips) {
		for (var name in parentInstance.tooltips) {
			var instance = parentInstance.tooltips[name];
			instance.mouseOverTarget = false;
			if (instance.dismissTooltip) parentInstance.tooltips[name].dismissTooltip();
		}
	}
}

function enableTooltips() {
	wireTooltipOps({
		tooltipMouseMove: tooltipMouseMove$1,
		tooltipMouseLeave: tooltipMouseLeave$1,
		tooltipParentDidMount: tooltipParentDidMount$1,
		tooltipParentWillReceiveProps: tooltipParentWillReceiveProps$1,
		tooltipParentWillUnmount: tooltipParentWillUnmount$1
	});
}

var Window = /*#__PURE__*/ (function(_Overlay) {
	_inheritsLoose(Window, _Overlay);

	function Window() {
		return _Overlay.apply(this, arguments) || this;
	}

	var _proto = Window.prototype;

	_proto.init = function init() {
		if (isDefined(this.closeable)) this.closable = this.closeable;
		if (isString(this.headerStyle)) this.headerStyle = parseStyle(this.headerStyle);
		if (isString(this.footerStyle)) this.footerStyle = parseStyle(this.footerStyle);
		if (isString(this.bodyStyle)) this.bodyStyle = parseStyle(this.bodyStyle);

		_Overlay.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Overlay$prototype$de;

		return (_Overlay$prototype$de = _Overlay.prototype.declareData).call.apply(
			_Overlay$prototype$de,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					title: undefined,
					closable: undefined,
					bodyStyle: {
						structured: true
					},
					bodyClass: {
						structured: true
					},
					headerStyle: {
						structured: true
					},
					footerStyle: {
						structured: true
					}
				}
			])
		);
	};

	_proto.initHelpers = function initHelpers() {
		var _Overlay$prototype$in;

		return (_Overlay$prototype$in = _Overlay.prototype.initHelpers).call.apply(
			_Overlay$prototype$in,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					header: Widget.create(
						this.header || {
							type: ContentPlaceholder,
							name: "header",
							scoped: true
						}
					),
					footer: Widget.create(
						this.footer || {
							type: ContentPlaceholder,
							name: "footer",
							scoped: true
						}
					),
					close:
						this.closable &&
						Button.create({
							mod: "hollow",
							dismiss: true,
							icon: "close",
							style: "margin-left: auto",
							onTouchStart: stopPropagation,
							onMouseDown: stopPropagation
						})
				}
			])
		);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		_Overlay.prototype.exploreCleanup.call(this, context, instance);

		var helpers = instance.helpers;
		var unregisterHeader = helpers.header && helpers.header.unregisterContentPlaceholder;
		if (unregisterHeader) unregisterHeader();
		var unregisterFooter = helpers.footer && helpers.footer.unregisterContentPlaceholder;
		if (unregisterFooter) unregisterFooter();
	};

	_proto.renderHeader = function renderHeader(context, instance, key) {
		var data = instance.data;
		var result = [];
		if (data.title) result.push(data.title);

		if (instance.helpers) {
			var header = getContent(instance.helpers.header && instance.helpers.header.render(context, key));
			if (header) result.push(header);
			if (data.closable && instance.helpers.close) result.push(getContent(instance.helpers.close.render(context)));
		}

		return result;
	};

	_proto.renderFooter = function renderFooter(context, instance, key) {
		return getContent(instance.helpers && instance.helpers.footer && instance.helpers.footer.render(context, key));
	};

	_proto.render = function render(context, instance, key) {
		var header = this.renderHeader(context, instance, "header");
		var footer = this.renderFooter(context, instance, "footer");
		return /*#__PURE__*/ jsx(
			WindowComponent,
			{
				instance: instance,
				header: header,
				footer: footer,
				children: this.renderContents(context, instance)
			},
			key
		);
	};

	return Window;
})(Overlay);
Window.prototype.baseClass = "window";
Window.prototype.closable = true;
Window.prototype.resizable = false;
Window.prototype.fixed = false;
Window.prototype.autoFocus = true;
Window.prototype.focusable = true;
Widget.alias("window", Window);
Localization.registerPrototype("cx/widgets/Window", Window);

var WindowComponent = /*#__PURE__*/ (function(_OverlayComponent) {
	_inheritsLoose(WindowComponent, _OverlayComponent);

	function WindowComponent() {
		return _OverlayComponent.apply(this, arguments) || this;
	}

	var _proto2 = WindowComponent.prototype;

	_proto2.renderOverlayBody = function renderOverlayBody() {
		var _this = this;

		var _this$props$instance = this.props.instance,
			widget = _this$props$instance.widget,
			data = _this$props$instance.data;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var header, footer;

		if (this.props.header.length > 0) {
			header = /*#__PURE__*/ jsx(
				"header",
				{
					ref: function ref(c) {
						_this.headerEl = c;
					},
					className: CSS.element(baseClass, "header"),
					style: data.headerStyle,
					onMouseDown: this.onHeaderMouseDown.bind(this),
					onMouseUp: ddMouseUp,
					onMouseMove: this.onHeaderMouseMove.bind(this),
					onTouchStart: this.onHeaderMouseDown.bind(this),
					onTouchEnd: ddMouseUp,
					onTouchMove: this.onHeaderMouseMove.bind(this),
					children: this.props.header
				},
				"header"
			);
		}

		if (this.props.footer) {
			footer = /*#__PURE__*/ jsx(
				"footer",
				{
					ref: function ref(c) {
						_this.footerEl = c;
					},
					className: CSS.element(baseClass, "footer"),
					style: data.footerStyle,
					children: this.props.footer
				},
				"footer"
			);
		}

		var body = /*#__PURE__*/ jsx(
			"div",
			{
				ref: function ref(c) {
					_this.bodyEl = c;
				},
				className: CSS.expand(CSS.element(widget.baseClass, "body"), data.bodyClass),
				style: data.bodyStyle,
				children: this.props.children
			},
			"body"
		);

		return [header, body, footer];
	};

	_proto2.getOverlayCssClass = function getOverlayCssClass() {
		var cls = _OverlayComponent.prototype.getOverlayCssClass.call(this);

		if (this.state.active) cls += " cxs-active";
		return cls;
	};

	_proto2.onFocusIn = function onFocusIn() {
		_OverlayComponent.prototype.onFocusIn.call(this);

		if (!this.state.active) {
			if (this.containerEl.contains(document.activeElement)) this.setZIndex(ZIndexManager.next());
			this.setState({
				active: true
			});
		}
	};

	_proto2.onFocusOut = function onFocusOut() {
		_OverlayComponent.prototype.onFocusOut.call(this);

		if (this.state.active) {
			this.setState({
				active: false
			});
		}
	};

	_proto2.onHeaderMouseDown = function onHeaderMouseDown(e) {
		e.stopPropagation();
		ddMouseDown(e);
	};

	_proto2.onHeaderMouseMove = function onHeaderMouseMove(e) {
		e.stopPropagation();

		if (!this.props.instance.widget.fixed && ddDetect(e)) {
			this.startMoveOperation(e);
		}
	};

	return WindowComponent;
})(OverlayComponent);

var MsgBox = /*#__PURE__*/ (function() {
	function MsgBox() {}

	MsgBox.alert = function alert(options) {
		if (isString(options))
			options = {
				message: options
			};
		return new Promise(function(resolve) {
			var callback = function callback(e, instance) {
				if (options.callback && options.callback() === false) return;
				instance.parentOptions.dismiss();
				resolve();
			};

			var w = Widget.create({
				$type: Window,
				title: options.title,
				header: options.header,
				mod: "alert",
				modal: true,
				center: true,
				resizable: false,
				closable: false,
				style: options.style || "max-width: 90vw",
				dismissOnPopState: true,
				jsxAttributes: [
					"title",
					"header",
					"mod",
					"modal",
					"center",
					"resizable",
					"closable",
					"style",
					"dismissOnPopState"
				],
				children: [
					"\n                  ",
					options.message || options.items || options.children,
					"\n                  ",
					{
						$type: FlexRow,
						putInto: "footer",
						direction: MsgBox.prototype.footerDirection,
						justify: MsgBox.prototype.footerJustify,
						jsxAttributes: ["putInto", "direction", "justify"],
						children: [
							"\n                     ",
							{
								$type: Button,
								mod: MsgBox.prototype.buttonMod,
								onClick: callback,
								jsxAttributes: ["mod", "onClick"],
								children: ["\n                        ", options.okText || "OK", "\n                     "]
							},
							"\n                  "
						]
					},
					"\n               "
				]
			});
			w.open(options.store);
		});
	};

	MsgBox.yesNo = function yesNo(options) {
		if (isString(options))
			options = {
				message: options
			};
		return new Promise(function(resolve, reject) {
			var callback = function callback(option) {
				return function(e, instance) {
					if (options.callback && options.callback(option) === false) return;
					instance.parentOptions.dismiss();
					if (option == "yes") resolve(option);
					else resolve(option);
				};
			};

			var w = Widget.create({
				$type: Window,
				title: options.title,
				header: options.header,
				mod: "alert",
				modal: true,
				center: true,
				resizable: false,
				closable: false,
				style: options.style || "max-width: 90vw",
				dismissOnPopState: true,
				jsxAttributes: [
					"title",
					"header",
					"mod",
					"modal",
					"center",
					"resizable",
					"closable",
					"style",
					"dismissOnPopState"
				],
				children: [
					"\n                  ",
					options.message || options.items || options.children,
					"\n                  ",
					{
						$type: FlexRow,
						putInto: "footer",
						direction: MsgBox.prototype.footerDirection,
						justify: MsgBox.prototype.footerJustify,
						hspacing: "small",
						jsxAttributes: ["putInto", "direction", "justify", "hspacing"],
						children: [
							"\n                     ",
							{
								$type: Button,
								mod: options.yesButtonMod || MsgBox.prototype.buttonMod,
								onClick: callback("yes"),
								jsxAttributes: ["mod", "onClick"],
								children: [
									"\n                        ",
									options.yesText || MsgBox.prototype.yesText,
									"\n                     "
								]
							},
							"\n                     ",
							{
								$type: Button,
								mod: options.noButtonMod || MsgBox.prototype.buttonMod,
								onClick: callback("no"),
								jsxAttributes: ["mod", "onClick"],
								children: [
									"\n                        ",
									options.noText || MsgBox.prototype.noText,
									"\n                     "
								]
							},
							"\n                  "
						]
					},
					"\n               "
				]
			});
			w.open(options.store);
		});
	};

	return MsgBox;
})();
MsgBox.prototype.buttonMod = null;
MsgBox.prototype.footerDirection = "row";
MsgBox.prototype.footerJustify = "center";
MsgBox.prototype.yesText = "Yes";
MsgBox.prototype.noText = "No";
Localization.registerPrototype("cx/widgets/MsgBox", MsgBox);
function enableMsgBoxAlerts() {
	registerAlertImpl({
		yesNo: MsgBox.yesNo.bind(MsgBox),
		alert: MsgBox.alert.bind(MsgBox)
	});
}

var Toast = /*#__PURE__*/ (function(_Overlay) {
	_inheritsLoose(Toast, _Overlay);

	function Toast() {
		return _Overlay.apply(this, arguments) || this;
	}

	var _proto = Toast.prototype;

	_proto.init = function init() {
		if (this.message)
			this.items = {
				type: Text,
				value: this.message
			};

		_Overlay.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Overlay$prototype$de;

		return (_Overlay$prototype$de = _Overlay.prototype.declareData).call.apply(
			_Overlay$prototype$de,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					timeout: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				pad: this.pad
			}
		);

		_Overlay.prototype.prepareData.call(this, context, instance);
	};

	_proto.overlayDidUpdate = function overlayDidUpdate(instance, component) {
		var el = component.containerEl || component.props.parentEl;

		if (component.state.animated) {
			el.style.height = component.el.offsetHeight + "px";
			el.classList.add(this.CSS.state("live"));
		}
	};

	_proto.overlayDidMount = function overlayDidMount(instance, component) {
		var data = instance.data;

		if (data.timeout > 0) {
			component.timeoutTimer = setTimeout(function() {
				instance.dismiss();
			}, data.timeout);
		}
	};

	_proto.overlayWillDismiss = function overlayWillDismiss(instance, component) {
		var el = component.containerEl || component.props.parentEl;
		el.style.height = 0;
		el.classList.remove(this.CSS.state("live"));
	};

	_proto.overlayWillUnmount = function overlayWillUnmount(instance, component) {
		var el = component.containerEl || component.props.parentEl;
		el.style.height = 0;
		el.classList.remove(this.CSS.state("live"));
		if (component.timeoutTimer) clearTimeout(component.timeoutTimer);
	};

	_proto.containerFactory = function containerFactory() {
		var _this$CSS$block;

		var el = document.createElement("div");
		el.className = this.CSS.element("toaster", "item");
		var placement = this.placement || "top";
		var toaster = getToaster(placement);
		toaster.el.className = this.CSS.block(
			"toaster",
			null,
			((_this$CSS$block = {}), (_this$CSS$block["placement-" + placement] = true), _this$CSS$block)
		);
		toaster.el.insertBefore(el, toaster.el.firstChild);
		return el;
	};

	return Toast;
})(Overlay);
var toasters = {};

function getToaster(placement) {
	var t = toasters[placement];

	if (!t) {
		var el = document.createElement("div");
		document.body.appendChild(el);
		t = toasters[placement] = {
			el: el
		};
	}

	return t;
}

Toast.prototype.styled = true;
Toast.prototype.pad = true;
Toast.prototype.animate = true;
Toast.prototype.baseClass = "toast";
Toast.prototype.placement = "top";
Toast.prototype.destroyDelay = 300;

var ContextMenu = /*#__PURE__*/ (function(_Dropdown) {
	_inheritsLoose(ContextMenu, _Dropdown);

	function ContextMenu() {
		return _Dropdown.apply(this, arguments) || this;
	}

	return ContextMenu;
})(Dropdown);
ContextMenu.prototype.trackMouse = true;
ContextMenu.prototype.dismissOnFocusOut = true;
ContextMenu.prototype.firstChildDefinesWidth = true;
ContextMenu.prototype.matchWidth = false;
ContextMenu.prototype.placementOrder = "down-right right up-right down-left left up-left";
ContextMenu.prototype.offset = 0;
ContextMenu.prototype.autoFocus = true;
ContextMenu.prototype.autoFocusFirstChild = false;
ContextMenu.prototype.focusable = true;
var openContextMenu = function openContextMenu(e, content, store, options) {
	e.preventDefault();
	e.stopPropagation();
	var position = getCursorPos(e);
	var menu = ContextMenu.create({
		relatedElement: e.currentTarget,
		mousePosition: {
			x: position.clientX,
			y: position.clientY
		},
		trackMouse: true,
		items: content
	});
	menu.open(store, options);
};

var FlyweightTooltipTracker = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(FlyweightTooltipTracker, _Widget);

	function FlyweightTooltipTracker() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = FlyweightTooltipTracker.prototype;

	_proto.initInstance = function initInstance(context, instance) {
		var _this = this;

		var handler = function handler(e) {
			return _this.handleMouseMove(e, instance);
		};

		document.addEventListener("mousemove", handler);
		instance.subscribeOnDestroy(function() {
			document.removeEventListener("mousemove", handler);
		});
	};

	_proto.render = function render(context, instance, key) {
		return null;
	};

	_proto.handleMouseMove = function handleMouseMove(e, instance) {
		if (!this.onGetTooltip) return;

		if (instance.lastTarget != e.target) {
			instance.lastTarget = e.target;
			var tooltip = null;
			instance.parentEl = closest(e.target, function(element) {
				tooltip = instance.invoke("onGetTooltip", element, instance);
				if (tooltip) return true;
			});
			instance.tooltip = tooltip;
		}

		if (!instance.parentEl) tooltipMouseMove(e, instance, null);
		else
			tooltipMouseMove(e, instance, instance.tooltip, {
				target: instance.parentEl
			});
	};

	return FlyweightTooltipTracker;
})(Widget);

var Route = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(Route, _PureContainer);

	function Route() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = Route.prototype;

	_proto.init = function init() {
		if (this.path) this.route = this.path;

		_PureContainer.prototype.init.call(this);

		if (this.route && this.route[0] !== "+")
			this.matcher = new RouteMatcher(this.route + (this.prefix ? "(*remainder)" : ""));
	};

	_proto.initInstance = function initInstance(context, instance) {
		_PureContainer.prototype.initInstance.call(this, context, instance);

		instance.store = new ReadOnlyDataView({
			store: instance.store
		});

		instance.setStore = function(store) {
			instance.store.setStore(store);
		};
	};

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					url: undefined
				}
			])
		);
	};

	_proto.checkVisible = function checkVisible(context, instance, data) {
		if (!data.visible) return false;

		if (data.url !== instance.cached.url) {
			instance.cached.url = data.url;
			var matcher = this.matcher;
			var route = this.route;

			if (this.route[0] === "+") {
				route = routeAppend(context.lastRoute.route, this.route.substring(1));
				if (!instance.cached.matcher || instance.cached.route !== route)
					instance.cached.matcher = new RouteMatcher(route + (this.prefix ? "(*remainder)" : ""));
				matcher = instance.cached.matcher;
			}

			instance.cached.result = matcher.match(data.url);
			instance.cached.matcher = matcher;
			instance.cached.route = data.route = route;
		}

		if (!instance.cached.result) return false;
		return _PureContainer.prototype.checkVisible.call(this, context, instance, data);
	};

	_proto.prepareData = function prepareData(context, _ref) {
		var _store$setData;

		var data = _ref.data,
			store = _ref.store,
			cached = _ref.cached;

		_PureContainer.prototype.prepareData.apply(this, arguments);

		store.setData(((_store$setData = {}), (_store$setData[this.recordName] = cached.result), _store$setData)); //TODO: Replace comparison with deepEquals

		if (this.params && this.params.bind) {
			var params = store.get(this.params.bind);

			if (JSON.stringify(params) != JSON.stringify(cached.result)) {
				store.set(this.params.bind, cached.result);
			}
		}

		if (this.map) {
			for (var key in result) {
				var binding = this.map[key];
				if (binding) store.set(binding, result[key]);
			}
		}
	};

	_proto.explore = function explore(context, instance) {
		context.push("lastRoute", {
			route: instance.cached.route,
			result: instance.cached.result,
			reverse: function reverse(data) {
				return instance.cached.matcher.reverse(
					_objectSpread2(
						_objectSpread2({}, instance.cached.result),
						{},
						{
							remainder: ""
						},
						data
					)
				);
			}
		});

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("lastRoute");
	};

	return Route;
})(PureContainer);
Route.prototype.recordName = "$route";
Route.prototype.prefix = false;
Widget.alias("route", Route);

var RedirectRoute = /*#__PURE__*/ (function(_Route) {
	_inheritsLoose(RedirectRoute, _Route);

	function RedirectRoute() {
		return _Route.apply(this, arguments) || this;
	}

	var _proto = RedirectRoute.prototype;

	_proto.checkVisible = function checkVisible(context, instance, data) {
		if (!data.visible) return false;
		if (!data.url && !data.route) return true;
		return _Route.prototype.checkVisible.call(this, context, instance, data);
	};

	_proto.declareData = function declareData() {
		var _Route$prototype$decl;

		(_Route$prototype$decl = _Route.prototype.declareData).call.apply(
			_Route$prototype$decl,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					redirect: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		_Route.prototype.prepareData.apply(this, arguments);

		var data = instance.data;
		if (data.redirect && data.redirect[0] === "+")
			data.redirect = routeAppend(context.lastRoute.reverse(), data.redirect.substring(1));
		if (data.redirect && History.store) History.replaceState({}, null, Url.resolve(data.redirect));
		else instance.set("url", data.redirect);
	};

	return RedirectRoute;
})(Route);
Widget.alias("redirect-route", RedirectRoute);

var Tab = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(Tab, _HtmlElement);

	function Tab() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = Tab.prototype;

	_proto.declareData = function declareData() {
		var _HtmlElement$prototyp;

		(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
			_HtmlElement$prototyp,
			[
				this,
				{
					tab: undefined,
					value: undefined,
					disabled: undefined,
					text: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = {
			active: data.tab == data.value,
			disabled: data.disabled,
			shape: this.shape
		};
		if (this["default"] && isUndefined(data.value)) instance.set("value", data.tab);

		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
		switch (attrName) {
			case "value":
			case "tab":
			case "text":
			case "disabled":
			case "default":
				return false;

			default:
				return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
		}
	};

	_proto.attachProps = function attachProps(context, instance, props) {
		var _this = this;

		_HtmlElement.prototype.attachProps.call(this, context, instance, props);

		var data = instance.data;

		if (!data.disabled) {
			props.href = "#";
			delete props.value;

			props.onMouseDown = function(e) {
				if (_this.onMouseDown) instance.invoke("onMouseDown", e, instance);
				preventFocusOnTouch(e);
			};

			props.onClick = function(e) {
				return _this.handleClick(e, instance);
			};
		}
	};

	_proto.handleClick = function handleClick(e, instance) {
		if (this.onClick) instance.invoke("onClick", e, instance);
		e.preventDefault();
		e.stopPropagation();
		var data = instance.data;
		if (data.disabled) return;
		instance.set("value", data.tab);
	};

	return Tab;
})(HtmlElement);
Tab.prototype.baseClass = "tab";
Tab.prototype.tag = "a";
Tab.prototype.focusOnMouseDown = false;
Tab.prototype["default"] = false;
Widget.alias("tab", Tab);

var LinkButton = /*#__PURE__*/ (function(_Button) {
	_inheritsLoose(LinkButton, _Button);

	function LinkButton() {
		return _Button.apply(this, arguments) || this;
	}

	var _proto = LinkButton.prototype;

	_proto.init = function init() {
		this.activeStyle = parseStyle(this.activeStyle);
		this.inacativeStyle = parseStyle(this.inactiveStyle);

		_Button.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Button$prototype$dec;

		(_Button$prototype$dec = _Button.prototype.declareData).call.apply(
			_Button$prototype$dec,
			[
				this,
				{
					href: undefined,
					url: undefined,
					active: undefined,
					activeClass: undefined,
					activeStyle: undefined,
					inactiveClass: undefined,
					inactiveStyle: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.unresolvedHref = data.href;

		if (typeof data.href === "string") {
			if (data.unresolvedHref[0] === "+")
				data.unresolvedHref = routeAppend(context.lastRoute.reverse(), data.href.substring(1));
			data.href = Url.resolve(data.unresolvedHref);
		}

		var active = this.isActive(data);
		data.stateMods = {
			disabled: data.disabled,
			active: active
		};

		_Button.prototype.prepareData.call(this, context, instance);

		if (active) {
			if (data.activeClass) data.classNames += " " + data.activeClass;
			if (data.activeStyle) data.style = _objectSpread2(_objectSpread2({}, data.style), parseStyle(data.activeStyle));
		} else {
			if (data.inactiveClass) data.classNames += " " + data.inactiveClass;
			if (data.inactiveStyle)
				data.style = _objectSpread2(_objectSpread2({}, data.style), parseStyle(data.inactiveStyle));
		}
	};

	_proto.isActive = function isActive(data) {
		if (data.active != null) return data.active;

		switch (this.match) {
			default:
			case "equal":
				return data.url === data.unresolvedHref;

			case "prefix":
				return data.url && data.unresolvedHref && data.url.indexOf(data.unresolvedHref) === 0;

			case "subroute":
				return (
					data.url &&
					data.unresolvedHref &&
					data.url.indexOf(data.unresolvedHref) === 0 &&
					(data.url === data.unresolvedHref || data.url[data.unresolvedHref.length] === "/")
				);
		}
	};

	_proto.attachProps = function attachProps(context, instance, props) {
		var _this = this;

		props.onClick = function(ev) {
			_this.handleClick(ev, instance);
		};

		_Button.prototype.attachProps.call(this, context, instance, props);

		props.href = instance.data.href;
		delete props.active;
		delete props.activeClass;
		delete props.activeStyle;
		delete props.inactiveClass;
		delete props.inactiveStyle;
	};

	_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attr) {
		if (attr === "url" || attr === "match") return false;
		return _Button.prototype.isValidHtmlAttribute.call(this, attr);
	};

	_proto.handleClick = function handleClick(e, instance) {
		var data = instance.data;

		if (data.disabled) {
			e.preventDefault();
			return;
		}

		if (this.onClick && instance.invoke("onClick", e, instance) === false) return;

		if (data.href && Url.isLocal(data.href) && !e.ctrlKey && !e.shiftKey && !e.metaKey) {
			e.preventDefault();
			History.pushState({}, null, data.href);
		}
	};

	return LinkButton;
})(Button);
LinkButton.prototype.match = "equal";
LinkButton.prototype.tag = "a";
Widget.alias("link-button", LinkButton);

var Link = /*#__PURE__*/ (function(_LinkButton) {
	_inheritsLoose(Link, _LinkButton);

	function Link() {
		return _LinkButton.apply(this, arguments) || this;
	}

	return Link;
})(LinkButton);
Link.prototype.baseClass = "link";
Widget.alias("link", Link);

var MenuItem = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(MenuItem, _HtmlElement);

	function MenuItem() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = MenuItem.prototype;

	_proto.init = function init() {
		if (this.hideCursor) this.showCursor = false;

		_HtmlElement.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _HtmlElement$prototyp;

		(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
			_HtmlElement$prototyp,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					icon: undefined,
					disabled: undefined,
					checked: false,
					arrow: undefined,
					confirm: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		instance.horizontal = this.horizontal;
		var lastMenu = context.lastMenu;

		if (lastMenu) {
			instance.horizontal = lastMenu.horizontal;
			instance.padding = lastMenu.itemPadding;
			instance.icons = lastMenu.icons;
		}

		instance.parentPositionChangeEvent = context.parentPositionChangeEvent;
		if (!instance.padding && this.pad == true) instance.padding = "medium";
		if (this.padding) instance.padding = this.padding;
		context.push("lastMenuItem", this);

		_HtmlElement.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("lastMenuItem");
	};

	_proto.render = function render(context, instance, key) {
		return /*#__PURE__*/ jsx(
			MenuItemComponent,
			{
				instance: instance,
				data: instance.data,
				children: instance.data.text
					? /*#__PURE__*/ jsx("span", {
							children: instance.data.text
					  })
					: this.renderChildren(context, instance)
			},
			key
		);
	};

	_proto.add = function add(element) {
		if (element && typeof element == "object" && element.putInto == "dropdown") {
			this.dropdown = _objectSpread2({}, element);
			delete this.dropdown.putInto;
		} else _HtmlElement.prototype.add.apply(this, arguments);
	};

	_proto.addText = function addText(text) {
		this.add({
			type: HtmlElement,
			tag: "span",
			text: text
		});
	};

	return MenuItem;
})(HtmlElement);
MenuItem.prototype.baseClass = "menuitem";
MenuItem.prototype.hoverFocusTimeout = 500;
MenuItem.prototype.hoverToOpen = false;
MenuItem.prototype.clickToOpen = false;
MenuItem.prototype.horizontal = true;
MenuItem.prototype.arrow = false;
MenuItem.prototype.dropdownOptions = null;
MenuItem.prototype.showCursor = true;
MenuItem.prototype.pad = true;
MenuItem.prototype.placement = null; //default dropdown placement

MenuItem.prototype.placementOrder = null; //allowed menu placements

MenuItem.prototype.autoClose = false;
MenuItem.prototype.checkedIcon = "check";
MenuItem.prototype.uncheckedIcon = "dummy";
MenuItem.prototype.keyboardShortcut = false;
MenuItem.prototype.openOnFocus = true;
MenuItem.prototype.closeDropdownOnScrollDistance = 100;
Widget.alias("submenu", MenuItem);
Localization.registerPrototype("cx/widgets/MenuItem", MenuItem);

var MenuItemComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(MenuItemComponent, _VDOM$Component);

	function MenuItemComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			dropdownOpen: false
		};
		return _this;
	}

	var _proto2 = MenuItemComponent.prototype;

	_proto2.getDefaultPlacementOrder = function getDefaultPlacementOrder(horizontal) {
		return horizontal
			? "down-right down down-left up-right up up-left"
			: "right-down right right-up left-down left left-up";
	};

	_proto2.getDropdown = function getDropdown() {
		var _this2 = this;

		var _this$props$instance = this.props.instance,
			horizontal = _this$props$instance.horizontal,
			widget = _this$props$instance.widget,
			parentPositionChangeEvent = _this$props$instance.parentPositionChangeEvent;

		if (!this.dropdown && widget.dropdown) {
			this.dropdown = Widget.create(
				Dropdown,
				_objectSpread2(
					_objectSpread2(
						{
							matchWidth: false,
							placementOrder: widget.placementOrder || this.getDefaultPlacementOrder(horizontal),
							trackScroll: true,
							inline: true
						},
						widget.dropdownOptions
					),
					{},
					{
						relatedElement: this.el.parentElement,
						placement: widget.placement,
						onKeyDown: this.onDropdownKeyDown.bind(this),
						items: widget.dropdown,
						parentPositionChangeEvent: parentPositionChangeEvent,
						pipeValidateDropdownPosition: function pipeValidateDropdownPosition(cb) {
							_this2.validateDropdownPosition = cb;
						},
						onDropdownPositionDidUpdate: function onDropdownPositionDidUpdate(params) {
							var parentBounds = params.parentBounds;
							var initialScreenPosition = _this2.initialScreenPosition;
							if (!initialScreenPosition) initialScreenPosition = _this2.initialScreenPosition = params.parentBounds;
							if (
								Math.abs(parentBounds.top - initialScreenPosition.top) > widget.closeDropdownOnScrollDistance ||
								Math.abs(parentBounds.left - initialScreenPosition.left) > widget.closeDropdownOnScrollDistance
							)
								_this2.closeDropdown();
						}
					}
				)
			);
		}

		return this.dropdown;
	};

	_proto2.render = function render() {
		var _this3 = this,
			_CSS$state;

		var _this$props = this.props,
			instance = _this$props.instance,
			data = _this$props.data,
			children = _this$props.children;
		var widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;

		var dropdown =
			this.state.dropdownOpen &&
			/*#__PURE__*/ jsx(Cx, {
				widget: this.getDropdown(),
				options: {
					name: "submenu"
				},
				parentInstance: instance,
				subscribe: true
			});

		var arrow =
			data.arrow &&
			/*#__PURE__*/ jsx(DropdownIcon, {
				className: CSS.element(baseClass, "arrow")
			});

		var icon = null;
		var checkbox = widget.checked != null;

		if (checkbox) {
			data.icon = data.checked ? widget.checkedIcon : widget.uncheckedIcon;
		}

		if (data.icon) {
			icon = /*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "button"),
				onClick: function onClick(e) {
					e.preventDefault();
					if (!instance.set("checked", !data.checked)) _this3.onClick(e);
				},
				onMouseDown: function onMouseDown(e) {
					if (checkbox) e.stopPropagation();
				},
				children: Icon.render(data.icon, {
					className: CSS.element(baseClass, "icon")
				})
			});
		}

		var empty = !children || (Array.isArray(children) && children.length == 0);
		var classNames = CSS.expand(
			data.classNames,
			CSS.state(
				((_CSS$state = {
					open: this.state.dropdownOpen,
					horizontal: instance.horizontal,
					vertical: !instance.horizontal,
					arrow: data.arrow,
					cursor: widget.showCursor
				}),
				(_CSS$state[instance.padding + "-padding"] = instance.padding),
				(_CSS$state.icon = !!icon || instance.icons),
				(_CSS$state.disabled = data.disabled),
				(_CSS$state.empty = empty),
				_CSS$state)
			)
		);
		if (empty)
			children = /*#__PURE__*/ jsx("span", {
				className: CSS.element(baseClass, "baseline"),
				children: "\xA0"
			});
		return /*#__PURE__*/ jsxs("div", {
			className: classNames,
			style: data.style,
			tabIndex: !data.disabled && (widget.dropdown || widget.onClick || widget.checked) ? 0 : null,
			ref: function ref(el) {
				_this3.el = el;
			},
			onKeyDown: this.onKeyDown.bind(this),
			onMouseDown: this.onMouseDown.bind(this),
			onMouseEnter: this.onMouseEnter.bind(this),
			onMouseLeave: this.onMouseLeave.bind(this),
			onFocus: this.onFocus.bind(this),
			onClick: this.onClick.bind(this),
			onBlur: this.onBlur.bind(this),
			children: [children, icon, arrow, dropdown]
		});
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		if (this.state.dropdownOpen && this.validateDropdownPosition) {
			this.validateDropdownPosition();
		}
	};

	_proto2.componentDidMount = function componentDidMount() {
		var _this4 = this;

		var widget = this.props.instance.widget;
		if (widget.keyboardShortcut)
			this.unregisterKeyboardShortcut = registerKeyboardShortcut(widget.keyboardShortcut, function(e) {
				_this4.el.focus(); //open the dropdown

				_this4.onClick(e); //execute the onClick handler
			});
		tooltipParentDidMount(this.el, this.props.instance, widget.tooltip);
	};

	_proto2.onDropdownKeyDown = function onDropdownKeyDown(e) {
		debug(menuFlag, "MenuItem", "dropdownKeyDown");
		var horizontal = this.props.instance.horizontal;

		if (
			e.keyCode == KeyCode.esc ||
			(!isTextInputElement(e.target) && (horizontal ? e.keyCode == KeyCode.up : e.keyCode == KeyCode.left))
		) {
			FocusManager.focus(this.el);
			e.preventDefault();
			e.stopPropagation();
		}
	};

	_proto2.clearAutoFocusTimer = function clearAutoFocusTimer() {
		if (this.autoFocusTimerId) {
			debug(menuFlag, "MenuItem", "autoFocusCancel");
			clearTimeout(this.autoFocusTimerId);
			delete this.autoFocusTimerId;
		}
	};

	_proto2.onMouseEnter = function onMouseEnter(e) {
		var _this5 = this;

		debug(menuFlag, "MenuItem", "mouseEnter", this.el);
		var widget = this.props.instance.widget;

		if (widget.dropdown && !this.state.dropdownOpen) {
			this.clearAutoFocusTimer();
			if (widget.hoverToOpen) FocusManager.focus(this.el);
			else if (!widget.clickToOpen) {
				// Automatically open the dropdown only if parent menu is focused
				var commonParentMenu = closest(this.el, function(el) {
					return el.tagName == "UL" && el.contains(getActiveElement());
				});
				if (commonParentMenu)
					this.autoFocusTimerId = setTimeout(function() {
						delete _this5.autoFocusTimerId;

						if (!_this5.state.dropdownOpen) {
							debug(menuFlag, "MenuItem", "hoverFocusTimeout:before", _this5.el);
							FocusManager.focus(_this5.el);
							debug(menuFlag, "MenuItem", "hoverFocusTimeout:after", _this5.el, getActiveElement());
						}
					}, widget.hoverFocusTimeout);
			}
			e.stopPropagation();
			e.preventDefault();
		}

		tooltipMouseMove(e, this.props.instance, widget.tooltip);
	};

	_proto2.onMouseLeave = function onMouseLeave(e) {
		var widget = this.props.instance.widget;

		if (widget.dropdown) {
			debug(menuFlag, "MenuItem", "mouseLeave", this.el);
			this.clearAutoFocusTimer();
			if (widget.hoverToOpen && document.activeElement == this.el) this.el.blur();
		}

		tooltipMouseLeave(e, this.props.instance, widget.tooltip);
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var _this6 = this;

		debug(menuFlag, "MenuItem", "keyDown", this.el);
		var _this$props$instance2 = this.props.instance,
			horizontal = _this$props$instance2.horizontal,
			widget = _this$props$instance2.widget;

		if (widget.dropdown) {
			if (
				e.target == this.el &&
				(e.keyCode == KeyCode.enter || (horizontal ? e.keyCode == KeyCode.down : e.keyCode == KeyCode.right))
			) {
				this.openDropdown(function() {
					var focusableChild = findFirstChild(_this6.el, isFocusable);
					if (focusableChild) FocusManager.focus(focusableChild);
				});
				e.preventDefault();
				e.stopPropagation();
			}

			if (e.keyCode == KeyCode.esc) {
				if (!isFocused(this.el)) {
					FocusManager.focus(this.el);
					e.preventDefault();
					e.stopPropagation();
				}

				this.closeDropdown();
			}
		} else {
			if (e.keyCode == KeyCode.enter && widget.onClick) this.onClick(e);
		}
	};

	_proto2.onMouseDown = function onMouseDown(e) {
		var widget = this.props.instance.widget;

		if (widget.dropdown) {
			e.stopPropagation();
			if (this.state.dropdownOpen && !widget.hoverToOpen) this.closeDropdown();
			else {
				//IE sometimes does not focus parent on child click
				if (!isFocusedDeep(this.el)) FocusManager.focus(this.el);
				this.openDropdown(); //If one of the elements is auto focused prevent stealing focus

				if (isFocusedDeep(this.el)) e.preventDefault();
			}
		}
	};

	_proto2.openDropdown = function openDropdown(callback) {
		var widget = this.props.instance.widget;

		if (widget.dropdown) {
			if (!this.state.dropdownOpen) {
				this.setState(
					{
						dropdownOpen: true
					},
					callback
				); //hide tooltip if dropdown is open

				tooltipMouseLeave(null, this.props.instance, widget.tooltip);
			} else if (callback) callback(this.state);
		}
	};

	_proto2.onClick = function onClick(e) {
		e.stopPropagation();
		var instance = this.props.instance;
		var data = instance.data;

		if (data.disabled) {
			e.preventDefault();
			return;
		}

		var widget = instance.widget;
		if (widget.dropdown) e.preventDefault();
		//prevent navigation
		else {
			instance.set("checked", !instance.data.checked);

			if (widget.onClick) {
				if (data.confirm) {
					yesNo(data.confirm).then(function(btn) {
						if (btn == "yes") instance.invoke("onClick", null, instance);
					});
				} else instance.invoke("onClick", e, instance);
			}
		}
		if (widget.autoClose) getActiveElement().blur();
	};

	_proto2.onFocus = function onFocus() {
		var widget = this.props.instance.widget;

		if (widget.dropdown) {
			oneFocusOut(this, this.el, this.onFocusOut.bind(this));
			debug(menuFlag, "MenuItem", "focus", this.el, document.activeElement);
			this.clearAutoFocusTimer();
			if (widget.openOnFocus) this.openDropdown();
		}
	};

	_proto2.onBlur = function onBlur() {
		FocusManager.nudge();
	};

	_proto2.closeDropdown = function closeDropdown() {
		this.setState({
			dropdownOpen: false
		});
		delete this.initialScreenPosition;
	};

	_proto2.onFocusOut = function onFocusOut(focusedElement) {
		debug(menuFlag, "MenuItem", "focusout", this.el, focusedElement);
		this.clearAutoFocusTimer();

		if (this.el && !isSelfOrDescendant(this.el, focusedElement)) {
			debug(menuFlag, "MenuItem", "closing dropdown", this.el, focusedElement);
			this.closeDropdown();
		}
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		this.clearAutoFocusTimer();
		offFocusOut(this);
		if (this.offParentPositionChange) this.offParentPositionChange();
		if (this.unregisterKeyboardShortcut) this.unregisterKeyboardShortcut();
		tooltipParentWillUnmount(this.props.instance);
	};

	return MenuItemComponent;
})(VDOM.Component);

var MenuSpacer = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(MenuSpacer, _Widget);

	function MenuSpacer() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = MenuSpacer.prototype;

	_proto.render = function render(context, instance, key) {
		return {
			key: true,
			atomic: true,
			spacer: true
		};
	};

	return MenuSpacer;
})(Widget);
MenuSpacer.prototype.isMenuSpacer = true;

var Menu = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(Menu, _HtmlElement);

	function Menu() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = Menu.prototype;

	_proto.init = function init() {
		if (this.itemPadding === true) this.itemPadding = "medium";
		if (this.horizontal && isUndefined(this.itemPadding)) this.itemPadding = this.defaultHorizontalItemPadding;
		if (!this.horizontal && isUndefined(this.itemPadding)) this.itemPadding = this.defaultVerticalItemPadding;

		_HtmlElement.prototype.init.call(this);

		if (this.overflow) {
			if (!this.horizontal) throw new Error("Overflow works only on horizontal menus.");
			this.items.push(
				MenuItem.create({
					icon: this.overflowIcon,
					mod: "overflow",
					items: [
						{
							type: Menu,
							putInto: "dropdown",
							items: [].concat(this.items),
							showOnlyOverflowItems: true
						}
					]
				})
			);
		}
	};

	_proto.prepareData = function prepareData(context, instance) {
		var _objectSpread2$1;

		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			((_objectSpread2$1 = {
				horizontal: this.horizontal,
				vertical: !this.horizontal,
				overflow: this.overflow
			}),
			(_objectSpread2$1[this.itemPadding + "-item-padding"] = this.itemPadding),
			_objectSpread2$1)
		);

		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		context.push("lastMenu", this);

		_HtmlElement.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("lastMenu");
	};

	_proto.render = function render(context, instance, key) {
		return /*#__PURE__*/ jsx(
			MenuComponent,
			{
				instance: instance,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	_proto.add = function add(item) {
		if (item && item.tag == "a") {
			var mi = {
				type: MenuItem,
				items: item,
				autoClose: true
			};
			if (isDefined(item["if"])) mi["if"] = item["if"];
			if (isDefined(item.visible)) mi.visible = item.visible;

			_HtmlElement.prototype.add.call(this, mi);
		} else _HtmlElement.prototype.add.apply(this, arguments);
	};

	return Menu;
})(HtmlElement);
Menu.prototype.horizontal = false;
Menu.prototype.defaultVerticalItemPadding = "medium";
Menu.prototype.defaultHorizontalItemPadding = "small";
Menu.prototype.icons = false;
Menu.prototype.overflow = false;
Menu.prototype.overflowIcon = "drop-down";
Menu.Item = MenuItem;
Menu.Spacer = MenuSpacer;

var MenuComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(MenuComponent, _VDOM$Component);

	function MenuComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			cursor: null,
			nonOverflownItemCount: Infinity
		};

		_this.ref = function(el) {
			_this.el = el;
		};

		return _this;
	}

	var _proto2 = MenuComponent.prototype;

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			children = _this$props.children;
		var data = instance.data,
			widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		this.itemInfo = Array.from({
			length: children.length
		});
		var parentNonOverflownItemCount = 0;

		if (widget.showOnlyOverflowItems) {
			var parent = instance.parent;

			while (parent != null) {
				if (parent.widget instanceof Menu) {
					parentNonOverflownItemCount = parent.nonOverflownItemCount || 0;
					break;
				}

				parent = parent.parent;
			}
		}

		return /*#__PURE__*/ jsx("ul", {
			ref: this.ref,
			className: CSS.expand(
				data.classNames,
				CSS.state({
					pack: this.state.nonOverflownItemCount < children.length - 1
				})
			),
			style: data.style,
			onBlur: FocusManager.nudge(),
			onKeyDown: this.onKeyDown.bind(this),
			children: children.map(function(content, index) {
				var key = content && typeof content == "object" && content.key ? content.key : index;

				if (content && content.spacer) {
					return (
						widget.horizontal &&
						/*#__PURE__*/ jsx(
							"li",
							{
								className: CSS.element(baseClass, "spacer")
							},
							key
						)
					);
				}

				return /*#__PURE__*/ jsx(
					MenuItemComponent$1,
					{
						cursor: key === _this2.state.cursor,
						hidden:
							index < parentNonOverflownItemCount ||
							(index >= _this2.state.nonOverflownItemCount && index + 1 != children.length),
						instance: instance,
						itemInfo: _this2.itemInfo,
						itemKey: key,
						itemIndex: index,
						moveCursor: _this2.moveCursor.bind(_this2),
						children: content
					},
					key
				);
			})
		});
	};

	_proto2.moveCursor = function moveCursor(itemKey) {
		if (itemKey != this.state.cursor) {
			debug(menuFlag, "Menu", "moveCursor", itemKey);
			this.setState({
				cursor: itemKey
			});
		}
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var _this3 = this;

		//ignore the event if it comes from an input element
		if (isTextInputElement(e.target)) return;
		var instance = this.props.instance;
		var widget = instance.widget;
		var keyCode = e.keyCode;
		debug(menuFlag, "Menu", "keyDown", this.el, keyCode);
		var horizontal = widget.horizontal;

		if (keyCode == KeyCode.tab) {
			if (horizontal) keyCode = e.shiftKey ? KeyCode.left : KeyCode.up;
			else keyCode = e.shiftKey ? KeyCode.right : KeyCode.down;
		}

		if (this.state.cursor != null) {
			var cursorIndex = this.itemInfo.findIndex(function(a) {
				return a.key == _this3.state.cursor;
			});

			if (horizontal ? keyCode == KeyCode.left : keyCode == KeyCode.up) {
				for (var c = cursorIndex - 1; c >= 0; c--) {
					if (this.itemInfo[c].focusable) {
						FocusManager.focusFirst(this.itemInfo[c].el);
						e.stopPropagation();
						e.preventDefault();
						return;
					}
				}
			}

			if (horizontal ? keyCode == KeyCode.right : keyCode == KeyCode.down) {
				for (var _c = cursorIndex + 1; _c < this.itemInfo.length; _c++) {
					if (this.itemInfo[_c].focusable) {
						FocusManager.focusFirst(this.itemInfo[_c].el);
						e.stopPropagation();
						e.preventDefault();
						return;
					}
				}
			}
		}

		switch (keyCode) {
			case KeyCode.home:
				if (this.itemInfo[0].focusable) {
					FocusManager.focusFirst(this.itemInfo[0].el);
					e.stopPropagation();
					e.preventDefault();
				}

				break;

			case KeyCode.end:
				if (this.itemInfo[this.itemInfo.length - 1].focusable) {
					FocusManager.focusFirst(this.itemInfo[this.itemInfo.length - 1].el);
					e.stopPropagation();
					e.preventDefault();
				}

				break;
		}
	};

	_proto2.onFocusOut = function onFocusOut(elementReceivingFocus) {
		debug(menuFlag, "Menu", "focusout", this.el, elementReceivingFocus);
		if (this.el && !isSelfOrDescendant(this.el, elementReceivingFocus)) this.moveCursor(null);
	};

	_proto2.componentDidMount = function componentDidMount() {
		var widget = this.props.instance.widget;
		if (widget.autoFocus && this.itemInfo.length > 0 && !isFocusedDeep(this.el))
			FocusManager.focusFirst(this.itemInfo[0].el);

		if (widget.overflow) {
			this.measureOverflow();
			this.unsubscribeResize = ResizeManager.trackElement(this.el, this.measureOverflow.bind(this));
		}

		this.unsubscribeFocusOut = FocusManager.onFocusOut(this.el, this.onFocusOut.bind(this));
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		this.measureOverflow();
	};

	_proto2.measureOverflow = function measureOverflow() {
		var _this4 = this;

		var instance = this.props.instance;
		var widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		if (!widget.overflow) return;
		var spacerClass = CSS.element(baseClass, "spacer");
		var nonOverflownItemCount = 0;
		var fitItemsWidth = 0;
		var children = Array.from(this.el.children);
		var widths = children.map(function(c) {
			if (c.classList.contains(spacerClass)) return 0;
			var w = c.offsetWidth;
			var style = getComputedStyle(c);
			var marginLeft = style.getPropertyValue("margin-left");
			if (isString(marginLeft) && marginLeft.endsWith("px")) w += parseFloat(marginLeft);
			var marginRight = style.getPropertyValue("margin-right");
			if (isString(marginRight) && marginRight.endsWith("px")) w += parseFloat(marginRight);
			return w;
		});
		var clientWidth = this.el.clientWidth;
		var overflowWidth = widths[widths.length - 1];

		for (var i = 0; i < widths.length - 1; i++) {
			var overflowReduction = i == widths.length - 2 ? 0 : overflowWidth;
			if (widths[i] + fitItemsWidth > clientWidth - overflowReduction) break;
			nonOverflownItemCount++;
			fitItemsWidth += widths[i];
		}

		instance.nonOverflownItemCount = nonOverflownItemCount;

		if (!this.isMeasureOverflowDisabled && this.state.nonOverflownItemCount != nonOverflownItemCount) {
			this.isMeasureOverflowDisabled = true;
			this.setState(
				{
					nonOverflownItemCount: nonOverflownItemCount
				},
				function() {
					_this4.isMeasureOverflowDisabled = false;
				}
			);
		}
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		this.unsubscribeFocusOut && this.unsubscribeFocusOut();
		this.unsubscribeResize && this.unsubscribeResize();
	};

	return MenuComponent;
})(VDOM.Component);

Menu.prototype.baseClass = "menu";
Menu.prototype.tag = "ul";
Widget.alias("menu", Menu);

var MenuItemComponent$1 = /*#__PURE__*/ (function(_VDOM$Component2) {
	_inheritsLoose(MenuItemComponent, _VDOM$Component2);

	function MenuItemComponent(props) {
		var _this5;

		_this5 = _VDOM$Component2.call(this, props) || this;
		_this5.state = {
			focusable: true
		};
		return _this5;
	}

	var _proto3 = MenuItemComponent.prototype;

	_proto3.render = function render() {
		var _this6 = this;

		var _this$props2 = this.props,
			itemInfo = _this$props2.itemInfo,
			itemIndex = _this$props2.itemIndex,
			itemKey = _this$props2.itemKey,
			instance = _this$props2.instance,
			cursor = _this$props2.cursor,
			hidden = _this$props2.hidden;
		var widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var mods = {
			cursor: cursor,
			focusable: this.state.focusable,
			hidden: hidden
		};
		return /*#__PURE__*/ jsx("li", {
			ref: function ref(c) {
				_this6.el = c;
				itemInfo[itemIndex] = {
					el: c,
					focusable: _this6.state.focusable,
					key: itemKey
				};
			},
			className: CSS.element(baseClass, "item", mods),
			onFocus: this.onFocus.bind(this),
			onMouseDown: this.onMouseDown.bind(this),
			onKeyDown: this.onKeyDown.bind(this),
			children: this.props.children
		});
	};

	_proto3.onFocus = function onFocus(e) {
		FocusManager.nudge();
		debug(menuFlag, "MenuItem", "focus", this.el, e.target);
		this.props.moveCursor(this.props.itemKey);
	};

	_proto3.onKeyDown = function onKeyDown(e) {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onKeyDown) instance.invoke("onKeyDown", e, instance);
	};

	_proto3.onMouseDown = function onMouseDown(e) {
		e.stopPropagation(); //e.preventDefault(); //Causes problems with focusing menu items. Figure out why is this really needed?

		debug(menuFlag, "MenuItem", "mouseDown", this.el);

		if (this.state.focusable) {
			var _this$props3 = this.props,
				itemInfo = _this$props3.itemInfo,
				itemIndex = _this$props3.itemIndex;
			var el = itemInfo[itemIndex].el;
			var focusableSubElement = closest(e.target, function(domEl) {
				return domEl === el || isFocusable(domEl);
			});

			if (focusableSubElement == el) {
				//the user clicked on an unfocusable branch of elements
				//lets find a focusable child element and focus it
				//TODO: explain why is this really needed
				var focusedEl = getFocusedElement();
				var focusedChild = FocusManager.focusFirst(el);

				if (focusedChild !== focusedEl) {
					debug(menuFlag, "MenuItem", "focusChild", focusedChild, focusedEl);
				}
			}
		}
	};

	_proto3.componentDidMount = function componentDidMount() {
		this.componentDidUpdate();
	};

	_proto3.componentDidUpdate = function componentDidUpdate() {
		var _this$props4 = this.props,
			itemInfo = _this$props4.itemInfo,
			itemIndex = _this$props4.itemIndex,
			hidden = _this$props4.hidden;
		var focusable = !hidden && !!findFirst(this.el, isFocusable);

		if (focusable !== this.state.focusable) {
			itemInfo[itemIndex].focusable = focusable;
			this.setState({
				focusable: focusable
			});
		}
	};

	return MenuItemComponent;
})(VDOM.Component);

var Submenu = /*#__PURE__*/ (function(_MenuItem) {
	_inheritsLoose(Submenu, _MenuItem);

	function Submenu() {
		return _MenuItem.apply(this, arguments) || this;
	}

	return Submenu;
})(MenuItem);

var Scroller = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(Scroller, _Container);

	function Scroller() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = Scroller.prototype;

	_proto.init = function init() {
		if (!this.vertical) this.horizontal = true; //default

		_Container.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Container$prototype$;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(args, [
				{
					scrollIntoViewSelector: undefined
				}
			])
		);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			HScrollerComponent,
			{
				widget: this,
				data: instance.data,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	return Scroller;
})(Container);
Scroller.prototype.styled = true;
Scroller.prototype.baseClass = "scroller";
var HScrollerComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(HScrollerComponent, _VDOM$Component);

	function HScrollerComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;

		_this.stopScrolling = function() {
			delete _this.doScroll;
		};

		_this.scrollLeft = function(e) {
			return _this.scroll(e, "left");
		};

		_this.scrollRight = function(e) {
			return _this.scroll(e, "right");
		};

		_this.scrollUp = function(e) {
			return _this.scroll(e, "up");
		};

		_this.scrollDown = function(e) {
			return _this.scroll(e, "down");
		};

		_this.state = {
			scrollable: false
		};
		return _this;
	}

	var _proto2 = HScrollerComponent.prototype;

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			data = _this$props.data,
			children = _this$props.children,
			widget = _this$props.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(
				data.classNames,
				CSS.state({
					scrollable: this.state.scrollable,
					horizontal: widget.horizontal,
					vertical: widget.vertical
				})
			),
			style: data.style,
			ref: function ref(el) {
				_this2.el = el;
			},
			children: [
				widget.horizontal &&
					/*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "left-arrow"),
						onMouseDown: this.scrollLeft,
						onTouchStart: this.scrollLeft,
						onMouseUp: this.stopScrolling,
						onTouchEnd: this.stopScrolling,
						children: Icon.render("drop-down", {
							className: CSS.element(baseClass, "icon")
						})
					}),
				widget.horizontal &&
					/*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "right-arrow"),
						onMouseDown: this.scrollRight,
						onTouchStart: this.scrollRight,
						onMouseUp: this.stopScrolling,
						onTouchEnd: this.stopScrolling,
						children: Icon.render("drop-down", {
							className: CSS.element(baseClass, "icon")
						})
					}),
				widget.vertical &&
					/*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "top-arrow"),
						onMouseDown: this.scrollUp,
						onTouchStart: this.scrollUp,
						onMouseUp: this.stopScrolling,
						onTouchEnd: this.stopScrolling,
						children: Icon.render("drop-down", {
							className: CSS.element(baseClass, "icon")
						})
					}),
				widget.vertical &&
					/*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "bottom-arrow"),
						onMouseDown: this.scrollDown,
						onTouchStart: this.scrollDown,
						onMouseUp: this.stopScrolling,
						onTouchEnd: this.stopScrolling,
						children: Icon.render("drop-down", {
							className: CSS.element(baseClass, "icon")
						})
					}),
				/*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "clip"),
					ref: function ref(el) {
						_this2.clip = el;
					},
					children: /*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "scroller"),
						ref: function ref(el) {
							_this2.scroller = el;
						},
						children: /*#__PURE__*/ jsx("div", {
							className: CSS.element(baseClass, "content"),
							ref: function ref(el) {
								_this2.content = el;
							},
							children: children
						})
					})
				})
			]
		});
	};

	_proto2.componentDidMount = function componentDidMount() {
		this.unsubscribeResize = ResizeManager.trackElement(this.clip, this.componentDidUpdate.bind(this));
		this.componentDidUpdate();
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		var widget = this.props.widget;
		var scrollable = false;

		if (widget.horizontal) {
			var scrollSize = this.scroller.offsetHeight - this.scroller.clientHeight;
			this.scroller.style.marginBottom = -scrollSize + "px";
			if (this.content.scrollWidth > this.clip.clientWidth) scrollable = true;
		}

		if (widget.vertical) {
			var _scrollSize = this.scroller.offsetWidth - this.scroller.clientWidth;

			this.scroller.style.marginRight = -_scrollSize + "px";
			if (this.content.scrollHeight > this.clip.clientHeight) scrollable = true;
		}

		if (scrollable != this.state.scrollable)
			this.setState({
				scrollable: scrollable
			});
		this.scrollIntoView();
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		this.unsubscribeResize();
	};

	_proto2.scroll = function scroll(e, direction) {
		var _this3 = this;

		e.stopPropagation();
		e.preventDefault();

		this.doScroll = function() {
			if (!_this3.scroller) return;

			switch (direction) {
				case "left":
					_this3.scroller.scrollLeft -= 10;
					break;

				case "right":
					_this3.scroller.scrollLeft += 10;
					break;

				case "up":
					_this3.scroller.scrollTop -= 10;
					break;

				case "down":
					_this3.scroller.scrollTop += 10;
					break;
			}

			if (_this3.doScroll) requestAnimationFrame(_this3.doScroll);
		};

		this.doScroll();
	};

	_proto2.scrollIntoView = function scrollIntoView() {
		var _this$props2 = this.props,
			data = _this$props2.data,
			widget = _this$props2.widget;
		var scrollIntoViewSelector = data.scrollIntoViewSelector;

		if (isString(scrollIntoViewSelector)) {
			var child = this.el.querySelector(scrollIntoViewSelector);
			if (child) scrollElementIntoView(child, widget.vertical, widget.horizontal);
		}
	};

	return HScrollerComponent;
})(VDOM.Component);
var HScroller = /*#__PURE__*/ (function(_Scroller) {
	_inheritsLoose(HScroller, _Scroller);

	function HScroller() {
		return _Scroller.apply(this, arguments) || this;
	}

	return HScroller;
})(Scroller);
HScroller.prototype.horizontal = true;
var VScroller = /*#__PURE__*/ (function(_Scroller2) {
	_inheritsLoose(VScroller, _Scroller2);

	function VScroller() {
		return _Scroller2.apply(this, arguments) || this;
	}

	return VScroller;
})(Scroller);
VScroller.prototype.vertical = true;

var ValidationError = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(ValidationError, _Widget);

	function ValidationError() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = ValidationError.prototype;

	_proto.checkVisible = function checkVisible(context, instance, data) {
		if (
			data.visible &&
			context.lastFieldId &&
			context.validation &&
			context.validation.errors &&
			context.validation.errors.length > 0
		) {
			var lastError = (instance.lastError = context.validation.errors[context.validation.errors.length - 1]);
			return lastError.fieldId == context.lastFieldId && lastError.visited;
		}

		return false;
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			lastError = instance.lastError;
		var c1 = instance.cache("lastErrorMessage", lastError.message);
		var c2 = instance.cache("lastErrorFieldId", lastError.fieldId);

		if (c1 || c2) {
			data.errorMessage = lastError.message;
			data.fieldId = lastError.fieldId;
			instance.markShouldUpdate(context);
		}

		_Widget.prototype.explore.call(this, context, instance);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"label",
			{
				className: data.classNames,
				htmlFor: data.fieldId,
				children: data.errorMessage
			},
			key
		);
	};

	return ValidationError;
})(Widget);
ValidationError.prototype.baseClass = "validationerror";
ValidationError.prototype.styled = true;
Widget.alias("validation-error", ValidationError);

var HelpText = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(HelpText, _HtmlElement);

	function HelpText() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	return HelpText;
})(HtmlElement);
HelpText.prototype.tag = "span";
HelpText.prototype.baseClass = "helptext";
Widget.alias("help-text", HelpText);

var Label = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(Label, _HtmlElement);

	function Label() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto = Label.prototype;

	_proto.declareData = function declareData() {
		var _HtmlElement$prototyp;

		(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
			_HtmlElement$prototyp,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					required: undefined,
					disabled: undefined,
					htmlFor: undefined
				}
			])
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				disabled: data.disabled
			}
		);
		data._disabled = data.disabled;

		_HtmlElement.prototype.prepareData.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data;
		if (!data.htmlFor) data.htmlFor = context.lastFieldId;
		data.disabled = data.stateMods.disabled = coalesce(
			context.parentStrict ? context.parentDisabled : null,
			data._disabled,
			context.parentDisabled
		);

		if (instance.cache("disabled", data.disabled)) {
			instance.markShouldUpdate(context);
			this.prepareCSS(context, instance);
		}

		_HtmlElement.prototype.explore.call(this, context, instance);
	};

	_proto.isValidHtmlAttribute = function isValidHtmlAttribute(attrName) {
		switch (attrName) {
			case "asterisk":
			case "required":
				return false;
		}

		return _HtmlElement.prototype.isValidHtmlAttribute.call(this, attrName);
	};

	_proto.attachProps = function attachProps(context, instance, props) {
		_HtmlElement.prototype.attachProps.call(this, context, instance, props);

		var data = instance.data;

		if (data.htmlFor) {
			props.htmlFor = data.htmlFor;
			if (!props.onClick)
				props.onClick = function() {
					//additional focus for LookupFields which are not input based
					var el = document.getElementById(instance.data.htmlFor);
					if (el) FocusManager.focusFirst(el);
				};
		}

		if (!props.id && data.htmlFor) props.id = data.htmlFor + "-label";

		if (this.asterisk && data.required) {
			if (!isArray(props.children)) props.children = [props.children];
			props.children.push(" ");
			props.children.push(
				/*#__PURE__*/ jsx(
					"span",
					{
						className: this.CSS.element(this.baseClass, "asterisk"),
						children: "*"
					},
					"asterisk"
				)
			);
		}
	};

	return Label;
})(HtmlElement);
Label.prototype.baseClass = "label";
Label.prototype.tag = "label";
Label.prototype.asterisk = false;

var Field = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(Field, _PureContainer);

	function Field() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = Field.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		(_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[
				this,
				{
					label: undefined,
					labelWidth: undefined,
					mode: undefined,
					viewMode: undefined,
					id: undefined,
					error: undefined,
					inputStyle: {
						structured: true
					},
					inputClass: {
						structured: true
					},
					inputAttrs: {
						structured: true
					},
					emptyText: undefined,
					visited: undefined,
					autoFocus: undefined,
					tabOnEnterKey: undefined,
					tabIndex: undefined,
					validationParams: {
						structured: true
					}
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (this.validationMode == "tooltip" && isUndefined(this.errorTooltip)) {
			this.errorTooltip = _objectSpread2(
				{
					text: {
						bind: "$error"
					},
					mod: "error"
				},
				this.errorTooltip
			);
		}

		if (isUndefined(this.help)) {
			switch (this.validationMode) {
				case "help":
				case "help-inline":
					this.help = ValidationError;
					break;

				case "help-block":
					this.help = {
						type: ValidationError,
						mod: "block"
					};
					break;
			}
		}

		if (this.help != null) {
			var helpConfig = {};
			if (this.help.isComponentType) helpConfig = this.help;
			else if (isSelector(this.help)) helpConfig.text = this.help;
			else Object.assign(helpConfig, this.help);
			this.help = HelpText.create(helpConfig);
		}

		if (this.label != null) {
			var labelConfig = {
				mod: this.mod,
				disabled: this.disabled,
				required: this.required,
				asterisk: this.asterisk,
				style: this.labelStyle,
				class: this.labelClass
			};
			if (this.label.isComponentType) labelConfig = this.label;
			else if (isSelector(this.label)) labelConfig.text = this.label;
			else Object.assign(labelConfig, this.label);
			this.label = Label.create(labelConfig);
		}

		this.inputStyle = parseStyle(this.inputStyle);

		_PureContainer.prototype.init.call(this);
	};

	_proto.initComponents = function initComponents(context, instance) {
		var _PureContainer$protot2;

		return (_PureContainer$protot2 = _PureContainer.prototype.initComponents).call.apply(
			_PureContainer$protot2,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					label: this.label,
					help: this.help
				}
			])
		);
	};

	_proto.initState = function initState(context, instance) {
		instance.state = {
			inputError: false,
			visited: this.visited === true
		};
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data,
			state = instance.state;
		if (!data.id) data.id = "fld-" + instance.id;
		data._disabled = data.disabled;
		data._readOnly = data.readOnly;
		data._viewMode = data.mode === "view" || data.viewMode;
		data._tabOnEnterKey = data.tabOnEnterKey;
		instance.parentDisabled = context.parentDisabled;
		instance.parentReadOnly = context.parentReadOnly;
		instance.parentViewMode = context.parentViewMode;
		instance.parentTabOnEnterKey = context.parentTabOnEnterKey;
		instance.parentVisited = context.parentVisited;
		if (typeof data.enabled !== "undefined") data._disabled = !data.enabled;
		this.disableOrValidate(context, instance);
		data.inputStyle = parseStyle(data.inputStyle);
		if (this.labelPlacement && this.label) data.mod = [data.mod, "label-placement-" + this.labelPlacement];
		if (this.helpPlacement && this.help) data.mod = [data.mod, "help-placement-" + this.helpPlacement];
		data.empty = this.isEmpty(data);

		_PureContainer.prototype.prepareData.apply(this, arguments);
	};

	_proto.disableOrValidate = function disableOrValidate(context, instance) {
		var data = instance.data,
			state = instance.state; //if the parent is strict and sets some flag to true, it is not allowed to overrule that flag by field settings

		data.disabled = coalesce(
			context.parentStrict ? context.parentDisabled : null,
			data._disabled,
			context.parentDisabled
		);
		data.readOnly = coalesce(
			context.parentStrict ? context.parentReadOnly : null,
			data._readOnly,
			context.parentReadOnly
		);
		data.viewMode = coalesce(
			context.parentStrict ? context.parentViewMode : null,
			data._viewMode,
			context.parentViewMode
		);
		data.tabOnEnterKey = coalesce(
			context.parentStrict ? context.parentTabOnEnterKey : null,
			data._tabOnEnterKey,
			context.parentTabOnEnterKey
		);
		data.visited = coalesce(context.parentStrict ? context.parentVisited : null, data.visited, context.parentVisited);
		if (!data.error && !data.disabled && !data.viewMode) this.validate(context, instance);

		if (data.visited && !state.visited) {
			//feels hacky but it should be ok since we're in the middle of a new render cycle
			state.visited = true;
		}

		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				disabled: data.disabled,
				"edit-mode": !data.viewMode,
				"view-mode": data.viewMode
			}
		);
	};

	_proto.explore = function explore(context, instance) {
		var data = instance.data,
			state = instance.state;
		instance.parentDisabled = context.parentDisabled;
		instance.parentReadOnly = context.parentReadOnly;
		instance.parentViewMode = context.parentViewMode;
		instance.parentTabOnEnterKey = context.parentTabOnEnterKey;
		instance.parentVisited = context.parentVisited;

		if (
			instance.cache("parentDisabled", context.parentDisabled) ||
			instance.cache("parentReadOnly", context.parentReadOnly) ||
			instance.cache("parentViewMode", context.parentViewMode) ||
			instance.cache("parentTabOnEnterKey", context.parentTabOnEnterKey) ||
			instance.cache("parentVisited", context.parentVisited)
		) {
			instance.markShouldUpdate(context);
			this.disableOrValidate(context, instance);
			this.prepareCSS(context, instance);
		}

		if (!context.validation)
			context.validation = {
				errors: []
			};

		if (data.error) {
			context.validation.errors.push({
				fieldId: data.id,
				message: data.error,
				visited: state.visited,
				type: "error"
			});
		}

		context.push("lastFieldId", data.id);

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("lastFieldId");
	};

	_proto.isEmpty = function isEmpty(data) {
		return data.value == null || data.value === this.emptyValue;
	};

	_proto.validateRequired = function validateRequired(context, instance) {
		var data = instance.data;
		if (this.isEmpty(data)) return this.requiredText;
	};

	_proto.validate = function validate(context, instance) {
		var _this = this;

		var data = instance.data,
			state = instance.state;
		state = state || {};
		var empty = this.isEmpty(data);

		if (!data.error) {
			if (state.inputError) data.error = state.inputError;
			else if (state.validating && !empty) data.error = this.validatingText;
			else if (
				state.validationError &&
				data.value === state.lastValidatedValue &&
				shallowEquals(data.validationParams, state.lastValidationParams)
			)
				data.error = state.validationError;
			else if (data.required) data.error = this.validateRequired(context, instance);
		}

		if (
			!empty &&
			!state.validating &&
			!data.error &&
			this.onValidate &&
			(!state.previouslyValidated ||
				data.value != state.lastValidatedValue ||
				data.validationParams != state.lastValidationParams)
		) {
			var result = instance.invoke("onValidate", data.value, instance, data.validationParams);

			if (isPromise(result)) {
				data.error = this.validatingText;
				instance.setState({
					validating: true,
					lastValidatedValue: data.value,
					previouslyValidated: true,
					lastValidationParams: data.validationParams
				});
				result
					.then(function(r) {
						var data = instance.data,
							state = instance.state;
						var error =
							data.value == state.lastValidatedValue && shallowEquals(data.validationParams, state.lastValidationParams)
								? r
								: _this.validatingText; //parameters changed, this will be revalidated

						instance.setState({
							validating: false,
							validationError: error
						});
					})
					["catch"](function(e) {
						instance.setState({
							validating: false,
							validationError: _this.validationExceptionText
						});
						if (_this.onValidationException) instance.invoke("onValidationException", e, instance);
						else {
							Console.warn("Unhandled validation exception:", e);
						}
					});
			} else {
				data.error = result;
			}
		}
	};

	_proto.renderLabel = function renderLabel(context, instance, key) {
		if (instance.components.label) return getContent(instance.components.label.vdom);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		throw new Error("Not implemented.");
	};

	_proto.renderHelp = function renderHelp(context, instance, key) {
		if (instance.components.help) return getContent(instance.components.help.render(context, key));
	};

	_proto.formatValue = function formatValue(context, _ref) {
		var data = _ref.data;
		return data.text || data.value;
	};

	_proto.renderValue = function renderValue(context, instance, key) {
		var text = this.formatValue(context, instance);

		if (text) {
			return /*#__PURE__*/ jsx(
				"span",
				{
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
					},
					children: text
				},
				key
			);
		}
	};

	_proto.renderContent = function renderContent(context, instance, key) {
		var content = this.renderValue.apply(this, arguments) || this.renderEmptyText.apply(this, arguments);
		return this.renderWrap(context, instance, key, content);
	};

	_proto.renderWrap = function renderWrap(context, instance, key, content) {
		var data = instance.data;
		var interactive = !data.viewMode && !data.disabled;
		return /*#__PURE__*/ jsxs(
			"div",
			{
				className: data.classNames,
				style: data.style,
				onMouseDown: interactive ? stopPropagation : null,
				onTouchStart: interactive ? stopPropagation : null,
				children: [content, this.labelPlacement && this.renderLabel(context, instance, "label")]
			},
			key
		);
	};

	_proto.renderEmptyText = function renderEmptyText(context, _ref2, key) {
		var data = _ref2.data;
		return /*#__PURE__*/ jsx(
			"span",
			{
				className: this.CSS.element(this.baseClass, "empty-text"),
				children:
					data.emptyText ||
					/*#__PURE__*/ jsx("span", {
						children: "\xA0"
					})
			},
			key
		);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		var content = !data.viewMode
			? this.renderInput(context, instance, key)
			: this.renderContent(context, instance, key);
		return {
			label: !this.labelPlacement && this.renderLabel(context, instance, key),
			content: content,
			helpSpacer: this.helpSpacer && instance.components.help ? " " : null,
			help: !this.helpPlacement && this.renderHelp(context, instance, key)
		};
	};

	_proto.handleKeyDown = function handleKeyDown(e, instance) {
		if (this.onKeyDown && instance.invoke("onKeyDown", e, instance) === false) return false;

		if (instance.data.tabOnEnterKey && e.keyCode === 13) {
			var target = e.target;
			setTimeout(function() {
				if (!instance.state.inputError) FocusManager.focusNext(target);
			}, 10);
		}
	};

	return Field;
})(PureContainer);
Field.prototype.validationMode = "tooltip";
Field.prototype.suppressErrorsUntilVisited = false;
Field.prototype.requiredText = "This field is required.";
Field.prototype.autoFocus = false;
Field.prototype.asterisk = false;
Field.prototype.validatingText = "Validation is in progress...";
Field.prototype.validationExceptionText = "Something went wrong during input validation. Check log for more details.";
Field.prototype.helpSpacer = true;
Field.prototype.trackFocus = false; //add cxs-focus on parent element

Field.prototype.labelPlacement = false;
Field.prototype.helpPlacement = false;
Field.prototype.emptyValue = null;
Field.prototype.styled = true; //These flags are inheritable and should not be set to false
//Field.prototype.visited = null;
//Field.prototype.disabled = null;
//Field.prototype.readOnly = null;
//Field.prototype.viewMode = null;

Localization.registerPrototype("cx/widgets/Field", Field);
function getFieldTooltip(instance) {
	var widget = instance.widget,
		data = instance.data,
		state = instance.state;
	if (widget.errorTooltip && data.error && (!state || state.visited || !widget.suppressErrorsUntilVisited))
		return [
			instance,
			widget.errorTooltip,
			{
				data: {
					$error: data.error
				}
			}
		];
	return [instance, widget.tooltip];
}

var TextField = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(TextField, _Field);

	function TextField() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = TextField.prototype;

	_proto.init = function init() {
		if (typeof this.hideClear !== "undefined") this.showClear = !this.hideClear;
		if (this.alwaysShowClear) this.showClear = true;

		_Field.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: this.emptyValue,
					disabled: undefined,
					readOnly: undefined,
					enabled: undefined,
					placeholder: undefined,
					required: undefined,
					minLength: undefined,
					maxLength: undefined,
					icon: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			Input,
			{
				instance: instance,
				data: instance.data,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			},
			key
		);
	};

	_proto.validate = function validate(context, instance) {
		_Field.prototype.validate.call(this, context, instance);

		var data = instance.data;

		if (!data.error && data.value) {
			if (this.validationRegExp) this.validationRegExp.lastIndex = 0;
			if (this.validationRegExp && !this.validationRegExp.test(data.value)) data.error = this.validationErrorText;
			else if (typeof data.value === "string" && data.minLength != null && data.value.length < data.minLength)
				data.error = StringTemplate.format(this.minLengthValidationErrorText, data.minLength, data.value.length);
			else if (typeof data.value === "string" && data.maxLength != null && data.value.length > data.maxLength)
				data.error = StringTemplate.format(this.maxLengthValidationErrorText, data.maxLength, data.value.length);
		}
	};

	return TextField;
})(Field);
TextField.prototype.baseClass = "textfield";
TextField.prototype.reactOn = "change input blur";
TextField.prototype.inputType = "text";
TextField.prototype.validationErrorText = "The entered value is not valid.";
TextField.prototype.minLengthValidationErrorText = "Enter {[{0}-{1}]} more character(s).";
TextField.prototype.maxLengthValidationErrorText = "Use {0} characters or fewer.";
TextField.prototype.suppressErrorsUntilVisited = true;
TextField.prototype.icon = null;
TextField.prototype.showClear = false;
TextField.prototype.alwaysShowClear = false;
TextField.prototype.keyboardShortcut = false;
Localization.registerPrototype("cx/widgets/TextField", TextField);

var Input = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(Input, _VDOM$Component);

	function Input(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			focus: false
		};
		return _this;
	}

	var _proto2 = Input.prototype;

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			data = _this$props.data,
			label = _this$props.label,
			help = _this$props.help;
		var widget = instance.widget,
			state = instance.state;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;

		var icon =
			data.icon &&
			/*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "left-icon"),
				onMouseDown: preventDefault,
				onClick: function onClick(e) {
					return _this2.onChange(e, "enter");
				},
				children: Icon.render(data.icon, {
					className: CSS.element(baseClass, "icon")
				})
			});

		var insideButton;

		if (
			widget.showClear &&
			!data.empty &&
			!data.readOnly &&
			!data.disabled &&
			(widget.alwaysShowClear || !data.required)
		) {
			insideButton = /*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "clear"),
				onMouseDown: function onMouseDown(e) {
					return e.preventDefault();
				},
				onClick: function onClick(e) {
					return _this2.onClearClick(e);
				},
				children: /*#__PURE__*/ jsx(ClearIcon, {
					className: CSS.element(baseClass, "icon")
				})
			});
		}

		var empty = this.input ? !this.input.value : data.empty;
		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(
				data.classNames,
				CSS.state({
					visited: state.visited,
					focus: this.state.focus,
					icon: !!icon,
					clear: insideButton != null,
					empty: empty && !data.placeholder,
					error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
				})
			),
			style: data.style,
			onMouseDown: stopPropagation,
			onTouchStart: stopPropagation,
			children: [
				/*#__PURE__*/ jsx(
					"input",
					_objectSpread2(
						_objectSpread2(
							{
								ref: function ref(el) {
									_this2.input = el;
								},
								className: CSS.expand(CSS.element(baseClass, "input"), data.inputClass),
								defaultValue: data.value,
								id: data.id,
								style: data.inputStyle,
								type: widget.inputType,
								disabled: data.disabled,
								readOnly: data.readOnly,
								tabIndex: data.tabIndex,
								placeholder: data.placeholder
							},
							data.inputAttrs
						),
						{},
						{
							onMouseMove: this.onMouseMove.bind(this),
							onMouseLeave: this.onMouseLeave.bind(this),
							onInput: function onInput(e) {
								return _this2.onChange(e, "input");
							},
							onChange: function onChange(e) {
								return _this2.onChange(e, "change");
							},
							onKeyDown: this.onKeyDown.bind(this),
							onFocus: this.onFocus.bind(this),
							onBlur: this.onBlur.bind(this),
							onClick: stopPropagation
						}
					)
				),
				insideButton,
				icon,
				label,
				help
			]
		});
	};

	_proto2.onFocus = function onFocus() {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data;
		var widget = instance.widget;

		if (widget.trackFocus) {
			this.setState({
				focus: true
			});
			instance.set("focused", true);
		}

		if (data.error && data.value)
			instance.setState({
				visited: true
			});
	};

	_proto2.onBlur = function onBlur(e) {
		if (this.state.focus) {
			this.setState({
				focus: false
			});
			this.props.instance.set("focused", false);
		}

		this.onChange(e, "blur");
	};

	_proto2.onClearClick = function onClearClick(e) {
		this.props.instance.set("value", this.props.instance.widget.emptyValue, {
			immediate: true
		});
	};

	_proto2.onMouseMove = function onMouseMove(e) {
		tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(this.props.instance)));
	};

	_proto2.onMouseLeave = function onMouseLeave(e) {
		tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(this.props.instance)));
	};

	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
		autoFocus(this.input, this);
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		autoFocus(this.input, this);
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.enter:
				this.onChange(e, "enter");
				break;

			case KeyCode.left:
			case KeyCode.right:
				e.stopPropagation();
				break;
		}
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var data = props.data; //the second check is required for debouncing, sometimes the value in the store lags after the input
		//and update may be caused by some other property, i.e. visited

		if (data.value != this.input.value && data.value != this.props.data.value) this.input.value = data.value || "";
		tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(props.instance)));
	};

	_proto2.onChange = function onChange(e, change) {
		var _this$props3 = this.props,
			instance = _this$props3.instance,
			data = _this$props3.data;
		var immediate = change == "blur" || change == "enter";

		if (immediate) {
			instance.setState({
				visited: true
			});
		}

		var widget = instance.widget;

		if (widget.reactOn.indexOf(change) != -1) {
			var text = e.target.value;

			if (data.maxLength != null && text.length > data.maxLength) {
				text = text.substring(0, data.maxLength);
				this.input.value = text;
			}

			var value = text || widget.emptyValue;

			if (
				!instance.set("value", value, {
					immediate: immediate
				})
			) {
				if (text != this.input.value) this.input.value = text;
			} else {
				if (value)
					instance.setState({
						visited: true
					});
			}
		}
	};

	return Input;
})(VDOM.Component);

Widget.alias("textfield", TextField);

var SquareIcon = registerIcon(
	"square",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 64 64",
					children: /*#__PURE__*/ jsx("rect", {
						x: "12",
						y: "12",
						width: "40",
						height: "40",
						fill: "currentColor"
					})
				}
			)
		);
	},
	true
);

var Checkbox = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(Checkbox, _Field);

	function Checkbox() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = Checkbox.prototype;

	_proto.init = function init() {
		if (this.checked) this.value = this.checked;

		_Field.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: !this.indeterminate ? false : undefined,
					text: undefined,
					readOnly: undefined,
					disabled: undefined,
					enabled: undefined,
					required: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.renderWrap = function renderWrap(context, instance, key, content) {
		var _this = this;

		var data = instance.data;
		return /*#__PURE__*/ jsxs(
			"label",
			{
				className: data.classNames,
				onMouseDown: stopPropagation,
				onMouseMove: function onMouseMove(e) {
					return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
				},
				onMouseLeave: function onMouseLeave(e) {
					return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
				},
				onClick: function onClick(e) {
					_this.handleClick(e, instance);
				},
				style: data.style,
				children: [content, this.labelPlacement && getContent(this.renderLabel(context, instance, "label"))]
			},
			key
		);
	};

	_proto.validateRequired = function validateRequired(context, instance) {
		var data = instance.data;
		if (!data.value) return this.requiredText;
	};

	_proto.renderNativeCheck = function renderNativeCheck(context, instance) {
		var _this2 = this;

		var CSS = this.CSS,
			baseClass = this.baseClass;
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"input",
			_objectSpread2(
				_objectSpread2(
					{
						className: CSS.element(baseClass, "checkbox"),
						id: data.id,
						type: "checkbox",
						checked: data.value || false,
						disabled: data.disabled
					},
					data.inputAttrs
				),
				{},
				{
					onClick: stopPropagation,
					onChange: function onChange(e) {
						_this2.handleChange(e, instance);
					}
				}
			),
			"input"
		);
	};

	_proto.renderCheck = function renderCheck(context, instance) {
		return /*#__PURE__*/ jsx(
			CheckboxCmp,
			{
				instance: instance,
				data: instance.data
			},
			"check"
		);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		var data = instance.data;
		var text = data.text || this.renderChildren(context, instance);
		var CSS = this.CSS,
			baseClass = this.baseClass;
		return this.renderWrap(context, instance, key, [
			this["native"] ? this.renderNativeCheck(context, instance) : this.renderCheck(context, instance),
			text
				? /*#__PURE__*/ jsx(
						"div",
						{
							className: CSS.element(baseClass, "text"),
							children: text
						},
						"text"
				  )
				: /*#__PURE__*/ jsx(
						"span",
						{
							className: CSS.element(baseClass, "baseline"),
							children: "\xA0"
						},
						"baseline"
				  )
		]);
	};

	_proto.formatValue = function formatValue(context, instance) {
		var data = instance.data;
		return data.value && (data.text || this.renderChildren(context, instance));
	};

	_proto.handleClick = function handleClick(e, instance) {
		if (this["native"]) e.stopPropagation();
		else {
			var el = document.getElementById(instance.data.id);
			if (el) el.focus();

			if (!instance.data.viewMode) {
				e.preventDefault();
				e.stopPropagation();
				this.handleChange(e, instance, !instance.data.value);
			}
		}
	};

	_proto.handleChange = function handleChange(e, instance, checked) {
		var data = instance.data;
		if (data.readOnly || data.disabled || data.viewMode) return;
		instance.set("value", checked != null ? checked : e.target.checked);
	};

	return Checkbox;
})(Field);
Checkbox.prototype.baseClass = "checkbox";
Checkbox.prototype["native"] = false;
Checkbox.prototype.indeterminate = false;
Checkbox.prototype.unfocusable = false;
Widget.alias("checkbox", Checkbox);

var CheckboxCmp = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(CheckboxCmp, _VDOM$Component);

	function CheckboxCmp(props) {
		var _this3;

		_this3 = _VDOM$Component.call(this, props) || this;
		_this3.state = {
			value: props.data.value
		};
		return _this3;
	}

	var _proto2 = CheckboxCmp.prototype;

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		this.setState({
			value: props.data.value
		});
	};

	_proto2.render = function render() {
		var _this$props = this.props,
			instance = _this$props.instance,
			data = _this$props.data;
		var widget = instance.widget;
		var baseClass = widget.baseClass,
			CSS = widget.CSS;
		var check = false;
		if (this.state.value == null && widget.indeterminate) check = "indeterminate";
		else if (this.state.value) check = "check";
		return /*#__PURE__*/ jsxs(
			"span",
			{
				tabIndex: widget.unfocusable || data.disabled ? null : data.tabIndex || 0,
				className: CSS.element(baseClass, "input", {
					checked: check
				}),
				style: CSS.parseStyle(data.inputStyle),
				id: data.id,
				onClick: this.onClick.bind(this),
				onKeyDown: this.onKeyDown.bind(this),
				children: [
					check == "check" &&
						/*#__PURE__*/ jsx(CheckIcon, {
							className: CSS.element(baseClass, "input-check")
						}),
					check == "indeterminate" &&
						/*#__PURE__*/ jsx(SquareIcon, {
							className: CSS.element(baseClass, "input-check")
						})
				]
			},
			"check"
		);
	};

	_proto2.onClick = function onClick(e) {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data;
		var widget = instance.widget;

		if (!data.disabled && !data.readOnly) {
			e.stopPropagation();
			e.preventDefault();
			this.setState({
				value: !this.state.value
			});
			widget.handleChange(e, instance, !this.state.value);
		}
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.space:
				this.onClick(e);
				break;
		}
	};

	return CheckboxCmp;
})(VDOM.Component);

var Radio = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(Radio, _Field);

	function Radio() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = Radio.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: undefined,
					selection: undefined,
					option: undefined,
					disabled: undefined,
					enabled: undefined,
					readOnly: undefined,
					required: undefined,
					text: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (this.selection) this.value = this.selection;

		_Field.prototype.init.call(this);
	};

	_proto.formatValue = function formatValue(context, _ref) {
		var data = _ref.data;
		return data.text;
	};

	_proto.prepareData = function prepareData(context, instance) {
		_Field.prototype.prepareData.apply(this, arguments);

		var data = instance.data;
		data.checked = data.value === data.option;
		if (this["default"] && isUndefined(data.value)) instance.set("value", data.option);
	};

	_proto.renderValue = function renderValue(context, _ref2) {
		var data = _ref2.data;
		if (data.value === data.option) return _Field.prototype.renderValue.apply(this, arguments);
		return null;
	};

	_proto.renderWrap = function renderWrap(context, instance, key, content) {
		var _this = this;

		var data = instance.data;
		return /*#__PURE__*/ jsxs(
			"label",
			{
				className: data.classNames,
				style: data.style,
				onMouseDown: stopPropagation,
				onTouchStart: stopPropagation,
				onMouseMove: function onMouseMove(e) {
					return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
				},
				onMouseLeave: function onMouseLeave(e) {
					return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
				},
				onClick: function onClick(e) {
					_this.handleClick(e, instance);
				},
				htmlFor: data.id,
				children: [content, this.labelPlacement && getContent(this.renderLabel(context, instance, "label"))]
			},
			key
		);
	};

	_proto.renderNativeCheck = function renderNativeCheck(context, instance) {
		var _this2 = this;

		var CSS = this.CSS,
			baseClass = this.baseClass;
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"input",
			_objectSpread2(
				_objectSpread2(
					{
						className: CSS.element(baseClass, "radio"),
						id: data.id,
						type: "radio",
						checked: data.checked,
						disabled: data.disabled
					},
					data.inputAttrs
				),
				{},
				{
					onClick: stopPropagation,
					onChange: function onChange(e) {
						_this2.handleChange(e, instance);
					}
				}
			),
			"input"
		);
	};

	_proto.renderCheck = function renderCheck(context, instance) {
		return /*#__PURE__*/ jsx(
			RadioCmp,
			{
				instance: instance,
				data: instance.data
			},
			"check"
		);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		var data = instance.data;
		var text = data.text || this.renderChildren(context, instance);
		var CSS = this.CSS,
			baseClass = this.baseClass;
		return this.renderWrap(context, instance, key, [
			this["native"] ? this.renderNativeCheck(context, instance) : this.renderCheck(context, instance),
			text
				? /*#__PURE__*/ jsx(
						"div",
						{
							className: CSS.element(baseClass, "text"),
							children: text
						},
						"text"
				  )
				: /*#__PURE__*/ jsx(
						"span",
						{
							className: CSS.element(baseClass, "baseline"),
							children: "\xA0"
						},
						"baseline"
				  )
		]);
	};

	_proto.handleClick = function handleClick(e, instance) {
		if (this["native"]) e.stopPropagation();
		else {
			var el = document.getElementById(instance.data.id);
			if (el) el.focus();
			e.preventDefault();
			this.handleChange(e, instance);
		}
	};

	_proto.handleChange = function handleChange(e, instance) {
		var data = instance.data;
		if (data.disabled || data.readOnly || data.viewMode) return;
		instance.set("value", data.option);
	};

	return Radio;
})(Field);
Radio.prototype.baseClass = "radio";
Radio.prototype["native"] = false;
Radio.prototype["default"] = false;
Widget.alias("radio", Radio);

var RadioCmp = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(RadioCmp, _VDOM$Component);

	function RadioCmp(props) {
		var _this3;

		_this3 = _VDOM$Component.call(this, props) || this;
		_this3.state = {
			value: props.data.checked
		};
		return _this3;
	}

	var _proto2 = RadioCmp.prototype;

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		this.setState({
			value: props.data.checked
		});
	};

	_proto2.render = function render() {
		var _this$props = this.props,
			instance = _this$props.instance,
			data = _this$props.data;
		var widget = instance.widget;
		var baseClass = widget.baseClass,
			CSS = widget.CSS;
		return /*#__PURE__*/ jsx(
			"span",
			{
				tabIndex: data.disabled ? null : data.tabIndex || 0,
				className: CSS.element(baseClass, "input", {
					checked: this.state.value
				}),
				style: CSS.parseStyle(data.inputStyle),
				id: data.id,
				onClick: this.onClick.bind(this),
				onKeyDown: this.onKeyDown.bind(this)
			},
			"check"
		);
	};

	_proto2.onClick = function onClick(e) {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data;
		var widget = instance.widget;

		if (!data.disabled && !data.readOnly) {
			e.stopPropagation();
			e.preventDefault();
			widget.handleChange(e, instance);
		}
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.space:
				this.onClick(e);
				break;
		}
	};

	return RadioCmp;
})(VDOM.Component);

var Select = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(Select, _Field);

	function Select() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = Select.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: undefined,
					disabled: undefined,
					enabled: undefined,
					required: undefined,
					placeholder: undefined,
					icon: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
		if (this.alwaysShowClear) this.showClear = true;

		_Field.prototype.init.call(this);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		var _this = this;

		return /*#__PURE__*/ jsx(
			SelectComponent,
			{
				instance: instance,
				multiple: this.multiple,
				select: function select(v) {
					return _this.select(v, instance);
				},
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help")),
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	_proto.convert = function convert(value) {
		if (value == this.nullString) return null;
		if (value == "true") return true;
		if (value == "false") return false;
		if (value.match(/^\d+(\.\d+)?$/)) return Number(value);
		return value;
	};

	_proto.select = function select(value, instance) {
		if (this.convertValues && value != null) value = this.convert(value);
		instance.set("value", value);
	};

	_proto.add = function add(item) {
		if (isString(item)) return;

		_Field.prototype.add.call(this, item);
	};

	return Select;
})(Field);
Select.prototype.baseClass = "select";
Select.prototype.multiple = false;
Select.prototype.convertValues = true;
Select.prototype.nullString = "";
Select.prototype.suppressErrorsUntilVisited = true;
Select.prototype.showClear = true;
Select.prototype.alwaysShowClear = false;
Select.prototype.icon = null;
Widget.alias("select", Select);
Localization.registerPrototype("cx/widgets/Select", Select);

var SelectComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(SelectComponent, _VDOM$Component);

	function SelectComponent(props) {
		var _this2;

		_this2 = _VDOM$Component.call(this, props) || this;
		_this2.state = {
			visited: false,
			focus: false
		};
		return _this2;
	}

	var _proto2 = SelectComponent.prototype;

	_proto2.render = function render() {
		var _this3 = this;

		var _this$props = this.props,
			multiple = _this$props.multiple,
			select = _this$props.select,
			instance = _this$props.instance,
			label = _this$props.label,
			help = _this$props.help;
		var data = instance.data,
			widget = instance.widget,
			state = instance.state;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;

		var icon =
			data.icon &&
			/*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "left-icon"),
				children: Icon.render(data.icon, {
					className: CSS.element(baseClass, "icon")
				})
			});

		var insideButton,
			readOnly = data.disabled || data.readOnly;

		if (
			widget.showClear &&
			!readOnly &&
			!this.props.multiple &&
			(widget.alwaysShowClear || !data.required) &&
			data.placeholder &&
			!data.empty
		) {
			insideButton = /*#__PURE__*/ jsx("div", {
				onMouseDown: preventDefault,
				onClick: function onClick(e) {
					return _this3.onClearClick(e);
				},
				className: CSS.element(baseClass, "clear"),
				children: /*#__PURE__*/ jsx(ClearIcon, {
					className: CSS.element(baseClass, "icon")
				})
			});
		} else {
			insideButton = /*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "tool"),
				children: /*#__PURE__*/ jsx(DropdownIcon, {
					className: CSS.element(baseClass, "icon")
				})
			});
		}

		var placeholder;

		if (data.placeholder) {
			placeholder = /*#__PURE__*/ jsx("option", {
				value: widget.nullString,
				className: CSS.element(baseClass, "placeholder"),
				disabled: true,
				hidden: true,
				children: data.placeholder
			});
		}

		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(
				data.classNames,
				CSS.state({
					visited: state.visited,
					icon: data.icon,
					focus: this.state.focus,
					error: state.visited && data.error,
					empty: data.empty && !data.placeholder
				})
			),
			style: data.style,
			onMouseDown: stopPropagation,
			onTouchStart: stopPropagation,
			children: [
				/*#__PURE__*/ jsxs(
					"select",
					_objectSpread2(
						_objectSpread2(
							{
								id: data.id,
								ref: function ref(el) {
									_this3.select = el;
								},
								className: CSS.expand(CSS.element(baseClass, "select"), data.inputClass),
								style: data.inputStyle,
								value: data.value == null ? widget.nullString : String(data.value),
								multiple: multiple,
								disabled: data.disabled,
								tabIndex: data.tabIndex
							},
							data.inputAttrs
						),
						{},
						{
							onBlur: this.onBlur.bind(this),
							onFocus: function onFocus(e) {
								return _this3.onFocus();
							},
							onKeyDown: this.onKeyDown.bind(this),
							onChange: function onChange(e) {
								e.preventDefault();
								select(e.target.value);
							},
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
							},
							children: [placeholder, this.props.children]
						}
					)
				),
				insideButton,
				icon,
				label,
				help
			]
		});
	};

	_proto2.onBlur = function onBlur() {
		this.props.instance.setState({
			visited: true
		});
		if (this.state.focus)
			this.setState({
				focus: false
			});
	};

	_proto2.onFocus = function onFocus() {
		var instance = this.props.instance;
		var widget = instance.widget;

		if (widget.trackFocus) {
			this.setState({
				focus: true
			});
		}
	};

	_proto2.onClearClick = function onClearClick(e) {
		e.preventDefault();
		e.stopPropagation();
		var instance = this.props.instance;
		var widget = instance.widget;
		instance.set("value", widget.emptyValue);
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		switch (e.keyCode) {
			case KeyCode.up:
			case KeyCode.down:
				e.stopPropagation();
				break;
		}
	};

	_proto2.componentDidMount = function componentDidMount() {
		var select = this.props.select;
		select(this.select.value);
		tooltipParentDidMount.apply(void 0, [this.select].concat(getFieldTooltip(this.props.instance)));
		autoFocus(this.select, this);
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		autoFocus(this.select, this);
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		tooltipParentWillReceiveProps.apply(void 0, [this.select].concat(getFieldTooltip(props.instance)));
	};

	return SelectComponent;
})(VDOM.Component);

var Option = /*#__PURE__*/ (function(_HtmlElement) {
	_inheritsLoose(Option, _HtmlElement);

	function Option() {
		return _HtmlElement.apply(this, arguments) || this;
	}

	var _proto3 = Option.prototype;

	_proto3.declareData = function declareData() {
		var _HtmlElement$prototyp;

		(_HtmlElement$prototyp = _HtmlElement.prototype.declareData).call.apply(
			_HtmlElement$prototyp,
			[
				this,
				{
					value: undefined,
					disabled: undefined,
					enabled: undefined,
					selected: undefined,
					text: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto3.prepareData = function prepareData(context, _ref) {
		var data = _ref.data;

		_HtmlElement.prototype.prepareData.apply(this, arguments);

		if (!data.empty) data.value = data.value.toString();
	};

	_proto3.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"option",
			{
				value: data.value,
				children: data.text || this.renderChildren(context, instance)
			},
			key
		);
	};

	return Option;
})(HtmlElement);
Widget.alias("option", Option);

var ForwardIcon = registerIcon(
	"forward",
	function(props) {
		return /*#__PURE__*/ jsxs(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 20 20",
					children: [
						/*#__PURE__*/ jsx("path", {
							fill: "currentColor",
							strokeWidth: "0",
							stroke: "currentColor",
							d: "M10.15 15.5L14.5 10l-4.33-5.47-.65.47 3.98 5-4 5z"
						}),
						/*#__PURE__*/ jsx("path", {
							fill: "currentColor",
							strokeWidth: "0",
							stroke: "currentColor",
							d: "M6.15 15.5L10.5 10 6.17 4.53 5.52 5l3.98 5-4 5z"
						})
					]
				}
			)
		);
	},
	true
);

var Calendar = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(Calendar, _Field);

	function Calendar() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = Calendar.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: undefined,
					refDate: undefined,
					disabled: undefined,
					enabled: undefined,
					minValue: undefined,
					minExclusive: undefined,
					maxValue: undefined,
					maxExclusive: undefined,
					focusable: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (this.unfocusable) this.focusable = false;

		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, _ref) {
		var data = _ref.data;
		data.stateMods = {
			disabled: data.disabled
		};

		if (data.value) {
			var d = new Date(data.value);

			if (!isNaN(d.getTime())) {
				data.date = zeroTime(d);
			}
		}

		if (data.refDate) data.refDate = zeroTime(new Date(data.refDate));
		if (data.maxValue) data.maxValue = zeroTime(new Date(data.maxValue));
		if (data.minValue) data.minValue = zeroTime(new Date(data.minValue));

		_Field.prototype.prepareData.apply(this, arguments);
	};

	_proto.validate = function validate(context, instance) {
		_Field.prototype.validate.call(this, context, instance);

		var data = instance.data,
			widget = instance.widget;

		if (!data.error && data.date) {
			var d;

			if (data.maxValue) {
				d = dateDiff(data.date, data.maxValue);
				if (d > 0) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
				else if (d == 0 && data.maxExclusive)
					data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
			}

			if (data.minValue) {
				d = dateDiff(data.date, data.minValue);
				if (d < 0) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
				else if (d == 0 && data.minExclusive)
					data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
			}

			if (widget.disabledDaysOfWeek) {
				if (widget.disabledDaysOfWeek.includes(data.date.getDay())) data.error = this.disabledDaysOfWeekErrorText;
			}
		}
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		var _this = this;

		return /*#__PURE__*/ jsx(
			CalendarCmp,
			{
				instance: instance,
				handleSelect: function handleSelect(e, date) {
					return _this.handleSelect(e, instance, date);
				}
			},
			key
		);
	};

	_proto.handleSelect = function handleSelect(e, instance, date) {
		var store = instance.store,
			data = instance.data,
			widget = instance.widget;
		e.stopPropagation();
		if (data.disabled) return;
		if (!validationCheck(date, data)) return;
		if (this.onBeforeSelect && instance.invoke("onBeforeSelect", e, instance, date) === false) return;

		if (widget.partial) {
			var mixed = new Date(data.value);

			if (data.value && !isNaN(mixed)) {
				mixed.setFullYear(date.getFullYear());
				mixed.setMonth(date.getMonth());
				mixed.setDate(date.getDate());
				date = mixed;
			}
		}

		var encode = widget.encoding || Culture.getDefaultDateEncoding();
		instance.set("value", encode(date));
		if (this.onSelect) instance.invoke("onSelect", e, instance, date);
	};

	return Calendar;
})(Field);
Calendar.prototype.baseClass = "calendar";
Calendar.prototype.highlightToday = true;
Calendar.prototype.maxValueErrorText = "Select a date not after {0:d}.";
Calendar.prototype.maxExclusiveErrorText = "Select a date before {0:d}.";
Calendar.prototype.minValueErrorText = "Select a date not before {0:d}.";
Calendar.prototype.minExclusiveErrorText = "Select a date after {0:d}.";
Calendar.prototype.disabledDaysOfWeekErrorText = "Selected day of week is not allowed.";
Calendar.prototype.suppressErrorsUntilVisited = false;
Calendar.prototype.showTodayButton = false;
Calendar.prototype.todayButtonText = "Today";
Calendar.prototype.startWithMonday = false;
Calendar.prototype.focusable = true;
Localization.registerPrototype("cx/widgets/Calendar", Calendar);

var validationCheck = function validationCheck(date, data, disabledDaysOfWeek) {
	if (data.maxValue && !upperBoundCheck(date, data.maxValue, data.maxExclusive)) return false;
	if (data.minValue && !lowerBoundCheck(date, data.minValue, data.minExclusive)) return false;
	if (disabledDaysOfWeek && disabledDaysOfWeek.includes(date.getDay())) return false;
	return true;
};

var CalendarCmp = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(CalendarCmp, _VDOM$Component);

	function CalendarCmp(props) {
		var _this2;

		_this2 = _VDOM$Component.call(this, props) || this;
		var data = props.instance.data;
		var refDate = data.refDate ? data.refDate : data.date || zeroTime(new Date());
		_this2.state = Object.assign(
			{
				hover: false,
				focus: false,
				cursor: zeroTime(data.date || refDate)
			},
			_this2.getPage(refDate)
		);
		_this2.handleMouseMove = _this2.handleMouseMove.bind(_assertThisInitialized(_this2));
		_this2.handleMouseDown = _this2.handleMouseDown.bind(_assertThisInitialized(_this2));
		return _this2;
	}

	var _proto2 = CalendarCmp.prototype;

	_proto2.getPage = function getPage(refDate) {
		refDate = monthStart(refDate); //make a copy

		var startDate = new Date(refDate);
		startDate.setDate(1 - startDate.getDay());
		var endDate = new Date(refDate);
		endDate.setMonth(refDate.getMonth() + 1);
		endDate.setDate(endDate.getDate() - 1);
		endDate.setDate(endDate.getDate() + 6 - endDate.getDay());
		return {
			refDate: refDate,
			startDate: startDate,
			endDate: endDate
		};
	};

	_proto2.moveCursor = function moveCursor(e, date, options) {
		if (options === void 0) {
			options = {};
		}

		e.preventDefault();
		e.stopPropagation();
		date = zeroTime(date);
		if (date.getTime() == this.state.cursor.getTime()) return;
		var refDate = this.state.refDate;
		if (options.movePage || date < this.state.startDate || date > this.state.endDate) refDate = date;
		this.setState(
			_objectSpread2(
				_objectSpread2({}, this.getPage(refDate)),
				{},
				{
					cursor: date
				}
			)
		);
	};

	_proto2.move = function move(e, period, delta) {
		e.preventDefault();
		e.stopPropagation();
		var refDate = this.state.refDate;

		switch (period) {
			case "y":
				refDate.setFullYear(refDate.getFullYear() + delta);
				break;

			case "m":
				refDate.setMonth(refDate.getMonth() + delta);
				break;
		}

		var page = this.getPage(refDate);
		if (this.state.cursor < page.startDate) page.cursor = page.startDate;
		else if (this.state.cursor > page.endDate) page.cursor = page.endDate;
		this.setState(page);
	};

	_proto2.handleKeyPress = function handleKeyPress(e) {
		var cursor = new Date(this.state.cursor);

		switch (e.keyCode) {
			case KeyCode.enter:
				this.props.handleSelect(e, this.state.cursor);
				break;

			case KeyCode.left:
				cursor.setDate(cursor.getDate() - 1);
				this.moveCursor(e, cursor);
				break;

			case KeyCode.right:
				cursor.setDate(cursor.getDate() + 1);
				this.moveCursor(e, cursor);
				break;

			case KeyCode.up:
				cursor.setDate(cursor.getDate() - 7);
				this.moveCursor(e, cursor);
				break;

			case KeyCode.down:
				cursor.setDate(cursor.getDate() + 7);
				this.moveCursor(e, cursor);
				break;

			case KeyCode.pageUp:
				cursor.setMonth(cursor.getMonth() - 1);
				this.moveCursor(e, cursor, {
					movePage: true
				});
				break;

			case KeyCode.pageDown:
				cursor.setMonth(cursor.getMonth() + 1);
				this.moveCursor(e, cursor, {
					movePage: true
				});
				break;

			case KeyCode.home:
				cursor.setDate(1);
				this.moveCursor(e, cursor, {
					movePage: true
				});
				break;

			case KeyCode.end:
				cursor.setMonth(cursor.getMonth() + 1);
				cursor.setDate(0);
				this.moveCursor(e, cursor, {
					movePage: true
				});
				break;

			default:
				var instance = this.props.instance;
				var widget = instance.widget;
				if (widget.onKeyDown) instance.invoke("onKeyDown", e, instance);
				break;
		}
	};

	_proto2.handleWheel = function handleWheel(e) {
		e.preventDefault();
		e.stopPropagation();
		var cursor = new Date(this.state.cursor);

		if (e.deltaY < 0) {
			cursor.setMonth(cursor.getMonth() - 1);
			this.moveCursor(e, cursor, {
				movePage: true
			});
		} else if (e.deltaY > 0) {
			cursor.setMonth(cursor.getMonth() + 1);
			this.moveCursor(e, cursor, {
				movePage: true
			});
		}
	};

	_proto2.handleBlur = function handleBlur(e) {
		FocusManager.nudge();
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onBlur) instance.invoke("onBlur", e, instance);
		this.setState({
			focus: false
		});
	};

	_proto2.handleFocus = function handleFocus(e) {
		oneFocusOut(this, this.el, this.handleFocusOut.bind(this));
		this.setState({
			focus: true
		});
	};

	_proto2.handleFocusOut = function handleFocusOut() {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onFocusOut) instance.invoke("onFocusOut", null, instance);
	};

	_proto2.handleMouseLeave = function handleMouseLeave(e) {
		tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(this.props.instance)));
		this.setState({
			hover: false
		});
	};

	_proto2.handleMouseEnter = function handleMouseEnter(e) {
		this.setState({
			hover: true
		});
	};

	_proto2.handleMouseMove = function handleMouseMove(e) {
		this.moveCursor(e, readDate(e.target.dataset));
	};

	_proto2.handleMouseDown = function handleMouseDown(e) {
		this.props.handleSelect(e, readDate(e.target.dataset));
	};

	_proto2.componentDidMount = function componentDidMount() {
		//calendar doesn't bring up keyboard so it's ok to focus it even on mobile
		if (this.props.instance.widget.autoFocus) this.el.focus();
		tooltipParentDidMount.apply(void 0, [this.el].concat(getFieldTooltip(this.props.instance)));
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var data = props.instance.data;
		if (data.date)
			this.setState(
				_objectSpread2(
					_objectSpread2({}, this.getPage(data.date)),
					{},
					{
						value: data.date
					}
				)
			);
		tooltipParentWillReceiveProps.apply(void 0, [this.el].concat(getFieldTooltip(props.instance)));
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		offFocusOut(this);
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.render = function render() {
		var _this3 = this;

		var _this$props$instance = this.props.instance,
			data = _this$props$instance.data,
			widget = _this$props$instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			disabledDaysOfWeek = widget.disabledDaysOfWeek,
			startWithMonday = widget.startWithMonday;
		var refDate = this.state.refDate;
		var month = refDate.getMonth();
		var year = refDate.getFullYear();
		var startDate = new Date(year, month, 1);
		startDate.setDate(1 - startDate.getDay() + (startWithMonday ? 1 : 0));
		var weeks = [];
		var date = startDate;
		var today = zeroTime(new Date());

		while (date < refDate || date.getMonth() == month) {
			var days = [];

			for (var i = 0; i < 7; i++) {
				var unselectable = !validationCheck(date, data, disabledDaysOfWeek);
				var classNames = CSS.state({
					outside: month != date.getMonth(),
					unselectable: unselectable,
					selected: data.date && sameDate(data.date, date),
					cursor: (this.state.hover || this.state.focus) && this.state.cursor && sameDate(this.state.cursor, date),
					today: widget.highlightToday && sameDate(date, today)
				});
				var dateInst = new Date(date);
				days.push(
					/*#__PURE__*/ jsx(
						"td",
						{
							className: classNames,
							"data-year": dateInst.getFullYear(),
							"data-month": dateInst.getMonth() + 1,
							"data-date": dateInst.getDate(),
							onMouseMove: unselectable ? null : this.handleMouseMove,
							onMouseDown: unselectable ? null : this.handleMouseDown,
							children: date.getDate()
						},
						i
					)
				);
				date.setDate(date.getDate() + 1);
			}

			weeks.push(
				/*#__PURE__*/ jsxs(
					"tr",
					{
						className: CSS.element(baseClass, "week"),
						children: [/*#__PURE__*/ jsx("td", {}), days, /*#__PURE__*/ jsx("td", {})]
					},
					weeks.length
				)
			);
		}

		var culture = Culture.getDateTimeCulture();
		var monthNames = culture.getMonthNames("long");
		var dayNames = culture.getWeekdayNames("short").map(function(x) {
			return x.substr(0, 2);
		});
		if (startWithMonday) dayNames = [].concat(dayNames.slice(1), [dayNames[0]]);
		return /*#__PURE__*/ jsxs("div", {
			className: data.classNames,
			tabIndex: data.disabled || !data.focusable ? null : data.tabIndex || 0,
			onKeyDown: function onKeyDown(e) {
				return _this3.handleKeyPress(e);
			},
			onMouseDown: function onMouseDown(e) {
				// prevent losing focus from the input field
				if (!data.focusable) {
					e.preventDefault();
				}

				e.stopPropagation();
			},
			ref: function ref(el) {
				_this3.el = el;
			},
			onMouseMove: function onMouseMove(e) {
				return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
			},
			onMouseLeave: function onMouseLeave(e) {
				return _this3.handleMouseLeave(e);
			},
			onMouseEnter: function onMouseEnter(e) {
				return _this3.handleMouseEnter(e);
			},
			onWheel: function onWheel(e) {
				return _this3.handleWheel(e);
			},
			onFocus: function onFocus(e) {
				return _this3.handleFocus(e);
			},
			onBlur: function onBlur(e) {
				return _this3.handleBlur(e);
			},
			children: [
				/*#__PURE__*/ jsxs("table", {
					children: [
						/*#__PURE__*/ jsxs("thead", {
							children: [
								/*#__PURE__*/ jsxs(
									"tr",
									{
										className: CSS.element(baseClass, "header"),
										children: [
											/*#__PURE__*/ jsx("td", {}),
											/*#__PURE__*/ jsx("td", {
												onClick: function onClick(e) {
													return _this3.move(e, "y", -1);
												},
												children: /*#__PURE__*/ jsx(ForwardIcon, {
													className: CSS.element(baseClass, "icon-prev-year")
												})
											}),
											/*#__PURE__*/ jsx("td", {
												onClick: function onClick(e) {
													return _this3.move(e, "m", -1);
												},
												children: /*#__PURE__*/ jsx(DropdownIcon, {
													className: CSS.element(baseClass, "icon-prev-month")
												})
											}),
											/*#__PURE__*/ jsxs("th", {
												className: CSS.element(baseClass, "display"),
												colSpan: "3",
												children: [monthNames[month], /*#__PURE__*/ jsx("br", {}), year]
											}),
											/*#__PURE__*/ jsx("td", {
												onClick: function onClick(e) {
													return _this3.move(e, "m", +1);
												},
												children: /*#__PURE__*/ jsx(DropdownIcon, {
													className: CSS.element(baseClass, "icon-next-month")
												})
											}),
											/*#__PURE__*/ jsx("td", {
												onClick: function onClick(e) {
													return _this3.move(e, "y", +1);
												},
												children: /*#__PURE__*/ jsx(ForwardIcon, {
													className: CSS.element(baseClass, "icon-next-year")
												})
											}),
											/*#__PURE__*/ jsx("td", {})
										]
									},
									"h"
								),
								/*#__PURE__*/ jsxs(
									"tr",
									{
										className: CSS.element(baseClass, "day-names"),
										children: [
											/*#__PURE__*/ jsx("td", {}),
											dayNames.map(function(name, i) {
												return /*#__PURE__*/ jsx(
													"th",
													{
														children: name
													},
													i
												);
											}),
											/*#__PURE__*/ jsx("td", {})
										]
									},
									"d"
								)
							]
						}),
						/*#__PURE__*/ jsx("tbody", {
							children: weeks
						})
					]
				}),
				widget.showTodayButton &&
					/*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "toolbar"),
						children: /*#__PURE__*/ jsx("button", {
							className: CSS.expand(CSS.element(baseClass, "today-button"), CSS.block("button", "hollow")),
							"data-year": today.getFullYear(),
							"data-month": today.getMonth() + 1,
							"data-date": today.getDate(),
							onClick: function onClick(e) {
								_this3.handleMouseDown(e);
							},
							children: widget.todayButtonText
						})
					})
			]
		});
	};

	return CalendarCmp;
})(VDOM.Component);

var readDate = function readDate(ds) {
	return new Date(Number(ds.year), Number(ds.month) - 1, Number(ds.date));
};

Widget.alias("calendar", Calendar);

var LookupField = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(LookupField, _Field);

	function LookupField() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = LookupField.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		var additionalAttributes = this.multiple
			? {
					values: undefined,
					records: undefined
			  }
			: {
					value: undefined,
					text: undefined
			  };

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					disabled: undefined,
					enabled: undefined,
					placeholder: undefined,
					required: undefined,
					options: undefined,
					icon: undefined,
					autoOpen: undefined,
					readOnly: undefined
				},
				additionalAttributes
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
		if (this.alwaysShowClear) this.showClear = true;

		if (!this.bindings) {
			var b = [];
			if (this.value && this.value.bind)
				b.push({
					key: true,
					local: this.value.bind,
					remote: "$option." + this.optionIdField,
					set: this.value.set
				});
			if (this.text && this.text.bind)
				b.push({
					local: this.text.bind,
					remote: "$option." + this.optionTextField,
					set: this.text.set
				});
			this.bindings = b;
		}

		if (this.bindings.length == 0 && this.multiple)
			this.bindings = [
				{
					key: true,
					local: "$value." + this.valueIdField,
					remote: "$option." + this.optionIdField
				},
				{
					local: "$value." + this.valueTextField,
					remote: "$option." + this.optionTextField
				}
			];
		this.keyBindings = this.bindings.filter(function(b) {
			return b.key;
		});
		if (!this.items && !this.children)
			this.items = {
				$type: HighlightedSearchText,
				text: {
					bind: "$option." + this.optionTextField
				},
				query: {
					bind: "$query"
				}
			};
		this.itemConfig = this.children || this.items;
		delete this.items;
		delete this.children;

		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var _this = this;

		var data = instance.data,
			store = instance.store;
		data.stateMods = {
			multiple: this.multiple,
			disabled: data.disabled,
			readonly: data.readOnly
		};
		data.selectedKeys = [];

		if (this.multiple) {
			var _data$selectedKeys;

			if (isArray(data.values) && isArray(data.options)) {
				data.selectedKeys = data.values.map(function(v) {
					return _this.keyBindings.length == 1 ? [v] : v;
				});
				var map = {};
				data.options.filter(function($option) {
					var optionKey = getOptionKey(_this.keyBindings, {
						$option: $option
					});

					for (var i = 0; i < data.selectedKeys.length; i++) {
						if (areKeysEqual(optionKey, data.selectedKeys[i])) {
							map[i] = convertOption(_this.bindings, {
								$option: $option
							});
							break;
						}
					}
				});
				data.records = [];

				for (var i = 0; i < data.selectedKeys.length; i++) {
					if (map[i]) data.records.push(map[i]);
				}
			} else if (isArray(data.records))
				(_data$selectedKeys = data.selectedKeys).push.apply(
					_data$selectedKeys,
					data.records.map(function($value) {
						return _this.keyBindings.map(function(b) {
							return Binding.get(b.local).value({
								$value: $value
							});
						});
					})
				);
		} else {
			var dataViewData = store.getData();
			data.selectedKeys.push(
				this.keyBindings.map(function(b) {
					return Binding.get(b.local).value(dataViewData);
				})
			);

			if (!this.text && isArray(data.options)) {
				var option = data.options.find(function($option) {
					return areKeysEqual(
						getOptionKey(_this.keyBindings, {
							$option: $option
						}),
						data.selectedKeys[0]
					);
				});
				data.text = (option && option[this.optionTextField]) || "";
			}
		}

		instance.lastDropdown = context.lastDropdown;

		_Field.prototype.prepareData.call(this, context, instance);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			LookupComponent,
			{
				multiple: this.multiple,
				instance: instance,
				itemConfig: this.itemConfig,
				bindings: this.bindings,
				baseClass: this.baseClass,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help")),
				forceUpdate: context.forceUpdate
			},
			key
		);
	};

	_proto.filterOptions = function filterOptions(instance, options, query) {
		var _this2 = this;

		if (!query) return options;
		var textPredicate = getSearchQueryPredicate(query);
		return options.filter(function(o) {
			return isString(o[_this2.optionTextField]) && textPredicate(o[_this2.optionTextField]);
		});
	};

	_proto.isEmpty = function isEmpty(data) {
		if (this.multiple) return !isNonEmptyArray(data.values) && !isNonEmptyArray(data.records);
		return _Field.prototype.isEmpty.call(this, data);
	};

	_proto.formatValue = function formatValue(context, instance) {
		var _this3 = this;

		if (!this.multiple) return _Field.prototype.formatValue.call(this, context, instance);
		var _instance$data = instance.data,
			records = _instance$data.records,
			values = _instance$data.values,
			options = _instance$data.options;
		if (isArray(records))
			return records
				.map(function(record) {
					return record[_this3.valueTextField] || record[_this3.valueIdField];
				})
				.join(", ");

		if (isArray(values)) {
			if (isArray(options))
				return values
					.map(function(id) {
						var option = options.find(function(o) {
							return o[_this3.optionIdField] == id;
						});
						return option ? option[_this3.valueTextField] : id;
					})
					.filter(Boolean)
					.join(", ");
			return values.join(", ");
		}

		return null;
	};

	return LookupField;
})(Field);
LookupField.prototype.baseClass = "lookupfield"; //LookupField.prototype.memoize = false;

LookupField.prototype.multiple = false;
LookupField.prototype.queryDelay = 150;
LookupField.prototype.minQueryLength = 0;
LookupField.prototype.hideSearchField = false;
LookupField.prototype.minOptionsForSearchField = 7;
LookupField.prototype.loadingText = "Loading...";
LookupField.prototype.queryErrorText = "Error occurred while querying for lookup data.";
LookupField.prototype.noResultsText = "No results found.";
LookupField.prototype.optionIdField = "id";
LookupField.prototype.optionTextField = "text";
LookupField.prototype.valueIdField = "id";
LookupField.prototype.valueTextField = "text";
LookupField.prototype.suppressErrorsUntilVisited = true;
LookupField.prototype.fetchAll = false;
LookupField.prototype.cacheAll = false;
LookupField.prototype.showClear = true;
LookupField.prototype.alwaysShowClear = false;
LookupField.prototype.closeOnSelect = true;
LookupField.prototype.minQueryLengthMessageText = "Type in at least {0} character(s).";
LookupField.prototype.icon = null;
LookupField.prototype.sort = false;
LookupField.prototype.listOptions = null;
LookupField.prototype.autoOpen = false;
LookupField.prototype.submitOnEnterKey = false;
LookupField.prototype.submitOnDropdownEnterKey = false;
LookupField.prototype.pageSize = 100;
LookupField.prototype.infinite = false;
LookupField.prototype.closeDropdownOnScrollDistance = 100;
Localization.registerPrototype("cx/widgets/LookupField", LookupField);
Widget.alias("lookupfield", LookupField);

function getOptionKey(bindings, data) {
	return bindings
		.filter(function(a) {
			return a.key;
		})
		.map(function(b) {
			return Binding.get(b.remote).value(data);
		});
}

function areKeysEqual(key1, key2) {
	if (!key1 || !key2 || key1.length != key2.length) return false;

	for (var i = 0; i < key1.length; i++) {
		if (key1[i] != key2[i]) return false;
	}

	return true;
}

function convertOption(bindings, data) {
	var result = {
		$value: {}
	};
	bindings.forEach(function(b) {
		var value = Binding.get(b.remote).value(data);
		result = Binding.get(b.local).set(result, value);
	});
	return result.$value;
}

var SelectionDelegate = /*#__PURE__*/ (function(_Selection) {
	_inheritsLoose(SelectionDelegate, _Selection);

	function SelectionDelegate(_ref) {
		var _this4;

		var delegate = _ref.delegate;
		_this4 = _Selection.call(this) || this;
		_this4.delegate = delegate;
		return _this4;
	}

	var _proto2 = SelectionDelegate.prototype;

	_proto2.getIsSelectedDelegate = function getIsSelectedDelegate(store) {
		var _this5 = this;

		return function(record, index) {
			return _this5.delegate(record, index);
		};
	};

	_proto2.select = function select() {
		return false;
	};

	return SelectionDelegate;
})(Selection);

var LookupComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(LookupComponent, _VDOM$Component);

	function LookupComponent(props) {
		var _this6;

		_this6 = _VDOM$Component.call(this, props) || this;
		var _this6$props$instance = _this6.props.instance,
			data = _this6$props$instance.data,
			store = _this6$props$instance.store;
		_this6.dom = {};
		_this6.state = {
			options: [],
			formatted: data.formatted,
			value: data.formatted,
			dropdownOpen: false,
			focus: false
		};
		_this6.itemStore = new ReadOnlyDataView({
			store: store
		});
		return _this6;
	}

	var _proto3 = LookupComponent.prototype;

	_proto3.getOptionKey = function getOptionKey(data) {
		return this.props.bindings
			.filter(function(a) {
				return a.key;
			})
			.map(function(b) {
				return Binding.get(b.remote).value(data);
			});
	};

	_proto3.getLocalKey = function getLocalKey(data) {
		return this.props.bindings
			.filter(function(a) {
				return a.key;
			})
			.map(function(b) {
				return Binding.get(b.local).value(data);
			});
	};

	_proto3.findOption = function findOption(options, key) {
		if (!key) return -1;

		for (var i = 0; i < options.length; i++) {
			var optionKey = this.getOptionKey({
				$option: options[i]
			});
			if (areKeysEqual(key, optionKey)) return i;
		}

		return -1;
	};

	_proto3.getDropdown = function getDropdown() {
		var _this7 = this;

		if (this.dropdown) return this.dropdown;
		var _this$props$instance = this.props.instance,
			widget = _this$props$instance.widget,
			lastDropdown = _this$props$instance.lastDropdown;
		this.list = Widget.create({
			$type: List,
			sortField: widget.sort && widget.optionTextField,
			sortDirection: "ASC",
			mod: "dropdown",
			scrollSelectionIntoView: true,
			cached: widget.infinite,
			records: {
				bind: "$options"
			},
			recordName: "$option",
			onItemClick: function onItemClick(e, inst) {
				return _this7.onItemClick(e, inst);
			},
			pipeKeyDown: function pipeKeyDown(kd) {
				_this7.listKeyDown = kd;
			},
			selectOnTab: true,
			focusable: false,
			selection: {
				type: SelectionDelegate,
				delegate: function delegate(data) {
					return (
						_this7.props.instance.data.selectedKeys.find(function(x) {
							return areKeysEqual(
								x,
								_this7.getOptionKey({
									$option: data
								})
							);
						}) != null
					);
				}
			},
			jsxSpread: [widget.listOptions],
			jsxAttributes: [
				"sortField",
				"sortDirection",
				"mod",
				"scrollSelectionIntoView",
				"cached",
				"records",
				"recordName",
				"onItemClick",
				"pipeKeyDown",
				"selectOnTab",
				"focusable",
				"selection"
			],
			children: ["\n               ", this.props.itemConfig, "\n            "]
		});

		var dropdown = _objectSpread2(
			_objectSpread2(
				{
					constrain: true,
					scrollTracking: true,
					inline: !isTouchDevice() || !!lastDropdown,
					placementOrder: "down-right down-left up-right up-left"
				},
				widget.dropdownOptions
			),
			{},
			{
				type: Dropdown,
				relatedElement: this.dom.input,
				renderChildren: function renderChildren() {
					return _this7.renderDropdownContents();
				},
				onFocusOut: function onFocusOut(e) {
					return _this7.closeDropdown(e);
				},
				memoize: false,
				touchFriendly: isTouchDevice(),
				onMeasureNaturalContentSize: function onMeasureNaturalContentSize() {
					if (_this7.dom.dropdown && _this7.dom.list) {
						var _this7$dom$list$first;

						return {
							height:
								_this7.dom.dropdown.offsetHeight -
								_this7.dom.list.offsetHeight +
								(((_this7$dom$list$first = _this7.dom.list.firstElementChild) == null
									? void 0
									: _this7$dom$list$first.offsetHeight) || 0)
						};
					}
				},
				onDropdownPositionDidUpdate: function onDropdownPositionDidUpdate(params) {
					var parentBounds = params.parentBounds;
					var initialScreenPosition = _this7.initialScreenPosition;
					if (!initialScreenPosition) initialScreenPosition = _this7.initialScreenPosition = params.parentBounds;
					if (
						Math.abs(parentBounds.top - initialScreenPosition.top) > widget.closeDropdownOnScrollDistance ||
						Math.abs(parentBounds.left - initialScreenPosition.left) > widget.closeDropdownOnScrollDistance
					)
						_this7.closeDropdown(null, true);
				}
			}
		);

		return (this.dropdown = Widget.create(dropdown));
	};

	_proto3.renderDropdownContents = function renderDropdownContents() {
		var _this8 = this;

		var content;
		var instance = this.props.instance;
		var data = instance.data,
			widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var searchVisible =
			!widget.hideSearchField &&
			(!isArray(data.options) ||
				(widget.minOptionsForSearchField && data.options.length >= widget.minOptionsForSearchField));

		if (this.state.status == "loading") {
			content = /*#__PURE__*/ jsx(
				"div",
				{
					className: CSS.element(baseClass, "message", "loading"),
					children: widget.loadingText
				},
				"msg"
			);
		} else if (this.state.status == "error") {
			content = /*#__PURE__*/ jsx(
				"div",
				{
					className: CSS.element(baseClass, "message", "error"),
					children: widget.queryErrorText
				},
				"msg"
			);
		} else if (this.state.status == "info") {
			content = /*#__PURE__*/ jsx(
				"div",
				{
					className: CSS.element(baseClass, "message", "info"),
					children: this.state.message
				},
				"msg"
			);
		} else if (this.state.options.length == 0) {
			content = /*#__PURE__*/ jsx(
				"div",
				{
					className: CSS.element(baseClass, "message", "no-results"),
					children: widget.noResultsText
				},
				"msg"
			);
		} else {
			content = /*#__PURE__*/ jsx(
				"div",
				{
					ref: function ref(el) {
						_this8.dom.list = el;

						_this8.subscribeListOnWheel(el);

						_this8.subscribeListOnScroll(el);
					},
					className: CSS.element(baseClass, "scroll-container"),
					children: /*#__PURE__*/ jsx(Cx, {
						widget: this.list,
						store: this.itemStore,
						options: {
							name: "lookupfield-list"
						}
					})
				},
				"msg"
			);
		}

		return /*#__PURE__*/ jsxs(
			"div",
			{
				ref: function ref(el) {
					_this8.dom.dropdown = el;
				},
				className: CSS.element(baseClass, "dropdown"),
				tabIndex: 0,
				onFocus: function onFocus(e) {
					return _this8.onDropdownFocus(e);
				},
				onKeyDown: function onKeyDown(e) {
					return _this8.onDropdownKeyPress(e);
				},
				children: [
					searchVisible &&
						/*#__PURE__*/ jsx(
							"input",
							{
								ref: function ref(el) {
									_this8.dom.query = el;
								},
								type: "text",
								className: CSS.element(baseClass, "query"),
								onClick: function onClick(e) {
									e.preventDefault();
									e.stopPropagation();
								},
								onChange: function onChange(e) {
									return _this8.query(e.target.value);
								},
								onBlur: function onBlur(e) {
									return _this8.onQueryBlur(e);
								}
							},
							"query"
						),
					content
				]
			},
			"dropdown"
		);
	};

	_proto3.onListWheel = function onListWheel(e) {
		var list = this.dom.list;

		if (
			(list.scrollTop + list.offsetHeight == list.scrollHeight && e.deltaY > 0) ||
			(list.scrollTop == 0 && e.deltaY < 0)
		) {
			e.preventDefault();
			e.stopPropagation();
		}
	};

	_proto3.onListScroll = function onListScroll() {
		if (!this.dom.list) return;
		var el = this.dom.list;

		if (el.scrollTop > el.scrollHeight - 2 * el.offsetHeight) {
			this.loadAdditionalOptionPages();
		}
	};

	_proto3.onDropdownFocus = function onDropdownFocus(e) {
		if (this.dom.query && !isFocused(this.dom.query) && !isTouchDevice()) FocusManager.focus(this.dom.query);
	};

	_proto3.getPlaceholder = function getPlaceholder(text) {
		var _this$props$instance$ = this.props.instance.widget,
			CSS = _this$props$instance$.CSS,
			baseClass = _this$props$instance$.baseClass;
		if (text)
			return /*#__PURE__*/ jsx("span", {
				className: CSS.element(baseClass, "placeholder"),
				children: text
			});
		return /*#__PURE__*/ jsx("span", {
			className: CSS.element(baseClass, "placeholder"),
			children: "\xA0"
		});
	};

	_proto3.render = function render() {
		var _this9 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			label = _this$props.label,
			help = _this$props.help;
		var data = instance.data,
			widget = instance.widget,
			state = instance.state;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;

		var icon =
			data.icon &&
			/*#__PURE__*/ jsx(
				"div",
				{
					className: CSS.element(baseClass, "left-icon"),
					onMouseDown: preventDefault,
					onClick: function onClick(e) {
						_this9.openDropdown(e);

						e.stopPropagation();
						e.preventDefault();
					},
					children: Icon.render(data.icon, {
						className: CSS.element(baseClass, "icon")
					})
				},
				"icon"
			);

		var dropdown;

		if (this.state.dropdownOpen) {
			this.itemStore.setData({
				$options: this.state.options,
				$query: this.lastQuery
			});
			dropdown = /*#__PURE__*/ jsx(Cx, {
				widget: this.getDropdown(),
				store: this.itemStore,
				options: {
					name: "lookupfield-dropdown"
				}
			});
		}

		var insideButton = null;
		var multipleEntries = this.props.multiple && isArray(data.records) && data.records.length > 1;

		if (!data.readOnly) {
			if (
				widget.showClear &&
				!data.disabled &&
				!data.empty &&
				(widget.alwaysShowClear || (!data.required && !this.props.multiple) || multipleEntries)
			) {
				insideButton = /*#__PURE__*/ jsx(
					"div",
					{
						onMouseDown: preventDefault,
						onClick: function onClick(e) {
							return !_this9.props.multiple ? _this9.onClearClick(e) : _this9.onClearMultipleClick(e);
						},
						className: CSS.element(baseClass, "clear"),
						children: /*#__PURE__*/ jsx(ClearIcon, {
							className: CSS.element(baseClass, "icon")
						})
					},
					"ib"
				);
			} else {
				insideButton = /*#__PURE__*/ jsx(
					"div",
					{
						className: CSS.element(baseClass, "tool"),
						onMouseDown: preventDefault,
						onClick: function onClick(e) {
							_this9.toggleDropdown(e, true);

							e.stopPropagation();
							e.preventDefault();
						},
						children: /*#__PURE__*/ jsx(DropdownIcon, {
							className: CSS.element(baseClass, "icon")
						})
					},
					"ib"
				);
			}
		}

		var text;

		if (this.props.multiple) {
			var readOnly = data.disabled || data.readOnly;

			if (isNonEmptyArray(data.records)) {
				text = data.records.map(function(v, i) {
					return /*#__PURE__*/ jsxs(
						"div",
						{
							className: CSS.element(baseClass, "tag", {
								readonly: readOnly
							}),
							children: [
								/*#__PURE__*/ jsx("span", {
									className: CSS.element(baseClass, "tag-value"),
									children: v[widget.valueTextField]
								}),
								!readOnly &&
									/*#__PURE__*/ jsx("div", {
										className: CSS.element(baseClass, "tag-clear"),
										onMouseDown: function onMouseDown(e) {
											e.preventDefault();
											e.stopPropagation();
										},
										onClick: function onClick(e) {
											return _this9.onClearClick(e, v);
										},
										children: /*#__PURE__*/ jsx(ClearIcon, {
											className: CSS.element(baseClass, "icon")
										})
									})
							]
						},
						i
					);
				});
			} else {
				text = this.getPlaceholder(data.placeholder);
			}
		} else {
			text = !data.empty ? data.text || this.getPlaceholder() : this.getPlaceholder(data.placeholder);
		}

		var states = {
			visited: state.visited,
			focus: this.state.focus || this.state.dropdownOpen,
			icon: !!data.icon,
			empty: !data.placeholder && data.empty,
			error: data.error && (state.visited || !suppressErrorsUntilVisited || !data.empty)
		};
		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(data.classNames, CSS.state(states)),
			style: data.style,
			onMouseDown: stopPropagation,
			onTouchStart: stopPropagation,
			onKeyDown: function onKeyDown(e) {
				return _this9.onKeyDown(e);
			},
			children: [
				/*#__PURE__*/ jsx("div", {
					id: data.id,
					className: CSS.expand(CSS.element(widget.baseClass, "input"), data.inputClass),
					style: data.inputStyle,
					tabIndex: data.disabled ? null : data.tabIndex || 0,
					ref: function ref(el) {
						_this9.dom.input = el;
					},
					"aria-labelledby": data.id + "-label",
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this9.props.instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(_this9.props.instance)));
					},
					onClick: function onClick(e) {
						return _this9.onClick(e);
					},
					onInput: function onInput(e) {
						return _this9.onChange(e, "input");
					},
					onChange: function onChange(e) {
						return _this9.onChange(e, "change");
					},
					onKeyDown: function onKeyDown(e) {
						return _this9.onInputKeyDown(e);
					},
					onMouseDown: function onMouseDown(e) {
						return _this9.onMouseDown(e);
					},
					onBlur: function onBlur(e) {
						return _this9.onBlur(e);
					},
					onFocus: function onFocus(e) {
						return _this9.onFocus(e);
					},
					children: text
				}),
				insideButton,
				icon,
				dropdown,
				label,
				help
			]
		});
	};

	_proto3.onMouseDown = function onMouseDown(e) {
		//skip touch start to allow touch scrolling
		if (isTouchEvent()) return;
		e.preventDefault();
		e.stopPropagation();
		this.toggleDropdown(e, true);
	};

	_proto3.onClick = function onClick(e) {
		//mouse down will handle it for non-touch events
		if (!isTouchEvent()) return;
		e.preventDefault();
		e.stopPropagation();
		this.toggleDropdown(e, true);
	};

	_proto3.onItemClick = function onItemClick(e, _ref2) {
		var store = _ref2.store;
		this.select(e, store.getData());
		if (!this.props.instance.widget.submitOnEnterKey || e.type != "keydown") e.stopPropagation();
		if (e.keyCode != KeyCode.tab) e.preventDefault();
	};

	_proto3.onClearClick = function onClearClick(e, value) {
		var _this10 = this;

		var instance = this.props.instance;
		var data = instance.data,
			store = instance.store,
			widget = instance.widget;
		var keyBindings = widget.keyBindings;
		e.stopPropagation();
		e.preventDefault();

		if (widget.multiple) {
			if (isArray(data.records)) {
				var itemKey = this.getLocalKey({
					$value: value
				});
				var newRecords = data.records.filter(function(v) {
					return !areKeysEqual(
						_this10.getLocalKey({
							$value: v
						}),
						itemKey
					);
				});
				instance.set("records", newRecords);
				var newValues = newRecords
					.map(function(rec) {
						return _this10.getLocalKey({
							$value: rec
						});
					})
					.map(function(k) {
						return keyBindings.length == 1 ? k[0] : k;
					});
				instance.set("values", newValues);
			}
		} else {
			this.props.bindings.forEach(function(b) {
				store.set(b.local, widget.emptyValue);
			});
		}

		if (!isTouchEvent(e)) this.dom.input.focus();
	};

	_proto3.onClearMultipleClick = function onClearMultipleClick(e) {
		var instance = this.props.instance;
		instance.set("records", []);
		instance.set("values", []);
	};

	_proto3.select = function select(e, itemData) {
		var _this11 = this;

		var instance = this.props.instance;
		var store = instance.store,
			data = instance.data,
			widget = instance.widget;
		var bindings = widget.bindings,
			keyBindings = widget.keyBindings;

		if (widget.multiple) {
			var selectedKeys = data.selectedKeys,
				records = data.records;
			var optionKey = this.getOptionKey(itemData);
			var newRecords = records;

			if (
				!selectedKeys.find(function(k) {
					return areKeysEqual(optionKey, k);
				})
			) {
				var valueData = {
					$value: {}
				};
				bindings.forEach(function(b) {
					valueData = Binding.get(b.local).set(valueData, Binding.get(b.remote).value(itemData));
				});
				newRecords = [].concat(records || [], [valueData.$value]);
			} else {
				newRecords = records.filter(function(v) {
					return !areKeysEqual(
						optionKey,
						_this11.getLocalKey({
							$value: v
						})
					);
				});
			}

			instance.set("records", newRecords);
			var newValues = newRecords
				.map(function(rec) {
					return _this11.getLocalKey({
						$value: rec
					});
				})
				.map(function(k) {
					return keyBindings.length == 1 ? k[0] : k;
				});
			instance.set("values", newValues);
		} else {
			bindings.forEach(function(b) {
				var v = Binding.get(b.remote).value(itemData);
				if (b.set) b.set(v, instance);
				else store.set(b.local, v);
			});
		}

		if (widget.closeOnSelect) {
			//Pressing Tab should work it's own thing. Focus will move elsewhere and the dropdown will close.
			if (e.keyCode != KeyCode.tab) {
				if (!isTouchEvent(e)) this.dom.input.focus();
				this.closeDropdown(e);
			}
		}

		if (e.keyCode == KeyCode.enter && widget.submitOnDropdownEnterKey) {
			this.submitOnEnter(e);
		}
	};

	_proto3.onDropdownKeyPress = function onDropdownKeyPress(e) {
		if (e.keyCode == KeyCode.esc) {
			this.closeDropdown(e);
			this.dom.input.focus();
		}

		if (this.listKeyDown) this.listKeyDown(e); // if next focusable element is disabled, recalculate and update the dom before switching focus

		if (e.keyCode == KeyCode.tab) this.props.forceUpdate();
	};

	_proto3.onKeyDown = function onKeyDown(e) {
		switch (e.keyCode) {
			case KeyCode.pageDown:
			case KeyCode.pageUp:
				if (this.state.dropdownOpen) e.preventDefault();
				break;
		}
	};

	_proto3.onInputKeyDown = function onInputKeyDown(e) {
		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode["delete"]:
				this.onClearClick(e);
				return;

			case KeyCode.shift:
			case KeyCode.ctrl:
			case KeyCode.tab:
			case KeyCode.left:
			case KeyCode.right:
			case KeyCode.pageUp:
			case KeyCode.pageDown:
			case KeyCode.insert:
			case KeyCode.esc:
				break;

			case KeyCode.down:
				this.openDropdown(e);
				e.stopPropagation();
				break;

			case KeyCode.enter:
				if (this.props.instance.widget.submitOnEnterKey) {
					this.submitOnEnter(e);
				} else {
					this.openDropdown(e);
				}

				break;

			default:
				this.openDropdown(e);
				break;
		}
	};

	_proto3.onQueryBlur = function onQueryBlur(e) {
		FocusManager.nudge();
	};

	_proto3.onFocus = function onFocus(e) {
		var instance = this.props.instance;
		var widget = instance.widget;

		if (widget.trackFocus) {
			this.setState({
				focus: true
			});
		}

		if (this.props.instance.data.autoOpen) this.openDropdown(null);
	};

	_proto3.onBlur = function onBlur(e) {
		if (!this.state.dropdownOpen)
			this.props.instance.setState({
				visited: true
			});
		if (this.state.focus)
			this.setState({
				focus: false
			});
	};

	_proto3.toggleDropdown = function toggleDropdown(e, keepFocus) {
		if (this.state.dropdownOpen) this.closeDropdown(e, keepFocus);
		else this.openDropdown(e);
	};

	_proto3.closeDropdown = function closeDropdown(e, keepFocus) {
		var _this12 = this;

		if (this.state.dropdownOpen) {
			this.setState(
				{
					dropdownOpen: false
				},
				function() {
					return keepFocus && _this12.dom.input.focus();
				}
			);
			this.props.instance.setState({
				visited: true
			});
		} //delete results valid only while the dropdown is open

		delete this.tmpCachedResult;
		delete this.initialScreenPosition;
	};

	_proto3.openDropdown = function openDropdown(e) {
		var _this13 = this;

		var instance = this.props.instance;
		var data = instance.data;

		if (!this.state.dropdownOpen && !data.disabled && !data.readOnly) {
			this.query("");
			this.setState(
				{
					dropdownOpen: true
				},
				function() {
					if (_this13.dom.dropdown) _this13.dom.dropdown.focus();
				}
			);
		}
	};

	_proto3.query = function query(q) {
		var _this14 = this;

		/*
     In fetchAll mode onQuery should fetch all data and after
     that everything is done filtering is done client-side.
     If cacheAll is set results are cached for the lifetime of the
     widget, otherwise cache is invalidated when dropdown closes.
     */
		var instance = this.props.instance;
		var widget = instance.widget,
			data = instance.data;
		this.lastQuery = q; //do not make duplicate queries if fetchAll is enabled

		if (widget.fetchAll && this.state.status == "loading") return;
		if (this.queryTimeoutId) clearTimeout(this.queryTimeoutId);

		if (q.length < widget.minQueryLength) {
			this.setState({
				status: "info",
				message: StringTemplate.format(widget.minQueryLengthMessageText, widget.minQueryLength)
			});
			return;
		}

		if (isArray(data.options)) {
			var results = widget.filterOptions(this.props.instance, data.options, q);
			this.setState({
				options: results,
				status: "loaded"
			});
		}

		if (widget.onQuery) {
			var queryDelay = widget.queryDelay,
				fetchAll = widget.fetchAll,
				cacheAll = widget.cacheAll,
				pageSize = widget.pageSize;
			if (fetchAll) queryDelay = 0;

			if (!this.cachedResult) {
				this.setState({
					status: "loading"
				});
			}

			this.queryTimeoutId = setTimeout(function() {
				delete _this14.queryTimeoutId;
				var result = _this14.tmpCachedResult || _this14.cachedResult;
				var query = fetchAll ? "" : q;
				var params = !widget.infinite
					? query
					: {
							query: query,
							page: 1,
							pageSize: pageSize
					  };
				if (!result) result = instance.invoke("onQuery", params, instance);
				var queryId = (_this14.lastQueryId = Date.now());
				Promise.resolve(result)
					.then(function(results) {
						//discard results which do not belong to the last query
						if (queryId !== _this14.lastQueryId) return;
						if (!isArray(results)) results = [];

						if (fetchAll) {
							if (cacheAll) _this14.cachedResult = results;
							else _this14.tmpCachedResult = results;
							results = widget.filterOptions(_this14.props.instance, results, _this14.lastQuery);
						}

						_this14.setState(
							{
								page: 1,
								query: query,
								options: results,
								status: "loaded"
							},
							function() {
								if (widget.infinite) _this14.onListScroll();
							}
						);
					})
					["catch"](function(err) {
						_this14.setState({
							status: "error"
						});

						debug("Lookup query error:", err);
					});
			}, queryDelay);
		}
	};

	_proto3.loadAdditionalOptionPages = function loadAdditionalOptionPages() {
		var _this15 = this;

		var instance = this.props.instance;
		var widget = instance.widget;
		if (!widget.infinite) return;
		var _this$state = this.state,
			query = _this$state.query,
			page = _this$state.page,
			status = _this$state.status,
			options = _this$state.options;
		var blockerKey = query;
		if (status != "loaded") return;
		if (options.length < page * widget.pageSize) return; //some pages were not full which means we reached the end

		if (this.extraPageLoadingBlocker === blockerKey) return;
		this.extraPageLoadingBlocker = blockerKey;
		var params = {
			page: page + 1,
			query: query,
			pageSize: widget.pageSize
		};
		var result = instance.invoke("onQuery", params, instance);
		Promise.resolve(result)
			.then(function(results) {
				//discard results which do not belong to the last query
				if (_this15.extraPageLoadingBlocker !== blockerKey) return;
				_this15.extraPageLoadingBlocker = false;
				if (!isArray(results)) return;

				_this15.setState(
					{
						page: params.page,
						query: query,
						options: [].concat(options, results)
					},
					function() {
						_this15.onListScroll();
					}
				);
			})
			["catch"](function(err) {
				if (_this15.extraPageLoadingBlocker !== blockerKey) return;
				_this15.extraPageLoadingBlocker = false;

				_this15.setState({
					status: "error"
				});

				debug("Lookup query error:", err);
				console.error(err);
			});
	};

	_proto3.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		tooltipParentWillReceiveProps.apply(void 0, [this.dom.input].concat(getFieldTooltip(props.instance)));
	};

	_proto3.componentDidMount = function componentDidMount() {
		tooltipParentDidMount.apply(void 0, [this.dom.input].concat(getFieldTooltip(this.props.instance)));
		autoFocus(this.dom.input, this);
	};

	_proto3.componentDidUpdate = function componentDidUpdate() {
		autoFocus(this.dom.input, this);
	};

	_proto3.componentWillUnmount = function componentWillUnmount() {
		if (this.queryTimeoutId) clearTimeout(this.queryTimeoutId);
		tooltipParentWillUnmount(this.props.instance);
		this.subscribeListOnWheel(null);
	};

	_proto3.subscribeListOnWheel = function subscribeListOnWheel(list) {
		var _this16 = this;

		if (this.unsubscribeListOnWheel) {
			this.unsubscribeListOnWheel();
			this.unsubscribeListOnWheel = null;
		}

		if (list) {
			this.unsubscribeListOnWheel = addEventListenerWithOptions(
				list,
				"wheel",
				function(e) {
					return _this16.onListWheel(e);
				},
				{
					passive: false
				}
			);
		}
	};

	_proto3.subscribeListOnScroll = function subscribeListOnScroll(list) {
		var _this17 = this;

		if (this.unsubscribeListOnScroll) {
			this.unsubscribeListOnScroll();
			this.unsubscribeListOnScroll = null;
		}

		if (list) {
			this.unsubscribeListOnScroll = addEventListenerWithOptions(
				list,
				"scroll",
				function(e) {
					return _this17.onListScroll(e);
				},
				{
					passive: false
				}
			);
		}
	};

	_proto3.submitOnEnter = function submitOnEnter(e) {
		var instance = this.props.instance.parent;

		while (instance) {
			if (instance.events && instance.events.onSubmit) {
				instance.events.onSubmit(e, instance);
				break;
			} else {
				instance = instance.parent;
			}
		}
	};

	return LookupComponent;
})(VDOM.Component);

enableCultureSensitiveFormatting();
var NumberField = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(NumberField, _Field);

	function NumberField() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = NumberField.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: this.emptyValue,
					disabled: undefined,
					readOnly: undefined,
					enabled: undefined,
					placeholder: undefined,
					required: undefined,
					format: undefined,
					minValue: undefined,
					maxValue: undefined,
					minExclusive: undefined,
					maxExclusive: undefined,
					incrementPercentage: undefined,
					increment: undefined,
					icon: undefined,
					scale: undefined,
					offset: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (isDefined(this.step)) this.increment = this.step;
		if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
		if (this.alwaysShowClear) this.showClear = true;

		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data,
			state = instance.state,
			cached = instance.cached;
		data.formatted = Format.value(data.value, data.format);
		if (!cached.data || data.value != cached.data.value) state.empty = data.value == null;

		_Field.prototype.prepareData.call(this, context, instance);
	};

	_proto.formatValue = function formatValue(context, _ref) {
		var data = _ref.data;
		return data.formatted;
	};

	_proto.parseValue = function parseValue(value, instance) {
		if (this.onParseInput) {
			var result = instance.invoke("onParseInput", value, instance);
			if (result !== undefined) return result;
		}

		return Culture.getNumberCulture().parse(value);
	};

	_proto.validate = function validate(context, instance) {
		_Field.prototype.validate.call(this, context, instance);

		var data = instance.data;

		if (isNumber(data.value) && !data.error) {
			if (isNumber(data.minValue)) {
				if (data.value < data.minValue)
					data.error = StringTemplate.format(this.minValueErrorText, Format.value(data.minValue, data.format));
				else if (data.value == data.minValue && data.minExclusive)
					data.error = StringTemplate.format(this.minExclusiveErrorText, Format.value(data.minValue, data.format));
			}

			if (isNumber(data.maxValue)) {
				if (data.value > data.maxValue)
					data.error = StringTemplate.format(this.maxValueErrorText, Format.value(data.maxValue, data.format));
				else if (data.value == data.maxValue && data.maxExclusive)
					data.error = StringTemplate.format(this.maxExclusiveErrorText, Format.value(data.maxValue, data.format));
			}
		}
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			Input$1,
			{
				data: instance.data,
				instance: instance,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			},
			key
		);
	};

	_proto.validateRequired = function validateRequired(context, instance) {
		return instance.state.empty && this.requiredText;
	};

	return NumberField;
})(Field);
NumberField.prototype.baseClass = "numberfield";
NumberField.prototype.reactOn = "enter blur";
NumberField.prototype.format = "n";
NumberField.prototype.inputType = "text";
NumberField.prototype.maxValueErrorText = "Enter {0} or less.";
NumberField.prototype.maxExclusiveErrorText = "Enter a number less than {0}.";
NumberField.prototype.minValueErrorText = "Enter {0} or more.";
NumberField.prototype.minExclusiveErrorText = "Enter a number greater than {0}.";
NumberField.prototype.inputErrorText = "Invalid number entered.";
NumberField.prototype.suppressErrorsUntilVisited = true;
NumberField.prototype.incrementPercentage = 0.1;
NumberField.prototype.scale = 1;
NumberField.prototype.offset = 0;
NumberField.prototype.snapToIncrement = true;
NumberField.prototype.icon = null;
NumberField.prototype.showClear = false;
NumberField.prototype.alwaysShowClear = false;
Widget.alias("numberfield", NumberField);
Localization.registerPrototype("cx/widgets/NumberField", NumberField);

var Input$1 = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(Input, _VDOM$Component);

	function Input(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			focus: false
		};
		return _this;
	}

	var _proto2 = Input.prototype;

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			data = _this$props.data,
			instance = _this$props.instance,
			label = _this$props.label,
			help = _this$props.help;
		var widget = instance.widget,
			state = instance.state;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;

		var icon =
			data.icon &&
			/*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "left-icon"),
				children: Icon.render(data.icon, {
					className: CSS.element(baseClass, "icon")
				})
			});

		var insideButton;

		if (!data.readOnly && !data.disabled) {
			if (
				widget.showClear &&
				(((widget.alwaysShowClear || !data.required) && !data.empty) || instance.state.inputError)
			)
				insideButton = /*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "clear"),
					onMouseDown: function onMouseDown(e) {
						return e.preventDefault();
					},
					onClick: function onClick(e) {
						return _this2.onClearClick(e);
					},
					children: /*#__PURE__*/ jsx(ClearIcon, {
						className: CSS.element(baseClass, "icon")
					})
				});
		}

		var empty = this.input ? !this.input.value : data.empty;
		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(
				data.classNames,
				CSS.state({
					visited: state.visited,
					focus: this.state.focus,
					icon: !!icon,
					empty: empty && !data.placeholder,
					error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
				})
			),
			style: data.style,
			onMouseDown: stopPropagation,
			onTouchStart: stopPropagation,
			children: [
				/*#__PURE__*/ jsx(
					"input",
					_objectSpread2(
						_objectSpread2(
							{
								id: data.id,
								type: widget.inputType,
								className: CSS.expand(CSS.element(baseClass, "input"), data.inputClass),
								defaultValue: data.formatted,
								ref: function ref(el) {
									_this2.input = el;
								},
								style: data.inputStyle,
								disabled: data.disabled,
								readOnly: data.readOnly,
								tabIndex: data.tabIndex,
								placeholder: data.placeholder
							},
							data.inputAttrs
						),
						{},
						{
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this2.props.instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(_this2.props.instance)));
							},
							onChange: function onChange(e) {
								return _this2.onChange(e, "change");
							},
							onKeyDown: this.onKeyDown.bind(this),
							onBlur: function onBlur(e) {
								_this2.onChange(e, "blur");
							},
							onFocus: function onFocus(e) {
								return _this2.onFocus();
							},
							onWheel: function onWheel(e) {
								_this2.onChange(e, "wheel");
							},
							onClick: stopPropagation
						}
					)
				),
				insideButton,
				icon,
				label,
				help
			]
		});
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var _props$instance = props.instance,
			data = _props$instance.data,
			state = _props$instance.state;

		if (this.props.data.formatted != data.formatted && !state.inputError) {
			this.input.value = props.data.formatted || "";
			props.instance.setState({
				inputError: false
			});
		}

		tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(props.instance)));
	};

	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
		autoFocus(this.input, this);
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		autoFocus(this.input, this);
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.getPreCursorDigits = function getPreCursorDigits(text, cursor, decimalSeparator) {
		var res = "";

		for (var i = 0; i < cursor; i++) {
			if ("0" <= text[i] && text[i] <= "9") res += text[i];
			else if (text[i] == decimalSeparator) res += ".";
			else if (text[i] == "-") res += "-";
		}

		return res;
	};

	_proto2.getLengthWithoutSuffix = function getLengthWithoutSuffix(text, decimalSeparator) {
		var l = text.length;

		while (l > 0) {
			if ("0" <= text[l - 1] && text[l - 1] <= "9") break;
			if (text[l - 1] == decimalSeparator) break;
			l--;
		}

		return l;
	};

	_proto2.getDecimalSeparator = function getDecimalSeparator(format) {
		var text = Format.value(0.11111111, format);

		for (var i = text.length - 1; i >= 0; i--) {
			if ("0" <= text[i] && text[i] <= "9") continue;
			if (text[i] == "," || text[i] == ".") return text[i];
			break;
		}

		return null;
	};

	_proto2.updateCursorPosition = function updateCursorPosition(preCursorText) {
		if (isString(preCursorText)) {
			var cursor = 0;
			var preCursor = 0;
			var text = this.input.value || "";

			while (preCursor < preCursorText.length && cursor < text.length) {
				if (text[cursor] == preCursorText[preCursor]) {
					cursor++;
					preCursor++;
				} else {
					cursor++;
				}
			}

			this.input.setSelectionRange(cursor, cursor);
		}
	};

	_proto2.calculateIncrement = function calculateIncrement(value, strength) {
		if (value == 0) return 0.1;
		var absValue = Math.abs(value * strength);
		var log10 = Math.floor(Math.log10(absValue) + 0.001);
		var size = Math.pow(10, log10);
		if (absValue / size > 4.999) return 5 * size;
		if (absValue / size > 1.999) return 2 * size;
		return size;
	};

	_proto2.onClearClick = function onClearClick(e) {
		this.input.value = "";
		var instance = this.props.instance;
		instance.set("value", instance.widget.emptyValue, {
			immediate: true
		});
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.enter:
				this.onChange(e, "enter");
				break;

			case KeyCode.left:
			case KeyCode.right:
				e.stopPropagation();
				break;
		}
	};

	_proto2.onChange = function onChange(e, change) {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data;
		var widget = instance.widget;

		if (data.required) {
			instance.setState({
				empty: !e.target.value
			});
		}

		if (change == "blur" && this.state.focus) {
			this.setState({
				focus: false
			});
		}

		var immediate = change == "blur" || change == "enter";
		if ((widget.reactOn.indexOf(change) == -1 && !immediate) || data.disabled || data.readOnly) return;
		if (immediate)
			instance.setState({
				visited: true
			});
		var value = null;

		if (e.target.value) {
			var displayValue = widget.parseValue(e.target.value, instance);

			if (isNaN(displayValue)) {
				instance.setState({
					inputError: instance.widget.inputErrorText
				});
				return;
			}

			value = displayValue * data.scale + data.offset;

			if (change == "wheel") {
				e.preventDefault();
				var increment =
					data.increment != null ? data.increment : this.calculateIncrement(value, data.incrementPercentage);
				value = value + (e.deltaY < 0 ? increment : -increment);

				if (widget.snapToIncrement) {
					value = Math.round(value / increment) * increment;
				}

				if (data.minValue != null) {
					if (data.minExclusive) {
						if (value <= data.minValue) return;
					} else {
						value = Math.max(value, data.minValue);
					}
				}

				if (data.maxValue != null) {
					if (data.maxExclusive) {
						if (value >= data.maxValue) return;
					} else {
						value = Math.min(value, data.maxValue);
					}
				}
			}

			var fmt = data.format;
			var decimalSeparator = this.getDecimalSeparator(fmt) || Format.value(1.1, "n;1")[1];
			var formatted = Format.value(value, fmt); //re-parse to avoid differences between formatted value and value in the store

			value = widget.parseValue(formatted, instance) * data.scale + data.offset; //allow users to type numbers like 100.0003 without interruptions
			//if the last typed in character is zero or dot (decimal separator) skip processing it

			if (
				change == "change" &&
				this.input.selectionStart == this.input.selectionEnd &&
				this.input.selectionEnd >= this.getLengthWithoutSuffix(this.input.value, decimalSeparator) &&
				(e.target.value[this.input.selectionEnd - 1] == decimalSeparator ||
					(e.target.value.indexOf(decimalSeparator) >= 0 && e.target.value[this.input.selectionEnd - 1] == "0"))
			)
				return;

			if (change != "blur") {
				//format, but keep the correct cursor position
				var preCursorText = this.getPreCursorDigits(this.input.value, this.input.selectionStart, decimalSeparator);
				this.input.value = formatted;
				this.updateCursorPosition(preCursorText);
			} else {
				this.input.value = formatted;
			}
		}

		instance.set("value", value, {
			immediate: immediate
		});
		instance.setState({
			inputError: false,
			visited: true
		});
	};

	_proto2.onFocus = function onFocus() {
		var instance = this.props.instance;
		var widget = instance.widget;

		if (widget.trackFocus) {
			this.setState({
				focus: true
			});
		}
	};

	return Input;
})(VDOM.Component);

var TextArea = /*#__PURE__*/ (function(_TextField) {
	_inheritsLoose(TextArea, _TextField);

	function TextArea() {
		return _TextField.apply(this, arguments) || this;
	}

	var _proto = TextArea.prototype;

	_proto.declareData = function declareData() {
		var _TextField$prototype$;

		(_TextField$prototype$ = _TextField.prototype.declareData).call.apply(
			_TextField$prototype$,
			[
				this,
				{
					rows: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var state = instance.state,
			data = instance.data,
			cached = instance.cached;
		if (!cached.data || data.value != cached.data.value) state.empty = !data.value;

		_TextField.prototype.prepareData.call(this, context, instance);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			Input$2,
			{
				data: instance.data,
				instance: instance,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			},
			key
		);
	};

	_proto.validateRequired = function validateRequired(context, instance) {
		return instance.state.empty && this.requiredText;
	};

	return TextArea;
})(TextField);
TextArea.prototype.baseClass = "textarea";
TextArea.prototype.reactOn = "blur";
TextArea.prototype.suppressErrorsUntilVisited = true;

var Input$2 = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(Input, _VDOM$Component);

	function Input(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			focus: false
		};
		return _this;
	}

	var _proto2 = Input.prototype;

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			label = _this$props.label,
			help = _this$props.help;
		var widget = instance.widget,
			data = instance.data,
			state = instance.state;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
		var empty = this.input ? !this.input.value : data.empty;
		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(
				data.classNames,
				CSS.state({
					visited: state.visited,
					focus: this.state.focus,
					empty: empty && !data.placeholder,
					error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
				})
			),
			style: data.style,
			onMouseDown: stopPropagation,
			onTouchStart: stopPropagation,
			children: [
				/*#__PURE__*/ jsx(
					"textarea",
					_objectSpread2(
						_objectSpread2(
							{
								className: CSS.element(baseClass, "input"),
								ref: function ref(el) {
									_this2.input = el;
								},
								id: data.id,
								rows: data.rows,
								style: data.inputStyle,
								defaultValue: data.value,
								disabled: data.disabled,
								readOnly: data.readOnly,
								tabIndex: data.tabIndex,
								placeholder: data.placeholder
							},
							data.inputAttrs
						),
						{},
						{
							onInput: function onInput(e) {
								return _this2.onChange(e, "input");
							},
							onChange: function onChange(e) {
								return _this2.onChange(e, "change");
							},
							onBlur: function onBlur(e) {
								_this2.onChange(e, "blur");
							},
							onFocus: function onFocus(e) {
								return _this2.onFocus();
							},
							onClick: stopPropagation,
							onKeyDown: function onKeyDown(e) {
								return _this2.onKeyDown(e);
							},
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
							}
						}
					)
				),
				label,
				help
			]
		});
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
		autoFocus(this.input, this);
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		autoFocus(this.input, this);
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.down:
			case KeyCode.up:
			case KeyCode.left:
			case KeyCode.right:
				e.stopPropagation();
				break;
		}
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(_ref) {
		var data = _ref.data,
			instance = _ref.instance;

		if (data.value != this.props.data.value) {
			this.input.value = data.value || "";
		}

		tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(instance)));
	};

	_proto2.onChange = function onChange(e, change) {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data;
		var widget = instance.widget;

		if (change == "blur") {
			instance.setState({
				visited: true
			});
			if (this.state.focus)
				this.setState({
					focus: false
				});
		}

		if (data.required) {
			instance.setState({
				empty: !e.target.value
			});
		}

		if (instance.widget.reactOn.indexOf(change) != -1) {
			var value = e.target.value || widget.emptyValue;
			instance.set("value", value);
		}
	};

	_proto2.onFocus = function onFocus() {
		var instance = this.props.instance;
		var widget = instance.widget;

		if (widget.trackFocus) {
			this.setState({
				focus: true
			});
		}
	};

	return Input;
})(VDOM.Component);

Widget.alias("textarea", TextArea);

var ValidationGroup = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(ValidationGroup, _PureContainer);

	function ValidationGroup() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = ValidationGroup.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					errors: undefined,
					valid: undefined,
					invalid: undefined,
					disabled: undefined,
					enabled: undefined,
					readOnly: undefined,
					viewMode: undefined,
					tabOnEnterKey: undefined,
					isolated: undefined,
					visited: undefined,
					strict: undefined
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		if (isDefined(instance.data.enabled)) instance.data.disabled = !instance.data.enabled;
		instance.validation = {
			errors: []
		};
		context.push("parentStrict", coalesce(instance.data.strict, context.parentStrict));
		context.push("parentDisabled", coalesce(instance.data.disabled, context.parentDisabled));
		context.push("parentReadOnly", coalesce(instance.data.readOnly, context.parentReadOnly));
		context.push("parentViewMode", coalesce(instance.data.viewMode, context.parentViewMode));
		context.push("parentTabOnEnterKey", coalesce(instance.data.tabOnEnterKey, context.parentTabOnEnterKey));
		context.push("parentVisited", coalesce(instance.data.visited, context.parentVisited));
		context.push("validation", instance.validation);

		_PureContainer.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		var _context$validation$e;

		context.pop("validation");
		context.pop("parentVisited");
		context.pop("parentDisabled");
		context.pop("parentReadOnly");
		context.pop("parentViewMode");
		context.pop("parentTabOnEnterKey");
		context.pop("parentStrict");
		instance.valid = instance.validation.errors.length == 0;
		if (!instance.valid && !this.isolated && context.validation)
			(_context$validation$e = context.validation.errors).push.apply(_context$validation$e, instance.validation.errors);
		instance.set("valid", instance.valid);
		instance.set("invalid", !instance.valid);
		if (this.errors && !shallowEquals(instance.data.errors, instance.validation.errors))
			instance.set("errors", instance.validation.errors);
	};

	return ValidationGroup;
})(PureContainer);
ValidationGroup.prototype.isolated = false;
Widget.alias("validation-group", ValidationGroup);

var FieldGroup = /*#__PURE__*/ (function(_ValidationGroup) {
	_inheritsLoose(FieldGroup, _ValidationGroup);

	function FieldGroup() {
		return _ValidationGroup.apply(this, arguments) || this;
	}

	return FieldGroup;
})(ValidationGroup);
Widget.alias("field-group", FieldGroup);

var LabeledContainer = /*#__PURE__*/ (function(_FieldGroup) {
	_inheritsLoose(LabeledContainer, _FieldGroup);

	function LabeledContainer() {
		return _FieldGroup.apply(this, arguments) || this;
	}

	var _proto = LabeledContainer.prototype;

	_proto.declareData = function declareData() {
		var _FieldGroup$prototype;

		(_FieldGroup$prototype = _FieldGroup.prototype.declareData).call.apply(
			_FieldGroup$prototype,
			[
				this,
				{
					label: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (this.label != null) {
			var labelConfig = {
				type: Label,
				disabled: this.disabled,
				mod: this.mod,
				asterisk: this.asterisk,
				required: true
			};
			if (this.label.isComponentType) labelConfig = this.label;
			else if (isSelector(this.label)) labelConfig.text = this.label;
			else Object.assign(labelConfig, this.label);
			this.label = Widget.create(labelConfig);
		}

		_FieldGroup.prototype.init.call(this);
	};

	_proto.initComponents = function initComponents(context, instance) {
		var _FieldGroup$prototype2;

		return (_FieldGroup$prototype2 = _FieldGroup.prototype.initComponents).call.apply(
			_FieldGroup$prototype2,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					label: this.label
				}
			])
		);
	};

	_proto.renderLabel = function renderLabel(context, instance, key) {
		if (instance.components.label) return instance.components.label.render(context, key);
	};

	_proto.render = function render(context, instance, key) {
		return {
			label: this.renderLabel(context, instance),
			content: this.renderChildren(context, instance)
		};
	};

	return LabeledContainer;
})(FieldGroup);
Widget.alias("labeled-container", LabeledContainer);

enableCultureSensitiveFormatting();
var MonthPicker = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(MonthPicker, _Field);

	function MonthPicker() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = MonthPicker.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		var values = {};

		if (this.mode == "range") {
			this.range = true;
			this.mode = "edit";
			Console.warn('Please use the range flag on MonthPickers. Syntax mode="range" is deprecated.', this);
		}

		if (this.range) {
			values = {
				from: null,
				to: null
			};
		} else {
			values = {
				value: this.emptyValue
			};
		}

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				values,
				{
					refDate: undefined,
					disabled: undefined,
					minValue: undefined,
					minExclusive: undefined,
					maxValue: undefined,
					maxExclusive: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, _ref) {
		var data = _ref.data;
		data.stateMods = {
			disabled: data.disabled
		};
		if (!this.range && data.value) data.date = monthStart(new Date(data.value));

		if (this.range) {
			if (data.from) data.from = monthStart(new Date(data.from));
			if (data.to) data.to = monthStart(new Date(data.to));
		}

		if (data.refDate) data.refDate = monthStart(new Date(data.refDate));
		if (data.maxValue) data.maxValue = monthStart(new Date(data.maxValue));
		if (data.minValue) data.minValue = monthStart(new Date(data.minValue));

		_Field.prototype.prepareData.apply(this, arguments);
	};

	_proto.validate = function validate(context, instance) {
		_Field.prototype.validate.call(this, context, instance);

		var data = instance.data;

		if (!data.error && data.date) {
			var d;

			if (data.maxValue) {
				d = dateDiff(data.date, data.maxValue);
				if (d > 0) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
				else if (d == 0 && data.maxExclusive)
					data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
			}

			if (data.minValue) {
				d = dateDiff(data.date, data.minValue);
				if (d < 0) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
				else if (d == 0 && data.minExclusive)
					data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
			}
		}
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			MonthPickerComponent,
			{
				instance: instance,
				onBlur: this.onBlur,
				onFocusOut: this.onFocusOut,
				onKeyDown: this.onKeyDown,
				autoFocus: this.autoFocus
			},
			key
		);
	};

	_proto.handleSelect = function handleSelect(e, instance, date1, date2) {
		var data = instance.data;
		if (data.disabled) return;
		if (!validationCheck$1(date1, data)) return;
		if (this.onBeforeSelect && instance.invoke("onBeforeSelect", e, instance, date1, date2) === false) return;

		if (this.range) {
			instance.set("from", date1.toISOString());
			instance.set("to", date2.toISOString());
		} else instance.set("value", date1.toISOString());

		if (this.onSelect) instance.invoke("onSelect", instance, date1, date2);
	};

	return MonthPicker;
})(Field);
MonthPicker.prototype.baseClass = "monthpicker";
MonthPicker.prototype.range = false;
MonthPicker.prototype.startYear = 1980;
MonthPicker.prototype.endYear = 2030;
MonthPicker.prototype.bufferSize = 15; // Localization

MonthPicker.prototype.maxValueErrorText = "Select {0:d} or before.";
MonthPicker.prototype.maxExclusiveErrorText = "Select a date before {0:d}.";
MonthPicker.prototype.minValueErrorText = "Select {0:d} or later.";
MonthPicker.prototype.minExclusiveErrorText = "Select a date after {0:d}.";
Localization.registerPrototype("cx/widgets/MonthPicker", MonthPicker);
Widget.alias("month-picker", MonthPicker);

var validationCheck$1 = function validationCheck(date, data) {
	if (data.maxValue && !upperBoundCheck(date, data.maxValue, data.maxExclusive)) return false;
	if (data.minValue && !lowerBoundCheck(date, data.minValue, data.minExclusive)) return false;
	return true;
};

var monthNumber = function monthNumber(date) {
	return date.getFullYear() * 12 + date.getMonth();
};

var MonthPickerComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(MonthPickerComponent, _VDOM$Component);

	function MonthPickerComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		var _props$instance = props.instance,
			data = _props$instance.data,
			widget = _props$instance.widget;
		var cursor = monthStart(data.refDate ? data.refDate : data.date || data.from || new Date());
		_this.dom = {};
		_this.state = {
			cursorYear: cursor.getFullYear(),
			cursorMonth: cursor.getMonth() + 1,
			cursorQuarter: cursor.getMonth() / 3,
			column: "M",
			start: widget.startYear,
			end: widget.startYear + widget.bufferSize
		};
		_this.handleMouseDown = _this.handleMouseDown.bind(_assertThisInitialized(_this));
		_this.handleMouseUp = _this.handleMouseUp.bind(_assertThisInitialized(_this));
		_this.handleMouseEnter = _this.handleMouseEnter.bind(_assertThisInitialized(_this));
		_this.handleKeyPress = _this.handleKeyPress.bind(_assertThisInitialized(_this));
		_this.handleTouchMove = _this.handleTouchMove.bind(_assertThisInitialized(_this));
		_this.handleTouchEnd = _this.handleTouchEnd.bind(_assertThisInitialized(_this));
		return _this;
	}

	var _proto2 = MonthPickerComponent.prototype;

	_proto2.extractCursorInfo = function extractCursorInfo(el) {
		if (!el.attributes["data-point"].value) return false;
		var parts = el.attributes["data-point"].value.split("-");
		if (parts[0] != "Y") return false;
		var cursor = {
			column: "Y",
			cursorYear: Number(parts[1])
		};

		if (parts.length == 4) {
			cursor.column = parts[2];
			if (cursor.column == "M") cursor.cursorMonth = Number(parts[3]);
			else cursor.cursorQuarter = Number(parts[3]);
		}

		return cursor;
	};

	_proto2.moveCursor = function moveCursor(e, data, options) {
		var _this2 = this;

		if (options === void 0) {
			options = {};
		}

		e.preventDefault();
		e.stopPropagation();

		if (data.cursorYear) {
			var _this$props$instance$ = this.props.instance.widget,
				startYear = _this$props$instance$.startYear,
				endYear = _this$props$instance$.endYear;
			data.cursorYear = Math.max(startYear, Math.min(endYear, data.cursorYear));
		}

		if (
			Object.keys(data).every(function(k) {
				return _this2.state[k] == data[k];
			})
		)
			return;
		this.setState(data, function() {
			if (options.ensureVisible) {
				var index = _this2.state.cursorYear - _this2.state.start;
				var tbody = _this2.dom.table.children[index];
				if (tbody) scrollElementIntoView(tbody);
			}
		});
	};

	_proto2.handleKeyPress = function handleKeyPress(e) {
		var widget = this.props.instance.widget;
		var _this$state = this.state,
			cursorMonth = _this$state.cursorMonth,
			cursorYear = _this$state.cursorYear,
			cursorQuarter = _this$state.cursorQuarter,
			column = _this$state.column;

		switch (e.keyCode) {
			case KeyCode.enter:
				// if (widget.range && e.shiftKey && !this.dragStartDates) {
				//    this.handleMouseDown(e, {}, false);
				// } else {
				//    this.handleMouseUp(e);
				// }
				this.handleMouseUp(e);
				e.preventDefault();
				e.stopPropagation();
				break;

			case KeyCode.left:
				if (column == "Y")
					this.moveCursor(e, {
						cursorQuarter: 3,
						cursorYear: cursorYear - 1,
						column: "Q"
					});
				else if (column == "Q")
					this.moveCursor(e, {
						cursorMonth: cursorQuarter * 4,
						column: "M"
					});
				else if (column == "M" && (cursorMonth - 1) % 3 == 0)
					this.moveCursor(e, {
						column: "Y"
					});
				else
					this.moveCursor(e, {
						cursorMonth: cursorMonth - 1
					});
				break;

			case KeyCode.right:
				if (column == "Y")
					this.moveCursor(e, {
						cursorMonth: 1,
						column: "M"
					});
				else if (column == "Q")
					this.moveCursor(e, {
						column: "Y",
						cursorYear: cursorQuarter == 3 ? cursorYear + 1 : cursorYear
					});
				else if (column == "M" && (cursorMonth - 1) % 3 == 2)
					this.moveCursor(e, {
						column: "Q",
						cursorQuarter: Math.floor((cursorMonth - 1) / 3)
					});
				else
					this.moveCursor(e, {
						cursorMonth: cursorMonth + 1
					});
				break;

			case KeyCode.up:
				if (column == "Y")
					this.moveCursor(
						e,
						{
							cursorYear: cursorYear - 1
						},
						{
							ensureVisible: true
						}
					);
				else if (column == "Q")
					this.moveCursor(
						e,
						{
							cursorQuarter: (cursorQuarter + 3) % 4,
							cursorYear: cursorQuarter == 0 ? cursorYear - 1 : cursorYear
						},
						{
							ensureVisible: true
						}
					);
				else if (column == "M")
					if (cursorMonth > 3)
						this.moveCursor(
							e,
							{
								cursorMonth: cursorMonth - 3
							},
							{
								ensureVisible: true
							}
						);
					else
						this.moveCursor(
							e,
							{
								cursorMonth: cursorMonth + 9,
								cursorYear: cursorYear - 1
							},
							{
								ensureVisible: true
							}
						);
				break;

			case KeyCode.down:
				if (column == "Y")
					this.moveCursor(
						e,
						{
							cursorYear: cursorYear + 1
						},
						{
							ensureVisible: true
						}
					);
				else if (column == "Q")
					this.moveCursor(
						e,
						{
							cursorQuarter: (cursorQuarter + 1) % 4,
							cursorYear: cursorQuarter == 3 ? cursorYear + 1 : cursorYear
						},
						{
							ensureVisible: true
						}
					);
				else if (column == "M")
					if (cursorMonth < 10)
						this.moveCursor(
							e,
							{
								cursorMonth: cursorMonth + 3
							},
							{
								ensureVisible: true
							}
						);
					else
						this.moveCursor(
							e,
							{
								cursorMonth: cursorMonth - 9,
								cursorYear: cursorYear + 1
							},
							{
								ensureVisible: true
							}
						);
				break;

			case KeyCode.pageUp:
				this.moveCursor(e, {
					cursorYear: this.state.cursorYear - 1
				});
				break;

			case KeyCode.pageDown:
				this.moveCursor(e, {
					cursorYear: this.state.cursorYear + 1
				});
				break;

			default:
				if (this.props.onKeyDown) this.props.onKeyDown(e, this.props.instance);
				break;
		}
	};

	_proto2.handleBlur = function handleBlur(e) {
		FocusManager.nudge();
		if (this.props.onBlur) this.props.onBlur();
		this.setState({
			focused: false
		});
	};

	_proto2.handleFocus = function handleFocus(e) {
		this.setState({
			focused: true
		});
		if (this.props.onFocusOut) oneFocusOut(this, this.dom.el, this.handleFocusOut.bind(this));
	};

	_proto2.handleFocusOut = function handleFocusOut() {
		if (this.props.onFocusOut) this.props.onFocusOut();
	};

	_proto2.getCursorDates = function getCursorDates(cursor) {
		var _ref2 = cursor || this.state,
			cursorMonth = _ref2.cursorMonth,
			cursorYear = _ref2.cursorYear,
			cursorQuarter = _ref2.cursorQuarter,
			column = _ref2.column;

		switch (column) {
			case "M":
				return [new Date(cursorYear, cursorMonth - 1, 1), new Date(cursorYear, cursorMonth, 1)];

			case "Q":
				return [new Date(cursorYear, cursorQuarter * 3, 1), new Date(cursorYear, cursorQuarter * 3 + 3, 1)];

			case "Y":
				return [new Date(cursorYear, 0, 1), new Date(cursorYear + 1, 0, 1)];
		}
	};

	_proto2.handleTouchMove = function handleTouchMove(e) {
		var cursor = getCursorPos(e);
		var el = document.elementFromPoint(cursor.clientX, cursor.clientY);

		if (this.dom.table.contains(el) && isString(el.dataset.point)) {
			var _cursor = this.extractCursorInfo(el);

			this.moveCursor(e, _cursor);
		}
	};

	_proto2.handleTouchEnd = function handleTouchEnd(e) {
		if (this.state.state == "drag") this.handleMouseUp(e);
	};

	_proto2.handleMouseEnter = function handleMouseEnter(e) {
		var cursor = this.extractCursorInfo(e.target);
		cursor.hover = !isTouchEvent();
		this.moveCursor(e, cursor);
	};

	_proto2.handleMouseDown = function handleMouseDown(e, cursor, drag) {
		if (drag === void 0) {
			drag = true;
		}

		var instance = this.props.instance;
		var widget = instance.widget;

		if (!cursor) {
			cursor = this.extractCursorInfo(e.currentTarget);
			this.moveCursor(e, cursor);
		}

		e.stopPropagation();
		preventFocusOnTouch(e);
		this.dragStartDates = this.getCursorDates(cursor);

		if (drag) {
			this.setState(
				_objectSpread2(
					{
						state: "drag"
					},
					cursor
				)
			);
		}
	};

	_proto2.handleMouseUp = function handleMouseUp(e) {
		var instance = this.props.instance;
		var widget = instance.widget,
			data = instance.data;
		e.stopPropagation();
		e.preventDefault();

		var _this$getCursorDates = this.getCursorDates(),
			cursorFromDate = _this$getCursorDates[0],
			cursorToDate = _this$getCursorDates[1];

		var originFromDate = cursorFromDate,
			originToDate = cursorToDate;

		if (widget.range && e.shiftKey) {
			if (data.from) originFromDate = data.from;
			if (data.to) originToDate = data.to;
		} else if (this.state.state == "drag") {
			if (widget.range) {
				var _this$dragStartDates = this.dragStartDates;
				originFromDate = _this$dragStartDates[0];
				originToDate = _this$dragStartDates[1];
			}

			this.setState({
				state: "normal"
			});
		} else {
			//skip mouse events originated somewhere else
			if (e.type != "keydown") return;
		}

		widget.handleSelect(e, instance, minDate(originFromDate, cursorFromDate), maxDate(originToDate, cursorToDate));
	};

	_proto2.render = function render() {
		var _this3 = this;

		var _this$props$instance = this.props.instance,
			data = _this$props$instance.data,
			widget = _this$props$instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			startYear = widget.startYear,
			endYear = widget.endYear;
		var years = [];
		var _this$state2 = this.state,
			start = _this$state2.start,
			end = _this$state2.end;
		var from = 10000,
			to = 0,
			a,
			b;

		if (data.date && !widget.range) {
			from = monthNumber(data.date);
			to = from + 0.1;
		} else if (widget.range) {
			if (this.state.state == "drag") {
				var _this$dragStartDates2 = this.dragStartDates,
					originFromDate = _this$dragStartDates2[0],
					originToDate = _this$dragStartDates2[1];

				var _this$getCursorDates2 = this.getCursorDates(),
					cursorFromDate = _this$getCursorDates2[0],
					cursorToDate = _this$getCursorDates2[1];

				a = Math.min(monthNumber(originFromDate), monthNumber(cursorFromDate));
				b = Math.max(monthNumber(originToDate), monthNumber(cursorToDate));
				from = Math.min(a, b);
				to = Math.max(a, b);
			} else if (data.from && data.to) {
				a = monthNumber(data.from);
				b = monthNumber(data.to);
				from = Math.min(a, b);
				to = Math.max(a, b);
			}
		}

		var monthNames = Culture.getDateTimeCulture().getMonthNames("short");
		var showCursor = this.state.hover || this.state.focused;

		for (var y = start; y <= end; y++) {
			var rows = [];

			for (var q = 0; q < 4; q++) {
				var row = [];
				if (q == 0)
					row.push(
						/*#__PURE__*/ jsx(
							"th",
							{
								rowSpan: 4,
								"data-point": "Y-" + y,
								className: CSS.element(baseClass, "year", {
									cursor: showCursor && this.state.column == "Y" && y == this.state.cursorYear
								}),
								onMouseEnter: this.handleMouseEnter,
								onMouseDown: this.handleMouseDown,
								onMouseUp: this.handleMouseUp,
								children: y
							},
							"year"
						)
					);

				for (var i = 0; i < 3; i++) {
					var m = q * 3 + i + 1;
					var unselectable = !validationCheck$1(new Date(y, m - 1, 1), data);
					var mno = y * 12 + m - 1;
					var handle = true; //isTouchDevice(); //mno === from || mno === to - 1;

					row.push(
						/*#__PURE__*/ jsx(
							"td",
							{
								className: CSS.state({
									cursor:
										showCursor && this.state.column == "M" && y == this.state.cursorYear && m == this.state.cursorMonth,
									handle: handle,
									selected: mno >= from && mno < to,
									unselectable: unselectable
								}),
								"data-point": "Y-" + y + "-M-" + m,
								onMouseEnter: unselectable ? null : this.handleMouseEnter,
								onMouseDown: unselectable ? null : this.handleMouseDown,
								onMouseUp: unselectable ? null : this.handleMouseUp,
								onTouchStart: unselectable ? null : this.handleMouseDown,
								onTouchMove: unselectable ? null : this.handleTouchMove,
								onTouchEnd: this.handleMouseUp,
								children: monthNames[m - 1].substr(0, 3)
							},
							"M" + m
						)
					);
				}

				row.push(
					/*#__PURE__*/ jsx(
						"th",
						{
							className: CSS.state({
								cursor:
									showCursor && this.state.column == "Q" && y == this.state.cursorYear && q == this.state.cursorQuarter
							}),
							"data-point": "Y-" + y + "-Q-" + q,
							onMouseEnter: this.handleMouseEnter,
							onMouseDown: this.handleMouseDown,
							onMouseUp: this.handleMouseUp,
							children: "Q" + (q + 1)
						},
						"q" + q
					)
				);
				rows.push(row);
			}

			years.push(rows);
		}

		return /*#__PURE__*/ jsxs("div", {
			ref: function ref(el) {
				_this3.dom.el = el;
			},
			className: data.classNames,
			style: data.style,
			tabIndex: data.disabled ? null : data.tabIndex || 0,
			onKeyDown: this.handleKeyPress,
			onMouseDown: stopPropagation,
			onMouseMove: function onMouseMove(e) {
				return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
			},
			onMouseLeave: this.handleMouseLeave.bind(this),
			onFocus: function onFocus(e) {
				return _this3.handleFocus(e);
			},
			onBlur: this.handleBlur.bind(this),
			onScroll: this.onScroll.bind(this),
			children: [
				this.state.yearHeight &&
					/*#__PURE__*/ jsx("div", {
						style: {
							height: (start - startYear) * this.state.yearHeight + "px"
						}
					}),
				/*#__PURE__*/ jsx("table", {
					ref: function ref(el) {
						_this3.dom.table = el;
					},
					children: years.map(function(rows, y) {
						return /*#__PURE__*/ jsx(
							"tbody",
							{
								children: rows.map(function(cells, i) {
									return /*#__PURE__*/ jsx(
										"tr",
										{
											children: cells
										},
										i
									);
								})
							},
							start + y
						);
					})
				}),
				this.state.yearHeight &&
					/*#__PURE__*/ jsx("div", {
						style: {
							height: Math.max(0, endYear - end) * this.state.yearHeight + "px"
						}
					})
			]
		});
	};

	_proto2.onScroll = function onScroll() {
		var _this$props$instance$2 = this.props.instance.widget,
			startYear = _this$props$instance$2.startYear,
			endYear = _this$props$instance$2.endYear,
			bufferSize = _this$props$instance$2.bufferSize;
		var visibleItems = ceil5(Math.ceil(this.dom.el.offsetHeight / this.state.yearHeight));
		var start = Math.max(
			startYear,
			startYear + floor5(Math.floor(this.dom.el.scrollTop / this.state.yearHeight)) - visibleItems
		);

		if (start != this.state.start && start + bufferSize <= endYear) {
			this.setState({
				start: start,
				end: start + 15
			});
		}
	};

	_proto2.handleMouseLeave = function handleMouseLeave(e) {
		tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(this.props.instance)));
		this.moveCursor(e, {
			hover: false
		});
	};

	_proto2.componentDidMount = function componentDidMount() {
		var _this4 = this;

		//non-input, ok to focus on mobile
		if (this.props.autoFocus) this.dom.el.focus();
		tooltipParentDidMount.apply(void 0, [this.dom.el].concat(getFieldTooltip(this.props.instance)));
		var yearHeight = this.dom.table.scrollHeight / (this.props.instance.widget.bufferSize + 1);
		this.setState(
			{
				yearHeight: yearHeight
			},
			function() {
				var _this4$props$instance = _this4.props.instance,
					widget = _this4$props$instance.widget,
					data = _this4$props$instance.data;
				var startYear = widget.startYear;
				var yearCount = 1;

				if (widget.range && data.from && data.to) {
					yearCount = data.to.getFullYear() - data.from.getFullYear() + 1;
					if (data.to.getMonth() == 0 && data.to.getDate() == 1) yearCount--;
				}

				_this4.dom.el.scrollTop =
					(_this4.state.cursorYear - startYear + yearCount / 2) * _this4.state.yearHeight -
					_this4.dom.el.offsetHeight / 2;
			}
		);
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		this.setState({
			state: "normal"
		});
		tooltipParentWillReceiveProps.apply(void 0, [this.dom.el].concat(getFieldTooltip(props.instance)));
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		offFocusOut(this);
		tooltipParentWillUnmount(this.props.instance);
	};

	return MonthPickerComponent;
})(VDOM.Component);

function ceil5(x) {
	return Math.ceil(x / 5) * 5;
}

function floor5(x) {
	return Math.floor(x / 5) * 5;
}

var ColorPicker = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(ColorPicker, _Field);

	function ColorPicker() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = ColorPicker.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: this.emptyValue,
					format: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			ColorPickerComponent,
			{
				instance: instance
			},
			key
		);
	};

	_proto.handleEvent = function handleEvent(eventType, instance, color) {
		var data = instance.data;

		if (this.reportOn.indexOf(eventType) != -1) {
			var value;

			switch (data.format) {
				default:
				case "rgba":
					value =
						"rgba(" +
						color.r.toFixed(0) +
						"," +
						color.g.toFixed(0) +
						"," +
						color.b.toFixed(0) +
						"," +
						Math.round(color.a * 100) / 100 +
						")";
					break;

				case "hsla":
					value =
						"hsla(" +
						color.h.toFixed(0) +
						"," +
						color.s.toFixed(0) +
						"%," +
						color.l.toFixed(0) +
						"%," +
						Math.round(color.a * 100) / 100 +
						")";
					break;

				case "hex":
					value = rgbToHex(color.r, color.g, color.b);
					break;
			}

			instance.set("value", value);
		}
	};

	return ColorPicker;
})(Field);
ColorPicker.prototype.baseClass = "colorpicker";
ColorPicker.prototype.reportOn = "blur change";
ColorPicker.prototype.format = "rgba";
Widget.alias("color-picker", ColorPicker);

var ColorPickerComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(ColorPickerComponent, _VDOM$Component);

	function ColorPickerComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.data = props.instance.data;

		try {
			_this.state = _this.parse(props.instance.data.value);
		} catch (e) {
			//if web colors are used (e.g. red), fallback to the default color
			_this.state = _this.parse(null);
		}

		return _this;
	}

	var _proto2 = ColorPickerComponent.prototype;

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var data = props.instance.data;
		var color = this.parse(data.value);
		if (color.r != this.state.r || color.g != this.state.g || color.b != this.state.b || color.a != this.state.a)
			this.setState(color);
	};

	_proto2.parse = function parse(color) {
		var c = parseColor(color);

		if (c == null) {
			c = {
				type: "rgba",
				r: 128,
				g: 128,
				b: 128,
				a: 0
			};
		}

		c.a = Math.round(c.a * 100) / 100;

		if (c.type == "rgba") {
			var _rgbToHsl = rgbToHsl(c.r, c.g, c.b),
				h = _rgbToHsl[0],
				s = _rgbToHsl[1],
				l = _rgbToHsl[2];

			return {
				r: c.r,
				g: c.g,
				b: c.b,
				h: h,
				s: s,
				l: l,
				a: c.a
			};
		}

		if (c.type == "hsla") {
			var _hslToRgb = hslToRgb(c.h, c.s, c.l),
				r = _hslToRgb[0],
				g = _hslToRgb[1],
				b = _hslToRgb[2];

			r = this.fix255(r);
			g = this.fix255(g);
			b = this.fix255(b);
			return {
				r: r,
				g: g,
				b: b,
				h: c.h,
				s: c.s,
				l: c.l,
				a: c.a
			};
		}

		throw new Error("Color " + color + " parsing failed.");
	};

	_proto2.render = function render() {
		var _this2 = this;

		var _this$state = this.state,
			h = _this$state.h,
			s = _this$state.s,
			l = _this$state.l,
			a = _this$state.a,
			r = _this$state.r,
			g = _this$state.g,
			b = _this$state.b;
		var instance = this.props.instance;
		var widget = instance.widget,
			data = instance.data;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var hcolor = "hsl(" + h + ",100%,50%)";
		var hsla = "hsla(" + h.toFixed(0) + "," + s.toFixed(0) + "%," + l.toFixed(0) + "%," + a + ")";
		var rgba = "rgba(" + r.toFixed(0) + "," + g.toFixed(0) + "," + b.toFixed(0) + "," + a + ")";
		var hex = rgbToHex(r, g, b);
		var alphaGradient =
			getVendorPrefix("css") +
			"linear-gradient(left, hsla(" +
			h +
			"," +
			s +
			"%," +
			l +
			"%,0) 0%, hsla(" +
			h +
			"," +
			s +
			"%," +
			l +
			"%,1) 100%)";
		return /*#__PURE__*/ jsxs("div", {
			className: data.classNames,
			style: data.style,
			onBlur: this.onBlur.bind(this),
			onMouseDown: stopPropagation,
			onTouchStart: stopPropagation,
			children: [
				/*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "picker"),
					style: {
						backgroundColor: hcolor
					},
					onMouseDown: this.onSLSelect.bind(this),
					onTouchStart: this.onSLSelect.bind(this),
					children: /*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "indicator"),
						style: {
							left: "calc(" + s + "% - 4px)",
							top: "calc(" + (100 - l) + "% - 4px)",
							borderColor:
								"rgba(" + (r < 128 ? 255 : 0) + ", " + (g < 128 ? 255 : 0) + ", " + (b < 128 ? 255 : 0) + ", 0.5)"
						}
					})
				}),
				/*#__PURE__*/ jsxs("div", {
					className: CSS.element(baseClass, "details"),
					children: [
						/*#__PURE__*/ jsx("div", {
							className: CSS.element(baseClass, "hue"),
							onMouseDown: this.onHueSelect.bind(this),
							onTouchStart: this.onHueSelect.bind(this),
							onWheel: function onWheel(e) {
								_this2.onWheel(e, "h", 10);
							},
							children: /*#__PURE__*/ jsx("div", {
								className: CSS.element(baseClass, "indicator"),
								style: {
									left: "calc(" + h / 3.6 + "% - 2px)"
								}
							})
						}),
						/*#__PURE__*/ jsxs("div", {
							className: CSS.element(baseClass, "inputs"),
							children: [
								/*#__PURE__*/ jsxs("label", {
									children: [
										"H ",
										/*#__PURE__*/ jsx("input", {
											value: h.toFixed(0),
											onChange: function onChange(e) {
												_this2.onNumberChange(e, "h");
											},
											onWheel: function onWheel(e) {
												_this2.onWheel(e, "h", 10);
											}
										})
									]
								}),
								/*#__PURE__*/ jsxs("label", {
									children: [
										"S ",
										/*#__PURE__*/ jsx("input", {
											value: s.toFixed(0),
											onChange: function onChange(e) {
												_this2.onNumberChange(e, "s");
											},
											onWheel: function onWheel(e) {
												_this2.onWheel(e, "s", 5);
											}
										})
									]
								}),
								/*#__PURE__*/ jsxs("label", {
									children: [
										"L ",
										/*#__PURE__*/ jsx("input", {
											value: l.toFixed(0),
											onChange: function onChange(e) {
												_this2.onNumberChange(e, "l");
											},
											onWheel: function onWheel(e) {
												_this2.onWheel(e, "l", 5);
											}
										})
									]
								}),
								/*#__PURE__*/ jsxs("label", {
									children: [
										"A ",
										/*#__PURE__*/ jsx("input", {
											value: a,
											onChange: function onChange(e) {
												_this2.onNumberChange(e, "a");
											},
											onWheel: function onWheel(e) {
												_this2.onWheel(e, "a", 0.1);
											}
										})
									]
								})
							]
						}),
						/*#__PURE__*/ jsxs("div", {
							className: CSS.element(baseClass, "alpha"),
							onMouseDown: this.onAlphaSelect.bind(this),
							onTouchStart: this.onAlphaSelect.bind(this),
							onWheel: function onWheel(e) {
								_this2.onWheel(e, "a", 0.1);
							},
							children: [
								/*#__PURE__*/ jsx("div", {
									style: {
										background: alphaGradient
									}
								}),
								/*#__PURE__*/ jsx("div", {
									className: CSS.element(baseClass, "indicator"),
									style: {
										left: "calc(" + a * 100 + "% - 2px)"
									}
								})
							]
						}),
						/*#__PURE__*/ jsxs("div", {
							className: CSS.element(baseClass, "inputs"),
							children: [
								/*#__PURE__*/ jsxs("label", {
									children: [
										"R ",
										/*#__PURE__*/ jsx("input", {
											value: r.toFixed(0),
											onChange: function onChange(e) {
												_this2.onNumberChange(e, "r");
											},
											onWheel: function onWheel(e) {
												_this2.onWheel(e, "r", 5);
											}
										})
									]
								}),
								/*#__PURE__*/ jsxs("label", {
									children: [
										"G ",
										/*#__PURE__*/ jsx("input", {
											value: g.toFixed(0),
											onChange: function onChange(e) {
												_this2.onNumberChange(e, "g");
											},
											onWheel: function onWheel(e) {
												_this2.onWheel(e, "g", 5);
											}
										})
									]
								}),
								/*#__PURE__*/ jsxs("label", {
									children: [
										"B ",
										/*#__PURE__*/ jsx("input", {
											value: b.toFixed(0),
											onChange: function onChange(e) {
												_this2.onNumberChange(e, "b");
											},
											onWheel: function onWheel(e) {
												_this2.onWheel(e, "b", 5);
											}
										})
									]
								}),
								/*#__PURE__*/ jsxs("label", {
									children: [
										"A ",
										/*#__PURE__*/ jsx("input", {
											value: a,
											onChange: function onChange(e) {
												_this2.onNumberChange(e, "a");
											},
											onWheel: function onWheel(e) {
												_this2.onWheel(e, "a", 0.1);
											}
										})
									]
								})
							]
						}),
						/*#__PURE__*/ jsxs("div", {
							className: CSS.element(baseClass, "preview"),
							children: [
								/*#__PURE__*/ jsxs("div", {
									className: CSS.element(baseClass, "values"),
									children: [
										/*#__PURE__*/ jsx("input", {
											value: hsla,
											readOnly: true
										}),
										/*#__PURE__*/ jsx("input", {
											value: rgba,
											readOnly: true
										}),
										/*#__PURE__*/ jsx("input", {
											value: hex,
											readOnly: true
										})
									]
								}),
								/*#__PURE__*/ jsx("div", {
									className: CSS.element(baseClass, "color"),
									onClick: function onClick(e) {
										_this2.onColorClick(e);
									},
									children: /*#__PURE__*/ jsx("div", {
										style: {
											backgroundColor: hsla
										}
									})
								})
							]
						})
					]
				})
			]
		});
	};

	_proto2.onColorClick = function onColorClick(e) {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onColorClick) instance.invoke("onColorClick", e, instance);
	};

	_proto2.onHueSelect = function onHueSelect(e) {
		var _this3 = this;

		e.preventDefault();
		e.stopPropagation();
		var el = e.currentTarget;
		var bounds = el.getBoundingClientRect();

		var move = function move(e) {
			var pos = getCursorPos(e);
			var x = Math.max(0, Math.min(1, (pos.clientX + 1 - bounds.left) / el.offsetWidth));

			_this3.setColorProp({
				h: x * 360
			});
		};

		captureMouseOrTouch(e, move);
		move(e);
	};

	_proto2.onAlphaSelect = function onAlphaSelect(e) {
		var _this4 = this;

		e.preventDefault();
		e.stopPropagation();
		var el = e.currentTarget;
		var bounds = getTopLevelBoundingClientRect(el);

		var move = function move(e) {
			var pos = getCursorPos(e);
			var x = Math.max(0, Math.min(1, (pos.clientX + 1 - bounds.left) / el.offsetWidth));

			_this4.setColorProp({
				a: x
			});
		};

		captureMouseOrTouch(e, move);
		move(e);
	};

	_proto2.onSLSelect = function onSLSelect(e) {
		var _this5 = this;

		e.preventDefault();
		e.stopPropagation();
		var el = e.currentTarget;
		var bounds = getTopLevelBoundingClientRect(el);

		var move = function move(e) {
			var pos = getCursorPos(e);
			var x = Math.max(0, Math.min(1, (pos.clientX + 1 - bounds.left) / el.offsetWidth));
			var y = Math.max(0, Math.min(1, (pos.clientY + 1 - bounds.top) / el.offsetWidth));
			var s = x;
			var l = 1 - y;

			_this5.setColorProp({
				s: s * 100,
				l: l * 100
			});
		};

		captureMouseOrTouch(e, move);
		move(e);
	};

	_proto2.fix255 = function fix255(v) {
		return Math.max(0, Math.min(255, Math.round(v)));
	};

	_proto2.setColorProp = function setColorProp(props, value) {
		var _this6 = this;

		if (isString(props)) {
			var _props;

			props = ((_props = {}), (_props[props] = value), _props);
		}

		var state = _objectSpread2({}, this.state);

		var fixAlpha = false;

		for (var prop in props) {
			value = props[prop];

			switch (prop) {
				case "h":
					state.h = Math.min(360, Math.max(0, value));

					var _hslToRgb2 = hslToRgb(state.h, state.s, state.l);

					state.r = _hslToRgb2[0];
					state.g = _hslToRgb2[1];
					state.b = _hslToRgb2[2];
					fixAlpha = true;
					break;

				case "s":
					state.s = Math.min(100, Math.max(0, value));

					var _hslToRgb3 = hslToRgb(state.h, state.s, state.l);

					state.r = _hslToRgb3[0];
					state.g = _hslToRgb3[1];
					state.b = _hslToRgb3[2];
					fixAlpha = true;
					break;

				case "l":
					state.l = Math.min(100, Math.max(0, value));

					var _hslToRgb4 = hslToRgb(state.h, state.s, state.l);

					state.r = _hslToRgb4[0];
					state.g = _hslToRgb4[1];
					state.b = _hslToRgb4[2];
					fixAlpha = true;
					break;

				case "r":
				case "g":
				case "b":
					state[prop] = Math.round(Math.min(255, Math.max(0, value)));

					var _rgbToHsl2 = rgbToHsl(state.r, state.g, state.b),
						h = _rgbToHsl2[0],
						s = _rgbToHsl2[1],
						l = _rgbToHsl2[2];

					state.h = h;
					state.s = s;
					state.l = l;
					fixAlpha = true;
					break;

				case "a":
					state.a = Math.round(100 * Math.min(1, Math.max(0, value))) / 100;
					break;
			}
		}

		state.r = this.fix255(state.r);
		state.g = this.fix255(state.g);
		state.b = this.fix255(state.b);
		if (fixAlpha && state.a === 0) state.a = 1;
		this.setState(state, function() {
			_this6.props.instance.widget.handleEvent("change", _this6.props.instance, _this6.state);
		});
	};

	_proto2.onNumberChange = function onNumberChange(e, prop) {
		e.preventDefault();
		e.stopPropagation();
		var number = parseFloat(e.target.value || "0");
		this.setColorProp(prop, number);
	};

	_proto2.onWheel = function onWheel(e, prop, delta) {
		e.preventDefault();
		e.stopPropagation();
		var factor = e.deltaY < 0 ? 1 : -1;
		this.setColorProp(prop, this.state[prop] + delta * factor);
	};

	_proto2.onBlur = function onBlur() {
		this.props.instance.widget.handleEvent("blur", this.props.instance, this.state);
	};

	return ColorPickerComponent;
})(VDOM.Component);

var MonthField = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(MonthField, _Field);

	function MonthField() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = MonthField.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		if (this.mode == "range") {
			this.range = true;
			this.mode = "edit";
			Console.warn('Please use the range flag on MonthFields. Syntax mode="range" is deprecated.', this);
		}

		var values = {};

		if (this.range) {
			values = {
				from: null,
				to: null
			};
		} else {
			values = {
				value: this.emptyValue
			};
		}

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				values,
				{
					disabled: undefined,
					readOnly: undefined,
					enabled: undefined,
					placeholder: undefined,
					required: undefined,
					minValue: undefined,
					minExclusive: undefined,
					maxValue: undefined,
					maxExclusive: undefined,
					icon: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.isEmpty = function isEmpty(data) {
		return this.range ? data.from == null : data.value == null;
	};

	_proto.init = function init() {
		if (!this.culture) this.culture = new DateTimeCulture(Format$1.culture);
		if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
		if (this.alwaysShowClear) this.showClear = true;

		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		_Field.prototype.prepareData.call(this, context, instance);

		var data = instance.data;
		var formatOptions = {
			year: "numeric",
			month: "short"
		};

		if (!this.range && data.value) {
			data.date = new Date(data.value);
			data.formatted = this.culture.format(data.date, formatOptions);
		} else if (this.range && data.from && data.to) {
			data.from = new Date(data.from);
			data.to = new Date(data.to);
			data.to.setDate(data.to.getDate() - 1);
			var fromStr = this.culture.format(data.from, formatOptions);
			var toStr = this.culture.format(data.to, formatOptions);
			if (fromStr != toStr) data.formatted = fromStr + " - " + toStr;
			else data.formatted = fromStr;
		}

		if (data.refDate) data.refDate = monthStart(new Date(data.refDate));
		if (data.maxValue) data.maxValue = monthStart(new Date(data.maxValue));
		if (data.minValue) data.minValue = monthStart(new Date(data.minValue));
		instance.lastDropdown = context.lastDropdown;
	};

	_proto.validateRequired = function validateRequired(context, instance) {
		var data = instance.data;

		if (this.range) {
			if (!data.from || !data.to) return this.requiredText;
		} else return _Field.prototype.validateRequired.call(this, context, instance);
	};

	_proto.validate = function validate(context, instance) {
		_Field.prototype.validate.call(this, context, instance);

		var data = instance.data;

		if (!data.error && data.date) {
			var d;

			if (data.maxValue) {
				d = dateDiff(data.date, data.maxValue);
				if (d > 0) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
				else if (d == 0 && data.maxExclusive)
					data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
			}

			if (data.minValue) {
				d = dateDiff(data.date, data.minValue);
				if (d < 0) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
				else if (d == 0 && data.minExclusive)
					data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
			}
		}
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			MonthInput,
			{
				data: instance.data,
				instance: instance,
				monthPicker: {
					value: this.value,
					from: this.from,
					to: this.to,
					range: this.range,
					minValue: this.minValue,
					maxValue: this.maxValue,
					minExclusive: this.minExclusive,
					maxExclusive: this.maxExclusive,
					maxValueErrorText: this.maxValueErrorText,
					maxExclusiveErrorText: this.maxExclusiveErrorText,
					minValueErrorText: this.minValueErrorText,
					minExclusiveErrorText: this.minExclusiveErrorText
				},
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			},
			key
		);
	};

	_proto.formatValue = function formatValue(context, _ref) {
		var data = _ref.data;
		return data.formatted || "";
	};

	_proto.parseDate = function parseDate(date) {
		if (!date) return null;
		if (date instanceof Date) return date;
		date = this.culture.parse(date, {
			useCurrentDateForDefaults: true
		});
		return date;
	};

	_proto.handleSelect = function handleSelect(instance, date1, date2) {
		instance.setState({
			inputError: false
		});

		if (this.range) {
			var d1 = date1 ? date1.toISOString() : this.emptyValue;
			var d2 = date2 ? date2.toISOString() : this.emptyValue;
			instance.set("from", d1);
			instance.set("to", d2);
		} else {
			var value = date1 ? date1.toISOString() : this.emptyValue;
			instance.set("value", value);
		}
	};

	return MonthField;
})(Field);
MonthField.prototype.baseClass = "monthfield";
MonthField.prototype.maxValueErrorText = "Select {0:d} or before.";
MonthField.prototype.maxExclusiveErrorText = "Select a date before {0:d}.";
MonthField.prototype.minValueErrorText = "Select {0:d} or later.";
MonthField.prototype.minExclusiveErrorText = "Select a date after {0:d}.";
MonthField.prototype.inputErrorText = "Invalid date entered";
MonthField.prototype.suppressErrorsUntilVisited = true;
MonthField.prototype.icon = "calendar";
MonthField.prototype.showClear = true;
MonthField.prototype.alwaysShowClear = false;
MonthField.prototype.range = false;
MonthField.prototype.reactOn = "enter blur";
Localization.registerPrototype("cx/widgets/MonthField", MonthField);
Widget.alias("monthfield", MonthField);

var MonthInput = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(MonthInput, _VDOM$Component);

	function MonthInput(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.props.instance.component = _assertThisInitialized(_this);
		_this.state = {
			dropdownOpen: false,
			focus: false
		};
		return _this;
	}

	var _proto2 = MonthInput.prototype;

	_proto2.getDropdown = function getDropdown() {
		var _this2 = this;

		if (this.dropdown) return this.dropdown;
		var _this$props$instance = this.props.instance,
			widget = _this$props$instance.widget,
			lastDropdown = _this$props$instance.lastDropdown;

		var dropdown = _objectSpread2(
			_objectSpread2(
				{
					scrollTracking: true,
					inline: !isTouchDevice() || !!lastDropdown,
					placementOrder:
						"down down-left down-right up up-left up-right right right-up right-down left left-up left-down",
					touchFriendly: true
				},
				widget.dropdownOptions
			),
			{},
			{
				type: Dropdown,
				relatedElement: this.input,
				items: _objectSpread2(
					_objectSpread2(
						{
							type: MonthPicker
						},
						this.props.monthPicker
					),
					{},
					{
						autoFocus: true,
						onFocusOut: function onFocusOut(e) {
							_this2.closeDropdown(e);
						},
						onKeyDown: function onKeyDown(e) {
							return _this2.onKeyDown(e);
						},
						onSelect: function onSelect(e) {
							var touch = isTouchEvent(e);

							_this2.closeDropdown(e, function() {
								if (!touch) _this2.input.focus();
							});
						}
					}
				),
				constrain: true,
				firstChildDefinesWidth: true
			}
		);

		return (this.dropdown = Widget.create(dropdown));
	};

	_proto2.render = function render() {
		var _this3 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			label = _this$props.label,
			help = _this$props.help,
			data = _this$props.data;
		var widget = instance.widget,
			state = instance.state;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
		var insideButton, icon;

		if (!data.readOnly && !data.disabled) {
			if (
				widget.showClear &&
				(((widget.alwaysShowClear || !data.required) && !data.empty) || instance.state.inputError)
			)
				insideButton = /*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "clear"),
					onMouseDown: function onMouseDown(e) {
						e.preventDefault();
						e.stopPropagation();
					},
					onClick: function onClick(e) {
						_this3.onClearClick(e);
					},
					children: /*#__PURE__*/ jsx(ClearIcon, {
						className: CSS.element(baseClass, "icon")
					})
				});
			else
				insideButton = /*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "right-icon"),
					children: /*#__PURE__*/ jsx(DropdownIcon, {
						className: CSS.element(baseClass, "icon")
					})
				});
		}

		if (data.icon) {
			icon = /*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "left-icon"),
				children: Icon.render(data.icon, {
					className: CSS.element(baseClass, "icon")
				})
			});
		}

		var dropdown = false;
		if (this.state.dropdownOpen)
			dropdown = /*#__PURE__*/ jsx(Cx, {
				widget: this.getDropdown(),
				parentInstance: instance,
				options: {
					name: "monthfield-dropdown"
				},
				subscribe: true
			});
		var empty = this.input ? !this.input.value : data.empty;
		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(
				data.classNames,
				CSS.state({
					visited: state.visited,
					focus: this.state.focus || this.state.dropdownOpen,
					icon: !!icon,
					empty: empty && !data.placeholder,
					error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
				})
			),
			style: data.style,
			onMouseDown: this.onMouseDown.bind(this),
			onTouchStart: stopPropagation,
			onClick: stopPropagation,
			children: [
				/*#__PURE__*/ jsx("input", {
					id: data.id,
					ref: function ref(el) {
						_this3.input = el;
					},
					type: "text",
					className: CSS.expand(CSS.element(baseClass, "input"), data.inputClass),
					style: data.inputStyle,
					defaultValue: data.formatted,
					disabled: data.disabled,
					readOnly: data.readOnly,
					tabIndex: data.tabIndex,
					placeholder: data.placeholder,
					onInput: function onInput(e) {
						return _this3.onChange(e, "input");
					},
					onChange: function onChange(e) {
						return _this3.onChange(e, "change");
					},
					onKeyDown: function onKeyDown(e) {
						return _this3.onKeyDown(e);
					},
					onBlur: function onBlur(e) {
						_this3.onBlur(e);
					},
					onFocus: function onFocus(e) {
						_this3.onFocus(e);
					},
					onMouseMove: function onMouseMove(e) {
						return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
					},
					onMouseLeave: function onMouseLeave(e) {
						return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
					}
				}),
				icon,
				insideButton,
				dropdown,
				label,
				help
			]
		});
	};

	_proto2.onMouseDown = function onMouseDown(e) {
		e.stopPropagation();
		if (this.state.dropdownOpen) this.closeDropdown(e);
		else {
			this.openDropdownOnFocus = true;
		} //icon click

		if (e.target != this.input) {
			e.preventDefault();
			if (!this.state.dropdownOpen) this.openDropdown(e);
			else this.input.focus();
		}
	};

	_proto2.onFocus = function onFocus(e) {
		var instance = this.props.instance;
		var widget = instance.widget;

		if (widget.trackFocus) {
			this.setState({
				focus: true
			});
		}

		if (this.openDropdownOnFocus) this.openDropdown(e);
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var _this4 = this;

		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.enter:
				e.stopPropagation();
				this.onChange(e, "enter");
				break;

			case KeyCode.esc:
				if (this.state.dropdownOpen) {
					e.stopPropagation();
					this.closeDropdown(e, function() {
						_this4.input.focus();
					});
				}

				break;

			case KeyCode.left:
			case KeyCode.right:
				e.stopPropagation();
				break;

			case KeyCode.down:
				this.openDropdown(e);
				e.stopPropagation();
				e.preventDefault();
				break;
		}
	};

	_proto2.onBlur = function onBlur(e) {
		if (!this.state.dropdownOpen)
			this.props.instance.setState({
				visited: true
			});
		if (this.state.focus)
			this.setState({
				focus: false
			});
		this.onChange(e, "blur");
	};

	_proto2.closeDropdown = function closeDropdown(e, callback) {
		var _this5 = this;

		if (this.state.dropdownOpen) {
			if (this.scrollableParents)
				this.scrollableParents.forEach(function(el) {
					el.removeEventListener("scroll", _this5.updateDropdownPosition);
				});
			this.props.instance.setState({
				visited: true
			});
			this.setState(
				{
					dropdownOpen: false
				},
				callback
			);
		} else if (callback) callback();
	};

	_proto2.openDropdown = function openDropdown(e) {
		var data = this.props.instance.data;
		this.openDropdownOnFocus = false;

		if (!this.state.dropdownOpen && !(data.disabled || data.readOnly)) {
			this.setState({
				dropdownOpen: true
			});
		}
	};

	_proto2.onClearClick = function onClearClick(e) {
		e.stopPropagation();
		e.preventDefault();
		var instance = this.props.instance;
		var widget = instance.widget;
		widget.handleSelect(instance, null, null);
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var _props$instance = props.instance,
			data = _props$instance.data,
			state = _props$instance.state;

		if (data.formatted != this.input.value && (data.formatted != this.props.data.formatted || !state.inputError)) {
			this.input.value = data.formatted || "";
			props.instance.setState({
				inputError: false
			});
		}

		tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
	};

	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
		autoFocus(this.input, this);
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		autoFocus(this.input, this);
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.onChange = function onChange(e, eventType) {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.reactOn.indexOf(eventType) == -1) return;
		var parts = e.target.value.split("-");
		var date1 = widget.parseDate(parts[0]);
		var date2 = widget.parseDate(parts[1]) || date1;

		if ((date1 != null && isNaN(date1)) || (date2 != null && isNaN(date2))) {
			instance.setState({
				inputError: widget.inputErrorText
			});
		} else if (eventType == "blur" || eventType == "enter") {
			if (date2) date2 = new Date(date2.getFullYear(), date2.getMonth() + 1, 1);
			instance.setState({
				visited: true
			});
			widget.handleSelect(instance, date1, date2);
		}
	};

	return MonthInput;
})(VDOM.Component);

var ColorField = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(ColorField, _Field);

	function ColorField() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = ColorField.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: this.emptyValue,
					disabled: undefined,
					readOnly: undefined,
					enabled: undefined,
					placeholder: undefined,
					required: undefined,
					format: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (isDefined(this.hideClear)) this.showClear = !this.hideClear;
		if (this.alwaysShowClear) this.showClear = true;

		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = [
			data.stateMods,
			{
				empty: !data.value
			}
		];
		instance.lastDropdown = context.lastDropdown;

		_Field.prototype.prepareData.call(this, context, instance);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			ColorInput,
			{
				instance: instance,
				data: instance.data,
				picker: {
					value: this.value,
					format: this.format
				},
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			},
			key
		);
	};

	return ColorField;
})(Field);
ColorField.prototype.baseClass = "colorfield";
ColorField.prototype.format = "rgba";
ColorField.prototype.suppressErrorsUntilVisited = true;
ColorField.prototype.showClear = true;
ColorField.prototype.alwaysShowClear = false;
Widget.alias("color-field", ColorField);
Localization.registerPrototype("cx/widgets/ColorField", ColorField);

var ColorInput = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(ColorInput, _VDOM$Component);

	function ColorInput(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		var data = _this.props.data;
		_this.data = data;
		_this.state = {
			dropdownOpen: false,
			focus: false
		};
		return _this;
	}

	var _proto2 = ColorInput.prototype;

	_proto2.getDropdown = function getDropdown() {
		var _this2 = this;

		if (this.dropdown) return this.dropdown;
		var _this$props$instance = this.props.instance,
			widget = _this$props$instance.widget,
			lastDropdown = _this$props$instance.lastDropdown;

		var dropdown = _objectSpread2(
			_objectSpread2(
				{
					scrollTracking: true,
					autoFocus: true,
					//put focus on the dropdown to prevent opening the keyboard
					focusable: true,
					inline: !isTouchDevice() || !!lastDropdown,
					touchFriendly: true,
					placementOrder:
						" down down-left down-right up up-left up-right right right-up right-down left left-up left-down"
				},
				widget.dropdownOptions
			),
			{},
			{
				type: Dropdown,
				relatedElement: this.input,
				items: _objectSpread2(
					_objectSpread2(
						{
							type: ColorPicker
						},
						this.props.picker
					),
					{},
					{
						onColorClick: function onColorClick(e) {
							e.stopPropagation();
							e.preventDefault();
							var touch = isTouchEvent(e);

							_this2.closeDropdown(e, function() {
								if (!touch) _this2.input.focus();
							});
						}
					}
				),
				onFocusOut: function onFocusOut() {
					_this2.closeDropdown();
				},
				firstChildDefinesHeight: true,
				firstChildDefinesWidth: true
			}
		);

		return (this.dropdown = Widget.create(dropdown));
	};

	_proto2.render = function render() {
		var _this3 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			label = _this$props.label,
			help = _this$props.help,
			data = _this$props.data;
		var widget = instance.widget,
			state = instance.state;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
		var insideButton;

		if (!data.readOnly && !data.disabled) {
			if (
				widget.showClear &&
				(((!data.required || widget.alwaysShowClear) && !data.empty) || instance.state.inputError)
			)
				insideButton = /*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "clear"),
					onMouseDown: function onMouseDown(e) {
						e.preventDefault();
						e.stopPropagation();
					},
					onClick: function onClick(e) {
						_this3.onClearClick(e);
					},
					children: /*#__PURE__*/ jsx(ClearIcon, {
						className: CSS.element(baseClass, "icon")
					})
				});
			else
				insideButton = /*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "right-icon"),
					children: /*#__PURE__*/ jsx(DropdownIcon, {
						className: CSS.element(baseClass, "icon")
					})
				});
		}

		var well = /*#__PURE__*/ jsx("div", {
			className: CSS.element(baseClass, "left-icon"),
			children: /*#__PURE__*/ jsx("div", {
				style: {
					backgroundColor: data.value
				}
			})
		});

		var dropdown = false;
		if (this.state.dropdownOpen)
			dropdown = /*#__PURE__*/ jsx(Cx, {
				widget: this.getDropdown(),
				parentInstance: instance,
				options: {
					name: "colorfield-dropdown"
				},
				subscribe: true
			});
		var empty = this.input ? !this.input.value : data.empty;
		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(
				data.classNames,
				CSS.state({
					visited: state.visited,
					focus: this.state.focus || this.state.dropdownOpen,
					icon: true,
					empty: empty && !data.placeholder,
					error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
				})
			),
			style: data.style,
			onMouseDown: this.onMouseDown.bind(this),
			onTouchStart: stopPropagation,
			onClick: stopPropagation,
			children: [
				/*#__PURE__*/ jsx(
					"input",
					_objectSpread2(
						_objectSpread2(
							{
								id: data.id,
								ref: function ref(el) {
									_this3.input = el;
								},
								type: "text",
								className: CSS.expand(CSS.element(baseClass, "input"), data.inputClass),
								style: data.inputStyle,
								defaultValue: this.trim(data.value || ""),
								disabled: data.disabled,
								readOnly: data.readOnly,
								tabIndex: data.tabIndex,
								placeholder: data.placeholder
							},
							data.inputAttrs
						),
						{},
						{
							onInput: function onInput(e) {
								return _this3.onChange(e, "input");
							},
							onChange: function onChange(e) {
								return _this3.onChange(e, "change");
							},
							onKeyDown: function onKeyDown(e) {
								return _this3.onKeyDown(e);
							},
							onBlur: function onBlur(e) {
								_this3.onBlur(e);
							},
							onFocus: function onFocus(e) {
								_this3.onFocus(e);
							},
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
							}
						}
					)
				),
				well,
				insideButton,
				dropdown,
				label,
				help
			]
		});
	};

	_proto2.onMouseDown = function onMouseDown(e) {
		e.stopPropagation();
		if (this.state.dropdownOpen) this.closeDropdown(e);
		else {
			this.openDropdownOnFocus = true;
		} //icon click

		if (e.target != this.input) {
			e.preventDefault();
			if (!this.state.dropdownOpen) this.openDropdown(e);
			else this.input.focus();
		}
	};

	_proto2.onFocus = function onFocus(e) {
		if (this.openDropdownOnFocus) this.openDropdown(e);
		var instance = this.props.instance;
		var widget = instance.widget;

		if (widget.trackFocus) {
			this.setState({
				focus: true
			});
		}
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var _this4 = this;

		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.enter:
				e.stopPropagation();
				this.onChange(e, "enter");
				break;

			case KeyCode.esc:
				if (this.state.dropdownOpen) {
					e.stopPropagation();
					this.closeDropdown(e, function() {
						_this4.input.focus();
					});
				}

				break;

			case KeyCode.left:
			case KeyCode.right:
				e.stopPropagation();
				break;

			case KeyCode.down:
				this.openDropdown(e);
				e.stopPropagation();
				e.preventDefault();
				break;
		}
	};

	_proto2.onBlur = function onBlur(e) {
		if (this.state.focus)
			this.setState({
				focus: false
			});
		this.onChange(e, "blur");
	};

	_proto2.closeDropdown = function closeDropdown(e, callback) {
		var _this5 = this;

		if (this.state.dropdownOpen) {
			if (this.scrollableParents)
				this.scrollableParents.forEach(function(el) {
					el.removeEventListener("scroll", _this5.updateDropdownPosition);
				});
			this.setState(
				{
					dropdownOpen: false
				},
				callback
			);
		} else if (callback) callback();
	};

	_proto2.openDropdown = function openDropdown(e) {
		var data = this.props.data;
		this.openDropdownOnFocus = false;

		if (!this.state.dropdownOpen && !(data.disabled || data.readOnly)) {
			this.setState({
				dropdownOpen: true
			});
		}
	};

	_proto2.trim = function trim(value) {
		return value.replace(/\s/g, "");
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var data = props.data,
			instance = props.instance;
		var state = instance.state;
		var nv = this.trim(data.value || "");

		if (nv != this.input.value && (this.data.value != data.value || !state.inputError)) {
			this.input.value = nv;
			instance.setState({
				inputError: false
			});
		}

		this.data = data;
		tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(instance)));
	};

	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
		if (this.props.instance.widget.autoFocus && !isTouchDevice()) this.input.focus();
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.onClearClick = function onClearClick(e) {
		var instance = this.props.instance;
		instance.set("value", instance.widget.emptyValue);
		instance.setState({
			inputError: false
		});
		e.stopPropagation();
		e.preventDefault();
	};

	_proto2.onChange = function onChange(e, eventType) {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data;
		var widget = instance.widget;
		if (eventType == "blur")
			instance.setState({
				visited: true
			});
		var text = e.target.value;
		var isValid;

		try {
			parseColor(text);
			isValid = true;
		} catch (e) {
			isValid = false;
		}

		if (eventType == "blur" || eventType == "enter") {
			var value = text || widget.emptyValue;
			if (isValid && value !== data.value) instance.set("value", value);
			instance.setState({
				inputError: !isValid && "Invalid color entered."
			});
		}
	};

	return ColorInput;
})(VDOM.Component);

var UploadButton = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(UploadButton, _Field);

	function UploadButton() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = UploadButton.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					disabled: undefined,
					enabled: undefined,
					text: undefined,
					url: undefined,
					icon: undefined,
					accept: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			UploadButtonComponent,
			{
				instance: instance,
				children: data.text || this.renderChildren(context, instance)
			},
			key
		);
	};

	return UploadButton;
})(Field);
UploadButton.prototype.baseClass = "uploadbutton";
UploadButton.prototype.multiple = false;
UploadButton.prototype.method = "POST";
UploadButton.prototype.abortOnDestroy = false;
UploadButton.prototype.uploadInProgressText = "Upload is in progress.";
Localization.registerPrototype("cx/widgets/UploadButton", UploadButton);

var UploadButtonComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(UploadButtonComponent, _VDOM$Component);

	function UploadButtonComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.uploads = {};
		_this.state = {
			progress: 100,
			uploadKey: 0
		};
		return _this;
	}

	var _proto2 = UploadButtonComponent.prototype;

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			children = _this$props.children;
		var widget = instance.widget,
			data = instance.data;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var icon;
		var className = data.classNames;

		if (data.icon) {
			icon = Icon.render(data.icon, {
				className: CSS.element(baseClass, "icon")
			});
			className = CSS.expand(className, CSS.state("icon"), children.length == 0 && CSS.state("empty"));
		}

		return /*#__PURE__*/ jsxs("div", {
			ref: function ref(el) {
				_this2.el = el;
			},
			className: className,
			style: data.style,
			children: [
				/*#__PURE__*/ jsx(
					"div",
					{
						className: CSS.element(baseClass, "progress", {
							done: this.state.progress == 100
						}),
						style: {
							width: this.state.progress + "%"
						}
					},
					"progress"
				),
				icon,
				children,
				!data.disabled &&
					/*#__PURE__*/ jsx(
						"input",
						{
							className: CSS.element(baseClass, "input"),
							type: "file",
							title: " ",
							accept: data.accept,
							multiple: widget.multiple,
							tabIndex: data.tabIndex,
							onChange: this.onFileSelected.bind(this)
						},
						this.state.uploadKey
					)
			]
		});
	};

	_proto2.onFileSelected = function onFileSelected(e) {
		var files = e.dataTransfer ? e.dataTransfer.files : e.target ? e.target.files : [];

		for (var i = 0; i < files.length; i++) {
			this.uploadFile(files[i]);
		}
	};

	_proto2.componentDidMount = function componentDidMount() {
		if (this.props.instance.data.autoFocus) this.el.focus();
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		if (this.props.instance.widget.abortOnDestroy) {
			for (var key in this.uploads) {
				var upload = this.uploads[key];
				upload.xhr.abort();
			}
		}
	};

	_proto2.uploadFile = function uploadFile(file) {
		var _this3 = this;

		var instance = this.props.instance;
		var data = instance.data,
			widget = instance.widget;

		if (widget.onResolveUrl) {
			Promise.resolve(instance.invoke("onResolveUrl", file, instance)).then(function(url) {
				_this3.doUpload(file, url);
			});
		} else {
			this.doUpload(file, data.url);
		}
	};

	_proto2.doUpload = function doUpload(file, url) {
		var _this4 = this;

		var instance = this.props.instance;
		var widget = instance.widget;
		if (!url) throw new Error("Upload URL not set.");
		var xhr = new XMLHttpRequest();
		xhr.open(widget.method, Url.resolve(url));
		var formData = new FormData();
		formData.append("file", file);
		var key = this.state.uploadKey;
		this.setState({
			uploadKey: key + 1
		});
		var startingPromise = widget.onUploadStarting
			? instance.invoke("onUploadStarting", xhr, instance, file, formData)
			: true;
		Promise.resolve(startingPromise)
			.then(function(result) {
				if (result === false) return;
				var upload = (_this4.uploads[key] = {
					progress: 0,
					size: file.size || 1,
					file: file,
					xhr: xhr
				});

				xhr.onload = function() {
					delete _this4.uploads[key];
					if (widget.onUploadComplete) instance.invoke("onUploadComplete", xhr, instance, file, formData);

					_this4.reportProgress();
				};

				xhr.onerror = function(e) {
					delete _this4.uploads[key];
					if (widget.onUploadError) instance.invoke("onUploadError", e, instance, file, formData);

					_this4.reportProgress();
				};

				xhr.upload.onprogress = function(event) {
					if (event.lengthComputable) {
						upload.progress = event.loaded / event.total;

						_this4.reportProgress();

						if (widget.onUploadProgress) instance.invoke("onUploadProgress", event, instance, file, formData);
					}
				};

				xhr.send(formData);
			})
			["catch"](function(err) {
				if (widget.onUploadError) instance.invoke("onUploadError", err, instance, file, formData);
				else console.error("Unhandled upload error.", err);
			});
		this.reportProgress();
	};

	_proto2.reportProgress = function reportProgress() {
		var totalSize = 0;
		var uploaded = 0;

		for (var key in this.uploads) {
			var upload = this.uploads[key];
			totalSize += upload.size;
			uploaded += upload.size * upload.progress;
		}

		var progress = 100 * (totalSize ? uploaded / totalSize : 1);
		this.props.instance.setState({
			inputError: progress == 100 ? false : this.props.instance.uploadInProgressText
		});
		this.setState({
			progress: Math.max(0.001, Math.floor(progress))
		});
	};

	return UploadButtonComponent;
})(VDOM.Component);

Widget.alias("upload-button", UploadButton);

var Slider = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(Slider, _Field);

	function Slider() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = Slider.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					from: 0,
					to: 0,
					step: undefined,
					minValue: undefined,
					maxValue: undefined,
					increment: undefined,
					incrementPercentage: undefined,
					wheel: undefined,
					disabled: undefined,
					enabled: undefined,
					readOnly: undefined,
					rangeStyle: {
						structured: true
					},
					handleStyle: {
						structured: true
					}
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (isDefined(this.min)) this.minValue = this.min;
		if (isDefined(this.max)) this.maxValue = this.max;
		if (this.value != null) this.to = this.value;
		if (isUndefined(this.from)) this.from = this.minValue;
		else this.showFrom = true;
		if (isUndefined(this.to)) this.to = this.maxValue;
		else this.showTo = true;
		if (this.valueTooltip) this.toTooltip = this.valueTooltip;

		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				horizontal: !this.vertical,
				vertical: this.vertical,
				disabled: data.disabled
			}
		);

		_Field.prototype.prepareData.call(this, context, instance);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			SliderComponent,
			{
				instance: instance,
				data: instance.data,
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label"))
			},
			key
		);
	};

	return Slider;
})(Field);
Slider.prototype.baseClass = "slider";
Slider.prototype.minValue = 0;
Slider.prototype.maxValue = 100;
Slider.prototype.vertical = false;
Slider.prototype.incrementPercentage = 0.01;
Slider.prototype.wheel = false;
Widget.alias("slider", Slider);

var SliderComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(SliderComponent, _VDOM$Component);

	function SliderComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.dom = {};
		var data = props.data;
		_this.state = {
			from: data.from,
			to: data.to
		};
		return _this;
	}

	var _proto2 = SliderComponent.prototype;

	_proto2.render = function render() {
		var _objectSpread2$1,
			_objectSpread3,
			_objectSpread4,
			_this2 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			data = _this$props.data,
			label = _this$props.label;
		var widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var minValue = data.minValue,
			maxValue = data.maxValue;
		var _this$state = this.state,
			from = _this$state.from,
			to = _this$state.to;
		from = Math.min(maxValue, Math.max(minValue, from));
		to = Math.min(maxValue, Math.max(minValue, to));
		var handleStyle = CSS.parseStyle(data.handleStyle);

		var fromHandleStyle = _objectSpread2(
			_objectSpread2({}, handleStyle),
			{},
			((_objectSpread2$1 = {}),
			(_objectSpread2$1[widget.vertical ? "top" : "left"] = (100 * (from - minValue)) / (maxValue - minValue) + "%"),
			_objectSpread2$1)
		);

		var toHandleStyle = _objectSpread2(
			_objectSpread2({}, handleStyle),
			{},
			((_objectSpread3 = {}),
			(_objectSpread3[widget.vertical ? "top" : "left"] = (100 * (to - minValue)) / (maxValue - minValue) + "%"),
			_objectSpread3)
		);

		var rangeStart = (from - minValue) / (maxValue - minValue);
		var rangeSize = (to - from) / (maxValue - minValue);

		var rangeStyle = _objectSpread2(
			_objectSpread2({}, CSS.parseStyle(data.rangeStyle)),
			{},
			((_objectSpread4 = {}),
			(_objectSpread4[widget.vertical ? "top" : "left"] = 100 * rangeStart + "%"),
			(_objectSpread4[widget.vertical ? "height" : "width"] = 100 * rangeSize + "%"),
			_objectSpread4)
		);

		return /*#__PURE__*/ jsxs("div", {
			className: data.classNames,
			style: data.style,
			id: data.id,
			onClick: function onClick(e) {
				return _this2.onClick(e);
			},
			onWheel: function onWheel(e) {
				return _this2.onWheel(e);
			},
			onMouseMove: function onMouseMove(e) {
				return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
			},
			onMouseLeave: function onMouseLeave(e) {
				return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
			},
			children: [
				label,
				"\xA0",
				/*#__PURE__*/ jsxs("div", {
					className: CSS.element(baseClass, "axis"),
					children: [
						rangeSize > 0 &&
							/*#__PURE__*/ jsx(
								"div",
								{
									className: CSS.element(baseClass, "range"),
									style: rangeStyle
								},
								"range"
							),
						/*#__PURE__*/ jsxs(
							"div",
							{
								className: CSS.element(baseClass, "space"),
								ref: function ref(c) {
									return (_this2.dom.range = c);
								},
								children: [
									widget.showFrom &&
										/*#__PURE__*/ jsx(
											"div",
											{
												className: CSS.element(baseClass, "handle"),
												tabIndex: data.disabled ? null : data.tabIndex || 0,
												style: fromHandleStyle,
												onMouseDown: function onMouseDown(e) {
													return _this2.onHandleMouseDown(e, "from");
												},
												onMouseMove: function onMouseMove(e) {
													return tooltipMouseMove(e, instance, widget.fromTooltip, {
														tooltipName: "fromTooltip"
													});
												},
												onMouseLeave: function onMouseLeave(e) {
													return _this2.onHandleMouseLeave(e, "from");
												},
												onTouchStart: function onTouchStart(e) {
													return _this2.onHandleMouseDown(e, "from");
												},
												ref: function ref(c) {
													return (_this2.dom.from = c);
												}
											},
											"from"
										),
									widget.showTo &&
										/*#__PURE__*/ jsx(
											"div",
											{
												className: CSS.element(baseClass, "handle"),
												tabIndex: data.disabled ? null : 0,
												style: toHandleStyle,
												onMouseDown: function onMouseDown(e) {
													return _this2.onHandleMouseDown(e, "to");
												},
												onMouseMove: function onMouseMove(e) {
													return tooltipMouseMove(e, instance, widget.toTooltip, {
														tooltipName: "toTooltip"
													});
												},
												onMouseLeave: function onMouseLeave(e) {
													return _this2.onHandleMouseLeave(e, "to");
												},
												onTouchStart: function onTouchStart(e) {
													return _this2.onHandleMouseDown(e, "to");
												},
												ref: function ref(c) {
													return (_this2.dom.to = c);
												}
											},
											"to"
										)
								]
							},
							"space"
						)
					]
				})
			]
		});
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		this.setState({
			from: props.data.from,
			to: props.data.to
		});
		var instance = props.instance;
		var widget = instance.widget;
		tooltipParentWillReceiveProps(this.dom.to, instance, widget.toTooltip, {
			tooltipName: "toTooltip"
		});
		tooltipParentWillReceiveProps(this.dom.from, instance, widget.fromTooltip, {
			tooltipName: "fromTooltip"
		});
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.componentDidMount = function componentDidMount() {
		var instance = this.props.instance;
		var widget = instance.widget;
		tooltipParentDidMount(this.dom.to, instance, widget.toTooltip, {
			tooltipName: "toTooltip"
		});
		tooltipParentDidMount(this.dom.from, instance, widget.fromTooltip, {
			tooltipName: "fromTooltip"
		});
	};

	_proto2.onHandleMouseLeave = function onHandleMouseLeave(e, handle) {
		if (!this.state.drag) {
			var tooltipName = handle + "Tooltip";
			var instance = this.props.instance;
			var tooltip = instance.widget[tooltipName];
			tooltipMouseLeave(e, instance, tooltip, {
				tooltipName: tooltipName
			});
		}
	};

	_proto2.onHandleMouseDown = function onHandleMouseDown(e, handle) {
		var _this3 = this;

		e.preventDefault();
		e.stopPropagation();
		var instance = this.props.instance;
		var data = instance.data,
			widget = instance.widget;
		if (data.disabled || data.readOnly) return;
		var handleEl = this.dom[handle];
		var b = getTopLevelBoundingClientRect(handleEl);
		var pos = getCursorPos(e);
		var dx = pos.clientX - (b.left + b.right) / 2;
		var dy = pos.clientY - (b.top + b.bottom) / 2;
		var tooltipName = handle + "Tooltip";
		var tooltip = widget[tooltipName];
		this.setState({
			drag: true
		});
		captureMouseOrTouch(
			e,
			function(e) {
				var _this3$getValues = _this3.getValues(e, widget.vertical ? dy : dx),
					value = _this3$getValues.value;

				if (handle === "from") {
					if (instance.set("from", value))
						_this3.setState({
							from: value
						});

					if (value > _this3.state.to) {
						if (instance.set("to", value))
							_this3.setState({
								to: value
							});
					}
				} else if (handle === "to") {
					if (instance.set("to", value))
						_this3.setState({
							to: value
						});

					if (value < _this3.state.from) {
						if (instance.set("from", value))
							_this3.setState({
								from: value
							});
					}
				}

				tooltipMouseMove(e, instance, tooltip, {
					tooltipName: tooltipName,
					target: handleEl
				});
			},
			function(e) {
				_this3.setState({
					drag: false
				});

				var pos = getCursorPos(e);
				var el = document.elementFromPoint(pos.clientX, pos.clientY);
				if (el !== handleEl)
					tooltipMouseLeave(e, instance, tooltip, {
						tooltipName: tooltipName,
						target: handleEl
					});
			}
		);
	};

	_proto2.getValues = function getValues(e, d) {
		if (d === void 0) {
			d = 0;
		}

		var _this$props$instance = this.props.instance,
			data = _this$props$instance.data,
			widget = _this$props$instance.widget;
		var minValue = data.minValue,
			maxValue = data.maxValue;
		var b = getTopLevelBoundingClientRect(this.dom.range);
		var pos = getCursorPos(e);
		var pct = widget.vertical
			? Math.max(0, Math.min(1, (pos.clientY - b.top - d) / this.dom.range.offsetHeight))
			: Math.max(0, Math.min(1, (pos.clientX - b.left - d) / this.dom.range.offsetWidth));
		var delta = (maxValue - minValue) * pct;

		if (data.step) {
			var currentValue = Math.round(delta / data.step) * data.step + minValue;
			var value = this.checkBoundries(currentValue);
			if (maxValue % data.step === 0) delta = Math.round(delta / data.step) * data.step;
			delta = value - minValue;
		}

		return {
			percent: delta / (maxValue - minValue),
			value: minValue + delta
		};
	};

	_proto2.onClick = function onClick(e) {
		var instance = this.props.instance;
		var data = instance.data,
			widget = instance.widget;

		if (!data.disabled && !data.readOnly) {
			var _this$getValues = this.getValues(e),
				value = _this$getValues.value;

			this.props.instance.set("value", value, {
				immediate: true
			});
			if (widget.showFrom)
				this.setState({
					from: value
				});
			if (widget.showTo)
				this.setState({
					to: value
				});
		}
	};

	_proto2.onWheel = function onWheel(e) {
		var instance = this.props.instance;
		var data = instance.data,
			widget = instance.widget;
		if ((widget.showFrom && widget.showTo) || !data.wheel) return;
		e.preventDefault();
		e.stopPropagation();
		var increment = e.deltaY > 0 ? this.getIncrement() : -this.getIncrement();

		if (!data.disabled && !data.readOnly) {
			if (widget.showFrom) {
				var value = this.checkBoundries(data.from + increment);
				if (instance.set("from", value))
					this.setState({
						from: value
					});
			} else if (widget.showTo) {
				var _value = this.checkBoundries(data.to + increment);

				if (instance.set("to", _value))
					this.setState({
						to: _value
					});
			}
		}
	};

	_proto2.checkBoundries = function checkBoundries(value) {
		var data = this.props.instance.data;
		if (value > data.maxValue) value = data.maxValue;
		else if (value < data.minValue) value = data.minValue;
		return value;
	};

	_proto2.getIncrement = function getIncrement() {
		var instance = this.props.instance;
		var data = instance.data;
		var increment = data.increment || (data.maxValue - data.minValue) * data.incrementPercentage;
		return increment;
	};

	return SliderComponent;
})(VDOM.Component);

var Switch = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(Switch, _Field);

	function Switch() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = Switch.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					on: false,
					off: true,
					value: undefined,
					disabled: undefined,
					enabled: undefined,
					readOnly: undefined,
					text: undefined,
					rangeStyle: {
						structured: true
					},
					handleStyle: {
						structured: true
					}
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.isEmpty = function isEmpty() {
		return false;
	};

	_proto.init = function init() {
		if (isDefined(this.value)) this.on = this.value;
		this.rangeStyle = parseStyle(this.rangeStyle);
		this.handleStyle = parseStyle(this.handleStyle);

		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		if (isDefined(this.off)) data.on = !data.off;
		data.stateMods = _objectSpread2(
			_objectSpread2({}, data.stateMods),
			{},
			{
				on: data.on,
				disabled: data.disabled
			}
		);

		_Field.prototype.prepareData.call(this, context, instance);
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		var _this = this;

		var data = instance.data,
			widget = instance.widget;
		var rangeStyle = data.rangeStyle,
			handleStyle = data.handleStyle;
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var text = data.text || this.renderChildren(context, instance);
		return /*#__PURE__*/ jsxs(
			"div",
			{
				className: data.classNames,
				style: data.style,
				id: data.id,
				tabIndex: data.disabled ? null : data.tabIndex || 0,
				onMouseDown: function onMouseDown(e) {
					e.stopPropagation();
					if (!_this.focusOnMouseDown) preventFocus(e);
				},
				onClick: function onClick(e) {
					_this.toggle(e, instance);
				},
				onKeyDown: function onKeyDown(e) {
					if (widget.handleKeyDown(e, instance) === false) return;

					if (e.keyCode == KeyCode.space) {
						_this.toggle(e, instance);
					}
				},
				onMouseMove: function onMouseMove(e) {
					return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(instance)));
				},
				onMouseLeave: function onMouseLeave(e) {
					return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(instance)));
				},
				children: [
					this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
					"\xA0",
					/*#__PURE__*/ jsxs("div", {
						className: CSS.element(baseClass, "axis"),
						children: [
							/*#__PURE__*/ jsx("div", {
								className: CSS.element(baseClass, "range"),
								style: parseStyle(rangeStyle)
							}),
							/*#__PURE__*/ jsx("div", {
								className: CSS.element(baseClass, "space"),
								children: /*#__PURE__*/ jsx("div", {
									className: CSS.element(baseClass, "handle"),
									style: parseStyle(handleStyle)
								})
							})
						]
					}),
					text &&
						/*#__PURE__*/ jsx(
							"div",
							{
								className: CSS.element(this.baseClass, "text"),
								children: text
							},
							"text"
						)
				]
			},
			key
		);
	};

	_proto.toggle = function toggle(e, instance) {
		var data = instance.data;
		if (data.readOnly || data.disabled) return;
		instance.set("on", !data.on);
		instance.set("off", data.on);
		e.preventDefault();
		e.stopPropagation();
	};

	return Switch;
})(Field);
Switch.prototype.baseClass = "switch";
Switch.prototype.focusOnMouseDown = false;
Widget.alias("switch", Switch);

var Wheel = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(Wheel, _PureContainer);

	function Wheel() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = Wheel.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					value: undefined,
					options: undefined
				}
			])
		);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		var value = data.value,
			options = data.options;
		var index = options.findIndex(function(a) {
			return a.id === value;
		});
		if (index === -1) index = Math.floor(options.length / 2);
		return /*#__PURE__*/ jsx(
			WheelComponent,
			{
				size: this.size,
				focusable: true,
				CSS: this.CSS,
				baseClass: this.baseClass,
				className: data.classNames,
				style: data.style,
				index: index,
				onChange: function onChange(newIndex) {
					var option = options[newIndex];
					instance.set("value", option.id);
				},
				children: options.map(function(o, i) {
					return /*#__PURE__*/ jsx(
						"span",
						{
							children: o.text
						},
						0
					);
				})
			},
			key
		);
	};

	return Wheel;
})(PureContainer);
Wheel.prototype.baseClass = "wheel";
Wheel.prototype.size = 3;
Wheel.prototype.styled = true;
var WheelComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(WheelComponent, _VDOM$Component);

	function WheelComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {};
		_this.index = props.index || 0;

		_this.wheelRef = function(el) {
			_this.wheelEl = el;
		};

		_this.scrollRef = function(el) {
			_this.scrollEl = el;
		};

		_this.onWheel = _this.onWheel.bind(_assertThisInitialized(_this));
		_this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_this));
		return _this;
	}

	var _proto2 = WheelComponent.prototype;

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			size = _this$props.size,
			children = _this$props.children,
			CSS = _this$props.CSS,
			baseClass = _this$props.baseClass,
			active = _this$props.active,
			className = _this$props.className,
			style = _this$props.style,
			onMouseDown = _this$props.onMouseDown;
		var optionClass = CSS.element(baseClass, "option");
		var dummyClass = CSS.element(baseClass, "option", {
			dummy: true
		});
		var tpad = [],
			bpad = [];

		for (var i = 0; i < (size - 1) / 2; i++) {
			tpad.push({
				key: -1 - i,
				child: children[0],
				cls: dummyClass
			});
			bpad.push({
				key: -100 - i,
				child: children[0],
				cls: dummyClass
			});
		}

		var displayedOptions = [].concat(
			tpad,
			children.map(function(c, i) {
				return {
					key: i,
					child: c,
					cls: optionClass
				};
			}),
			bpad
		);
		if (!this.state.wheelHeight) displayedOptions = displayedOptions.slice(this.index, this.index + size);
		return /*#__PURE__*/ jsxs("div", {
			tabIndex: this.props.focusable ? data.tabIndex || 0 : null,
			className:
				className ||
				CSS.element(baseClass, "container", {
					active: active
				}),
			style: style,
			onKeyDown: this.onKeyDown,
			children: [
				/*#__PURE__*/ jsxs("div", {
					className: CSS.element(baseClass, "clip"),
					style: {
						width: this.state.wheelWidth
					},
					onMouseDown: onMouseDown,
					children: [
						/*#__PURE__*/ jsx("div", {
							className: CSS.element(baseClass, "vscroll"),
							ref: this.scrollRef,
							onTouchStart: this.onTouchStart.bind(this),
							onTouchEnd: this.onTouchEnd.bind(this),
							children: /*#__PURE__*/ jsx("div", {
								className: CSS.element(baseClass, "wheel"),
								style: {
									height: this.state.wheelHeight
								},
								ref: this.wheelRef,
								children: displayedOptions.map(function(opt) {
									return /*#__PURE__*/ jsx(
										"div",
										{
											className: opt.cls,
											children: opt.child
										},
										opt.key
									);
								})
							})
						}),
						/*#__PURE__*/ jsx("div", {
							className: CSS.element(baseClass, "mask"),
							style: {
								top: "0",
								bottom: (50 + 50 / size).toFixed(3) + "%"
							}
						}),
						/*#__PURE__*/ jsx("div", {
							className: CSS.element(baseClass, "mask"),
							style: {
								top: (50 + 50 / size).toFixed(3) + "%",
								bottom: "0"
							}
						}),
						/*#__PURE__*/ jsx("div", {
							className: CSS.element(baseClass, "selection"),
							style: {
								height: (100 / size).toFixed(3) + "%",
								top: (50 - 50 / size).toFixed(3) + "%"
							}
						})
					]
				}),
				/*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "arrow-up"),
					onClick: function onClick(e) {
						e.preventDefault();

						_this2.select(_this2.index - 1);
					},
					children: Icon.render("drop-down", {
						className: CSS.element(baseClass, "arrow-icon")
					})
				}),
				/*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "arrow-down"),
					onClick: function onClick(e) {
						e.preventDefault();

						_this2.select(_this2.index + 1);
					},
					children: Icon.render("drop-down", {
						className: CSS.element(baseClass, "arrow-icon")
					})
				})
			]
		});
	};

	_proto2.componentDidMount = function componentDidMount() {
		var _this3 = this;

		this.unsubscribeOnWheel = addEventListenerWithOptions(this.wheelEl, "wheel", this.onWheel, {
			passive: false
		});
		this.setState(
			{
				wheelHeight: this.wheelEl.offsetHeight,
				wheelWidth: this.wheelEl.offsetWidth
			},
			function() {
				_this3.scrollEl.scrollTop = (_this3.index * _this3.state.wheelHeight) / _this3.props.size;
			}
		);
		if (this.props.onPipeKeyDown) this.props.onPipeKeyDown(this.onKeyDown);
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		this.index = props.index || 0;
		this.scrollTo();
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		this.scrolling = false;
		this.unsubscribeOnWheel();
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		switch (e.keyCode) {
			case KeyCode.up:
				e.preventDefault();
				this.select(this.index - 1);
				break;

			case KeyCode.down:
				e.preventDefault();
				this.select(this.index + 1);
				break;
		}
	};

	_proto2.onWheel = function onWheel(e) {
		e.preventDefault();
		var index = this.index;
		if (e.deltaY > 0) index++;
		else index--;
		this.select(index);
	};

	_proto2.onTouchStart = function onTouchStart(e) {
		this.scrolling = false;
	};

	_proto2.onTouchEnd = function onTouchEnd(e) {
		var size = this.props.size;
		var index = Math.round(this.scrollEl.scrollTop / (this.state.wheelHeight / size));
		this.select(index);
	};

	_proto2.select = function select(newIndex) {
		var children = this.props.children;
		newIndex = Math.max(0, Math.min(children.length - 1, newIndex));

		if (this.index !== newIndex) {
			this.index = newIndex;
			this.props.onChange(newIndex);
		}

		this.scrollTo();
	};

	_proto2.scrollTo = function scrollTo() {
		var _this4 = this;

		var size = this.props.size;

		var callback = function callback() {
			if (!_this4.scrolling) return;
			var x = (_this4.index * _this4.state.wheelHeight) / size;
			var delta = Math.round(x - _this4.scrollEl.scrollTop);

			if (delta === 0) {
				_this4.scrolling = false;
				return;
			}

			var sign = delta > 0 ? 1 : -1;
			delta = Math.abs(delta) / 10;
			if (delta < 1) delta = 1;
			_this4.scrollEl.scrollTop += sign * delta;
			requestAnimationFrame(callback);
		};

		if (!this.scrolling) {
			this.scrolling = true;
			requestAnimationFrame(callback);
		}
	};

	return WheelComponent;
})(VDOM.Component);

enableCultureSensitiveFormatting();
var DateTimePicker = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(DateTimePicker, _Widget);

	function DateTimePicker() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = DateTimePicker.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		return (_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					value: undefined
				}
			])
		);
	};

	_proto.render = function render(context, instance, key) {
		return /*#__PURE__*/ jsx(
			DateTimePickerComponent,
			{
				instance: instance,
				data: instance.data,
				size: this.size,
				segment: this.segment
			},
			key
		);
	};

	return DateTimePicker;
})(Widget);
DateTimePicker.prototype.baseClass = "datetimepicker";
DateTimePicker.prototype.styled = true;
DateTimePicker.prototype.size = 3;
DateTimePicker.prototype.autoFocus = false;
DateTimePicker.prototype.segment = "datetime";
DateTimePicker.prototype.showSeconds = false;

var DateTimePickerComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(DateTimePickerComponent, _VDOM$Component);

	function DateTimePickerComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		var date = props.data.value ? new Date(props.data.value) : new Date();
		if (isNaN(date.getTime())) date = new Date();
		_this.state = {
			date: date,
			activeWheel: null
		};
		var widget = props.instance.widget;
		_this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));
		_this.onFocus = _this.onFocus.bind(_assertThisInitialized(_this));
		_this.onBlur = _this.onBlur.bind(_assertThisInitialized(_this));
		_this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_this));
		var showDate = props.segment.indexOf("date") !== -1;
		var showTime = props.segment.indexOf("time") !== -1;
		_this.wheels = {
			year: showDate,
			month: showDate,
			date: showDate,
			hours: showTime,
			minutes: showTime,
			seconds: showTime && widget.showSeconds
		};
		_this.keyDownPipes = {};
		return _this;
	}

	var _proto2 = DateTimePickerComponent.prototype;

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var date = props.data.value ? new Date(props.data.value) : new Date();
		if (isNaN(date.getTime())) date = new Date();
		this.setState({
			date: date
		});
	};

	_proto2.setDateComponent = function setDateComponent(date, component, value) {
		var v = new Date(date);

		switch (component) {
			case "year":
				v.setFullYear(value);
				break;

			case "month":
				v.setMonth(value);
				break;

			case "date":
				v.setDate(value);
				break;

			case "hours":
				v.setHours(value);
				break;

			case "minutes":
				v.setMinutes(value);
				break;

			case "seconds":
				v.setSeconds(value);
				break;
		}

		return v;
	};

	_proto2.handleChange = function handleChange() {
		var encode = this.props.instance.widget.encoding || Culture.getDefaultDateEncoding();
		this.props.instance.set("value", encode(this.state.date));
	};

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			data = _this$props.data,
			size = _this$props.size;
		var widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var date = this.state.date;
		var culture = Culture.getDateTimeCulture();
		var monthNames = culture.getMonthNames("short");
		var years = [];

		for (var y = 1970; y <= 2050; y++) {
			years.push(
				/*#__PURE__*/ jsx(
					"span",
					{
						children: y
					},
					y
				)
			);
		}

		var days = [];
		var start = new Date(date.getFullYear(), date.getMonth(), 1);

		while (start.getMonth() === date.getMonth()) {
			var day = start.getDate();
			days.push(
				/*#__PURE__*/ jsx(
					"span",
					{
						children: day < 10 ? "0" + day : day
					},
					day
				)
			);
			start.setDate(start.getDate() + 1);
		}

		var hours = [];

		for (var h = 0; h < 24; h++) {
			hours.push(
				/*#__PURE__*/ jsx(
					"span",
					{
						children: h < 10 ? "0" + h : h
					},
					h
				)
			);
		}

		var minutes = [];

		for (var m = 0; m < 60; m++) {
			minutes.push(
				/*#__PURE__*/ jsx(
					"span",
					{
						children: m < 10 ? "0" + m : m
					},
					m
				)
			);
		}

		return /*#__PURE__*/ jsxs("div", {
			tabIndex: 0,
			ref: function ref(el) {
				_this2.el = el;
			},
			className: data.classNames,
			onFocus: this.onFocus,
			onBlur: this.onBlur,
			onKeyDown: this.onKeyDown,
			children: [
				this.wheels.year &&
					/*#__PURE__*/ jsx(WheelComponent, {
						size: size,
						CSS: CSS,
						active: this.state.activeWheel === "year",
						baseClass: baseClass + "-wheel",
						index: date.getFullYear() - 1970,
						onChange: function onChange(newIndex) {
							_this2.setState(function(state) {
								return {
									date: _this2.setDateComponent(_this2.state.date, "year", newIndex + 1970)
								};
							}, _this2.handleChange);
						},
						onPipeKeyDown: function onPipeKeyDown(kd) {
							_this2.keyDownPipes["year"] = kd;
						},
						onMouseDown: function onMouseDown() {
							_this2.setState({
								activeWheel: "year"
							});
						},
						children: years
					}),
				this.wheels.year &&
					this.wheels.month &&
					/*#__PURE__*/ jsx("span", {
						children: "-"
					}),
				this.wheels.month &&
					/*#__PURE__*/ jsx(WheelComponent, {
						size: size,
						CSS: CSS,
						active: this.state.activeWheel === "month",
						baseClass: baseClass + "-wheel",
						index: date.getMonth(),
						onChange: function onChange(newIndex) {
							_this2.setState(function(state) {
								return {
									date: _this2.setDateComponent(_this2.state.date, "month", newIndex)
								};
							}, _this2.handleChange);
						},
						onPipeKeyDown: function onPipeKeyDown(kd) {
							_this2.keyDownPipes["month"] = kd;
						},
						onMouseDown: function onMouseDown() {
							_this2.setState({
								activeWheel: "month"
							});
						},
						children: monthNames.map(function(m, i) {
							return /*#__PURE__*/ jsx(
								"span",
								{
									children: m
								},
								i
							);
						})
					}),
				this.wheels.month &&
					this.wheels.date &&
					/*#__PURE__*/ jsx("span", {
						children: "-"
					}),
				this.wheels.date &&
					/*#__PURE__*/ jsx(WheelComponent, {
						size: size,
						CSS: CSS,
						active: this.state.activeWheel === "date",
						baseClass: baseClass + "-wheel",
						index: date.getDate() - 1,
						onChange: function onChange(newIndex) {
							_this2.setState(function(state) {
								return {
									date: _this2.setDateComponent(_this2.state.date, "date", newIndex + 1)
								};
							}, _this2.handleChange);
						},
						onPipeKeyDown: function onPipeKeyDown(kd) {
							_this2.keyDownPipes["date"] = kd;
						},
						onMouseDown: function onMouseDown() {
							_this2.setState({
								activeWheel: "date"
							});
						},
						children: days
					}),
				this.wheels.hours &&
					this.wheels.year &&
					/*#__PURE__*/ jsx("span", {
						className: CSS.element(baseClass, "spacer")
					}),
				this.wheels.hours &&
					/*#__PURE__*/ jsx(WheelComponent, {
						size: size,
						CSS: CSS,
						active: this.state.activeWheel === "hours",
						baseClass: baseClass + "-wheel",
						index: date.getHours(),
						onChange: function onChange(newIndex) {
							_this2.setState(function(state) {
								return {
									date: _this2.setDateComponent(_this2.state.date, "hours", newIndex)
								};
							}, _this2.handleChange);
						},
						onPipeKeyDown: function onPipeKeyDown(kd) {
							_this2.keyDownPipes["hours"] = kd;
						},
						onMouseDown: function onMouseDown() {
							_this2.setState({
								activeWheel: "hours"
							});
						},
						children: hours
					}),
				this.wheels.hours &&
					this.wheels.minutes &&
					/*#__PURE__*/ jsx("span", {
						children: ":"
					}),
				this.wheels.minutes &&
					/*#__PURE__*/ jsx(WheelComponent, {
						size: size,
						CSS: CSS,
						baseClass: baseClass + "-wheel",
						active: this.state.activeWheel === "minutes",
						index: date.getMinutes(),
						onChange: function onChange(newIndex) {
							_this2.setState(function(state) {
								return {
									date: _this2.setDateComponent(_this2.state.date, "minutes", newIndex)
								};
							}, _this2.handleChange);
						},
						onPipeKeyDown: function onPipeKeyDown(kd) {
							_this2.keyDownPipes["minutes"] = kd;
						},
						onMouseDown: function onMouseDown() {
							_this2.setState({
								activeWheel: "minutes"
							});
						},
						children: minutes
					}),
				this.wheels.minutes &&
					this.wheels.seconds &&
					/*#__PURE__*/ jsx("span", {
						children: ":"
					}),
				this.wheels.seconds &&
					/*#__PURE__*/ jsx(WheelComponent, {
						size: size,
						CSS: CSS,
						baseClass: baseClass + "-wheel",
						active: this.state.activeWheel === "seconds",
						index: date.getSeconds(),
						onChange: function onChange(newIndex) {
							_this2.setState(function(state) {
								return {
									date: _this2.setDateComponent(_this2.state.date, "seconds", newIndex)
								};
							}, _this2.handleChange);
						},
						onPipeKeyDown: function onPipeKeyDown(kd) {
							_this2.keyDownPipes["seconds"] = kd;
						},
						onMouseDown: function onMouseDown() {
							_this2.setState({
								activeWheel: "seconds"
							});
						},
						children: minutes
					})
			]
		});
	};

	_proto2.componentDidMount = function componentDidMount() {
		if (this.props.instance.widget.autoFocus) this.el.focus();
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		offFocusOut(this);
	};

	_proto2.onFocus = function onFocus() {
		oneFocusOut(this, this.el, this.onFocusOut.bind(this));

		if (!this.state.activeWheel) {
			var firstWheel = null;

			for (var wheel in this.wheels) {
				if (this.wheels[wheel]) {
					firstWheel = wheel;
					break;
				}
			}

			this.setState({
				activeWheel: firstWheel
			});
		}
	};

	_proto2.onFocusOut = function onFocusOut() {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onFocusOut) instance.invoke("onFocusOut", null, instance);
	};

	_proto2.onBlur = function onBlur() {
		this.setState({
			activeWheel: null
		});
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var tmp = null;
		var instance = this.props.instance;

		switch (e.keyCode) {
			case KeyCode.right:
				e.preventDefault();

				for (var wheel in this.wheels) {
					if (this.wheels[wheel]) {
						if (tmp === this.state.activeWheel) {
							this.setState({
								activeWheel: wheel
							});
							break;
						}

						tmp = wheel;
					}
				}

				break;

			case KeyCode.left:
				e.preventDefault();

				for (var _wheel in this.wheels) {
					if (this.wheels[_wheel]) {
						if (_wheel === this.state.activeWheel && tmp) {
							this.setState({
								activeWheel: tmp
							});
							break;
						}

						tmp = _wheel;
					}
				}

				break;

			case KeyCode.enter:
				e.preventDefault();
				if (instance.widget.onSelect) instance.invoke("onSelect", e, instance, this.state.date);
				break;

			default:
				var kdp = this.keyDownPipes[this.state.activeWheel];
				if (kdp) kdp(e);
				break;
		}
	};

	return DateTimePickerComponent;
})(VDOM.Component);

var TimeList = createFunctionalComponent(function(_ref) {
	var value = _ref.value,
		step = _ref.step,
		format = _ref.format,
		encoding = _ref.encoding,
		onSelect = _ref.onSelect,
		props = _objectWithoutPropertiesLoose(_ref, ["value", "step", "format", "encoding", "onSelect"]);

	return {
		$type: ContentResolver,
		params: {
			step: step,
			format: format,
			dummy: true
		},
		onResolve: function onResolve(_ref2) {
			var step = _ref2.step,
				format = _ref2.format;
			var max = 24 * 60;
			if (!step) step = 15;
			if (step < 1) step = 1;
			var times = [];
			var today = zeroTime(new Date()).valueOf();

			for (var m = 0; m < max; m += step) {
				var time = m * 60 * 1000;
				times.push({
					id: m * 60 * 1000,
					text: Format$1.value(today + time, format || "datetime;HHmm")
				});
			}

			var stepMs = step * 60 * 1000;
			return {
				$type: DataProxy,
				data: {
					$value: value
				},
				immutable: true,
				jsxAttributes: ["data", "immutable"],
				children: [
					"\n                        ",
					{
						$type: DataProxy,
						data: {
							$selection: {
								get: function get(_ref3) {
									var $value = _ref3.$value;
									if ($value == null) return null;
									var selectionDate = new Date($value);
									var selectionTime = selectionDate.valueOf() - zeroTime(selectionDate).valueOf();
									return (Math.round(selectionTime / stepMs) * stepMs) % 86400000;
								},
								set: function set(value, instance) {
									var store = instance.store;
									var $value = store.get("$value");
									var copy = $value ? new Date($value) : new Date();
									var today = zeroTime(new Date()).valueOf();
									var date = new Date(today + value);
									copy.setHours(date.getHours());
									copy.setMinutes(date.getMinutes());
									copy.setSeconds(date.getSeconds());
									copy.setMilliseconds(0);
									var encode = encoding || Culture.getDefaultDateEncoding();
									store.set("$value", encode(copy));
								}
							}
						},
						jsxAttributes: ["data"],
						children: [
							"\n                           ",
							{
								$type: List,
								records: times,
								recordAlias: "$time",
								selection: {
									type: KeySelection,
									selection: {
										bind: "$selection"
									}
								},
								onItemClick: function onItemClick(e, instance) {
									if (!onSelect) return;
									var date = new Date(instance.store.get("$value"));
									if (isString(onSelect)) instance.invokeControllerMethod(onSelect, e, instance, date);
									else if (isFunction(onSelect)) onSelect(e, instance, date);
								},
								jsxSpread: [props],
								jsxAttributes: ["records", "recordAlias", "selection", "onItemClick"],
								children: [
									"\n                              ",
									{
										$type: HtmlElement$1,
										tag: "div",
										text: {
											bind: "$time.text"
										},
										jsxAttributes: ["text"]
									},
									"\n                           "
								]
							},
							"\n                        "
						]
					},
					"\n                     "
				]
			};
		},
		jsxAttributes: ["params", "onResolve"]
	};
});

var DateTimeField = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(DateTimeField, _Field);

	function DateTimeField() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = DateTimeField.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		(_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[
				this,
				{
					value: this.emptyValue,
					disabled: undefined,
					readOnly: undefined,
					enabled: undefined,
					placeholder: undefined,
					required: undefined,
					minValue: undefined,
					minExclusive: undefined,
					maxValue: undefined,
					maxExclusive: undefined,
					format: undefined,
					icon: undefined,
					autoOpen: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.init = function init() {
		if (typeof this.hideClear !== "undefined") this.showClear = !this.hideClear;
		if (this.alwaysShowClear) this.showClear = true;

		if (!this.format) {
			switch (this.segment) {
				case "datetime":
					this.format = "datetime;YYYYMMddhhmm";
					break;

				case "time":
					this.format = "time;hhmm";
					break;

				case "date":
					this.format = "date;yyyyMMMdd";
					break;
			}
		}

		_Field.prototype.init.call(this);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;

		if (data.value) {
			var date = new Date(data.value);
			if (isNaN(date.getTime())) data.formatted = String(data.value);
			else {
				// handle utc edge cases
				if (this.segment == "date") date = zeroTime(date);
				data.formatted = Format$1.value(date, data.format);
			}
			data.date = date;
		} else data.formatted = "";

		if (data.refDate) data.refDate = zeroTime(new Date(data.refDate));
		if (data.maxValue) data.maxValue = new Date(data.maxValue);
		if (data.minValue) data.minValue = new Date(data.minValue);

		if (this.segment == "date") {
			if (data.minValue) data.minValue = zeroTime(data.minValue);
			if (data.maxValue) data.maxValue = zeroTime(data.maxValue);
		}

		instance.lastDropdown = context.lastDropdown;

		_Field.prototype.prepareData.call(this, context, instance);
	};

	_proto.validate = function validate(context, instance) {
		_Field.prototype.validate.call(this, context, instance);

		var data = instance.data,
			widget = instance.widget;

		if (!data.error && data.date) {
			if (isNaN(data.date)) data.error = this.inputErrorText;
			else {
				var d;

				if (data.maxValue) {
					d = dateDiff(data.date, data.maxValue);
					if (d > 0) data.error = StringTemplate.format(this.maxValueErrorText, data.maxValue);
					else if (d == 0 && data.maxExclusive)
						data.error = StringTemplate.format(this.maxExclusiveErrorText, data.maxValue);
				}

				if (data.minValue) {
					d = dateDiff(data.date, data.minValue);
					if (d < 0) data.error = StringTemplate.format(this.minValueErrorText, data.minValue);
					else if (d == 0 && data.minExclusive)
						data.error = StringTemplate.format(this.minExclusiveErrorText, data.minValue);
				}

				if (widget.disabledDaysOfWeek) {
					if (widget.disabledDaysOfWeek.includes(data.date.getDay())) data.error = this.disabledDaysOfWeekErrorText;
				}
			}
		}
	};

	_proto.renderInput = function renderInput(context, instance, key) {
		return /*#__PURE__*/ jsx(
			DateTimeInput,
			{
				instance: instance,
				data: instance.data,
				picker: {
					value: this.value,
					minValue: this.minValue,
					maxValue: this.maxValue,
					minExclusive: this.minExclusive,
					maxExclusive: this.maxExclusive,
					maxValueErrorText: this.maxValueErrorText,
					maxExclusiveErrorText: this.maxExclusiveErrorText,
					minValueErrorText: this.minValueErrorText,
					minExclusiveErrorText: this.minExclusiveErrorText
				},
				label: this.labelPlacement && getContent(this.renderLabel(context, instance, "label")),
				help: this.helpPlacement && getContent(this.renderHelp(context, instance, "help"))
			},
			key
		);
	};

	_proto.formatValue = function formatValue(context, _ref) {
		var data = _ref.data;
		return data.value ? data.formatted : null;
	};

	_proto.parseDate = function parseDate(date, instance) {
		if (!date) return null;
		if (date instanceof Date) return date;

		if (this.onParseInput) {
			var result = instance.invoke("onParseInput", date, instance);
			if (result !== undefined) return result;
		}

		date = Culture.getDateTimeCulture().parse(date, {
			useCurrentDateForDefaults: true
		});
		return date;
	};

	return DateTimeField;
})(Field);
DateTimeField.prototype.baseClass = "datetimefield";
DateTimeField.prototype.maxValueErrorText = "Select {0:d} or before.";
DateTimeField.prototype.maxExclusiveErrorText = "Select a date before {0:d}.";
DateTimeField.prototype.minValueErrorText = "Select {0:d} or later.";
DateTimeField.prototype.minExclusiveErrorText = "Select a date after {0:d}.";
DateTimeField.prototype.inputErrorText = "Invalid date entered.";
DateTimeField.prototype.disabledDaysOfWeekErrorText = "Selected day of week is not allowed.";
DateTimeField.prototype.suppressErrorsUntilVisited = true;
DateTimeField.prototype.icon = "calendar";
DateTimeField.prototype.showClear = true;
DateTimeField.prototype.alwaysShowClear = false;
DateTimeField.prototype.reactOn = "enter blur";
DateTimeField.prototype.segment = "datetime";
DateTimeField.prototype.picker = "auto";
DateTimeField.prototype.disabledDaysOfWeek = null;
DateTimeField.prototype.focusInputFirst = false;
Widget.alias("datetimefield", DateTimeField);
Localization.registerPrototype("cx/widgets/DateTimeField", DateTimeField);

var DateTimeInput = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(DateTimeInput, _VDOM$Component);

	function DateTimeInput(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		props.instance.component = _assertThisInitialized(_this);
		_this.state = {
			dropdownOpen: false,
			focus: false
		};
		return _this;
	}

	var _proto2 = DateTimeInput.prototype;

	_proto2.getDropdown = function getDropdown() {
		var _this2 = this;

		if (this.dropdown) return this.dropdown;
		var _this$props$instance = this.props.instance,
			widget = _this$props$instance.widget,
			lastDropdown = _this$props$instance.lastDropdown;
		var pickerConfig;

		switch (widget.picker) {
			case "calendar":
				pickerConfig = {
					type: Calendar,
					partial: widget.partial,
					encoding: widget.encoding,
					disabledDaysOfWeek: widget.disabledDaysOfWeek,
					focusable: !widget.focusInputFirst
				};
				break;

			case "list":
				pickerConfig = {
					type: TimeList,
					style: "height: 300px",
					encoding: widget.encoding,
					step: widget.step,
					format: widget.format,
					scrollSelectionIntoView: true
				};
				break;

			default:
				pickerConfig = {
					type: DateTimePicker,
					segment: widget.segment,
					encoding: widget.encoding
				};
				break;
		}

		var dropdown = _objectSpread2(
			_objectSpread2(
				{
					scrollTracking: true,
					inline: !isTouchDevice() || !!lastDropdown,
					matchWidth: false,
					placementOrder: "down down-right down-left up up-right up-left",
					touchFriendly: true,
					firstChildDefinesHeight: true,
					firstChildDefinesWidth: true
				},
				widget.dropdownOptions
			),
			{},
			{
				type: Dropdown,
				relatedElement: this.input,
				onFocusOut: function onFocusOut(e) {
					_this2.closeDropdown(e);
				},
				items: _objectSpread2(
					_objectSpread2(_objectSpread2({}, pickerConfig), this.props.picker),
					{},
					{
						autoFocus: !widget.focusInputFirst,
						tabIndex: widget.focusInputFirst ? -1 : 0,
						onKeyDown: function onKeyDown(e) {
							return _this2.onKeyDown(e);
						},
						onSelect: function onSelect(e, calendar, date) {
							e.stopPropagation();
							e.preventDefault();
							var touch = isTouchEvent(e);

							_this2.closeDropdown(e, function() {
								if (date) {
									// If a blur event occurs before we re-render the input,
									// the old input value is parsed and written to the store.
									// We want to prevent that by eagerly updating the input value.
									// This can happen if the date field is within a menu.
									var newFormattedValue = Format$1.value(date, _this2.props.data.format);
									_this2.input.value = newFormattedValue;
								}

								if (!touch) _this2.input.focus();
							});
						}
					}
				)
			}
		);

		return (this.dropdown = Widget.create(dropdown));
	};

	_proto2.render = function render() {
		var _this3 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			label = _this$props.label,
			help = _this$props.help;
		var data = instance.data,
			widget = instance.widget,
			state = instance.state;
		var CSS = widget.CSS,
			baseClass = widget.baseClass,
			suppressErrorsUntilVisited = widget.suppressErrorsUntilVisited;
		var insideButton, icon;

		if (!data.readOnly && !data.disabled) {
			if (
				widget.showClear &&
				(((widget.alwaysShowClear || !data.required) && !data.empty) || instance.state.inputError)
			)
				insideButton = /*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "clear"),
					onMouseDown: function onMouseDown(e) {
						e.preventDefault();
						e.stopPropagation();
					},
					onClick: function onClick(e) {
						return _this3.onClearClick(e);
					},
					children: /*#__PURE__*/ jsx(ClearIcon, {
						className: CSS.element(baseClass, "icon")
					})
				});
			else
				insideButton = /*#__PURE__*/ jsx("div", {
					className: CSS.element(baseClass, "right-icon"),
					children: /*#__PURE__*/ jsx(DropdownIcon, {
						className: CSS.element(baseClass, "icon")
					})
				});
		}

		if (data.icon) {
			icon = /*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "left-icon"),
				children: Icon.render(data.icon, {
					className: CSS.element(baseClass, "icon")
				})
			});
		}

		var dropdown = false;
		if (this.state.dropdownOpen)
			dropdown = /*#__PURE__*/ jsx(Cx, {
				widget: this.getDropdown(),
				parentInstance: instance,
				options: {
					name: "datefield-dropdown"
				},
				subscribe: true
			});
		var empty = this.input ? !this.input.value : data.empty;
		return /*#__PURE__*/ jsxs("div", {
			className: CSS.expand(
				data.classNames,
				CSS.state({
					visited: state.visited,
					focus: this.state.focus || this.state.dropdownOpen,
					icon: !!icon,
					empty: empty && !data.placeholder,
					error: data.error && (state.visited || !suppressErrorsUntilVisited || !empty)
				})
			),
			style: data.style,
			onMouseDown: this.onMouseDown.bind(this),
			onTouchStart: stopPropagation,
			children: [
				/*#__PURE__*/ jsx(
					"input",
					_objectSpread2(
						_objectSpread2(
							{
								id: data.id,
								ref: function ref(el) {
									_this3.input = el;
								},
								type: "text",
								className: CSS.expand(CSS.element(baseClass, "input"), data.inputClass),
								style: data.inputStyle,
								defaultValue: data.formatted,
								disabled: data.disabled,
								readOnly: data.readOnly,
								tabIndex: data.tabIndex,
								placeholder: data.placeholder
							},
							data.inputAttrs
						),
						{},
						{
							onInput: function onInput(e) {
								return _this3.onChange(e, "input");
							},
							onChange: function onChange(e) {
								return _this3.onChange(e, "change");
							},
							onKeyDown: function onKeyDown(e) {
								return _this3.onKeyDown(e);
							},
							onBlur: function onBlur(e) {
								_this3.onBlur(e);
							},
							onFocus: function onFocus(e) {
								_this3.onFocus(e);
							},
							onMouseMove: function onMouseMove(e) {
								return tooltipMouseMove.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
							},
							onMouseLeave: function onMouseLeave(e) {
								return tooltipMouseLeave.apply(void 0, [e].concat(getFieldTooltip(_this3.props.instance)));
							}
						}
					)
				),
				icon,
				insideButton,
				dropdown,
				label,
				help
			]
		});
	};

	_proto2.onMouseDown = function onMouseDown(e) {
		e.stopPropagation();

		if (this.state.dropdownOpen) {
			this.closeDropdown(e);
		} else {
			this.openDropdownOnFocus = true;
		} //icon click

		if (e.target !== this.input) {
			e.preventDefault(); //the field should not focus only in case when dropdown will open and autofocus

			if (this.props.instance.widget.focusInputFirst || this.state.dropdownOpen) this.input.focus();
			if (this.state.dropdownOpen) this.closeDropdown(e);
			else this.openDropdown(e);
		}
	};

	_proto2.onFocus = function onFocus(e) {
		var instance = this.props.instance;
		var widget = instance.widget;

		if (widget.trackFocus) {
			this.setState({
				focus: true
			});
		}

		if (this.openDropdownOnFocus || widget.focusInputFirst) this.openDropdown(e);
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var _this4 = this;

		var instance = this.props.instance;
		if (instance.widget.handleKeyDown(e, instance) === false) return;

		switch (e.keyCode) {
			case KeyCode.enter:
				this.onChange(e, "enter");
				break;

			case KeyCode.esc:
				if (this.state.dropdownOpen) {
					e.stopPropagation();
					this.closeDropdown(e, function() {
						_this4.input.focus();
					});
				}

				break;

			case KeyCode.left:
			case KeyCode.right:
				e.stopPropagation();
				break;

			case KeyCode.down:
				this.openDropdown(e);
				e.stopPropagation();
				e.preventDefault();
				break;
		}
	};

	_proto2.onBlur = function onBlur(e) {
		if (!this.state.dropdownOpen)
			this.props.instance.setState({
				visited: true
			});
		else if (this.props.instance.widget.focusInputFirst) this.closeDropdown(e);
		if (this.state.focus)
			this.setState({
				focus: false
			});
		this.onChange(e, "blur");
	};

	_proto2.closeDropdown = function closeDropdown(e, callback) {
		var _this5 = this;

		if (this.state.dropdownOpen) {
			if (this.scrollableParents)
				this.scrollableParents.forEach(function(el) {
					el.removeEventListener("scroll", _this5.updateDropdownPosition);
				});
			this.setState(
				{
					dropdownOpen: false
				},
				callback
			);
			this.props.instance.setState({
				visited: true
			});
		} else if (callback) callback();
	};

	_proto2.openDropdown = function openDropdown() {
		var data = this.props.instance.data;
		this.openDropdownOnFocus = false;

		if (!this.state.dropdownOpen && !(data.disabled || data.readOnly)) {
			this.setState({
				dropdownOpen: true,
				dropdownOpenTime: Date.now()
			});
		}
	};

	_proto2.onClearClick = function onClearClick(e) {
		this.setValue(null);
		e.stopPropagation();
		e.preventDefault();
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var _props$instance = props.instance,
			data = _props$instance.data,
			state = _props$instance.state;

		if (data.formatted !== this.input.value && (data.formatted !== this.props.data.formatted || !state.inputError)) {
			this.input.value = data.formatted || "";
			props.instance.setState({
				inputError: false
			});
		}

		tooltipParentWillReceiveProps.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
	};

	_proto2.componentDidMount = function componentDidMount() {
		tooltipParentDidMount.apply(void 0, [this.input].concat(getFieldTooltip(this.props.instance)));
		autoFocus(this.input, this);
		if (this.props.data.autoOpen) this.openDropdown();
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		autoFocus(this.input, this);
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		tooltipParentWillUnmount(this.props.instance);
	};

	_proto2.onChange = function onChange(e, eventType) {
		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data;
		var widget = instance.widget;
		if (data.disabled || data.readOnly) return;
		if (widget.reactOn.indexOf(eventType) === -1) return;
		if (eventType == "enter")
			instance.setState({
				visited: true
			});
		this.setValue(e.target.value, data.value);
	};

	_proto2.setValue = function setValue(text, baseValue) {
		var _this$props3 = this.props,
			instance = _this$props3.instance,
			data = _this$props3.data;
		var widget = instance.widget;
		var date = widget.parseDate(text, instance);
		instance.setState({
			inputError: isNaN(date) && widget.inputErrorText
		});

		if (!isNaN(date)) {
			var mixed = new Date(baseValue);

			if (date && baseValue && !isNaN(mixed) && widget.partial) {
				switch (widget.segment) {
					case "date":
						mixed.setFullYear(date.getFullYear());
						mixed.setMonth(date.getMonth());
						mixed.setDate(date.getDate());
						break;

					case "time":
						mixed.setHours(date.getHours());
						mixed.setMinutes(date.getMinutes());
						mixed.setSeconds(date.getSeconds());
						break;

					default:
						mixed = date;
						break;
				}

				date = mixed;
			}

			var encode = widget.encoding || Culture.getDefaultDateEncoding();
			var value = date ? encode(date) : widget.emptyValue;
			if (!instance.set("value", value)) this.input.value = value ? Format$1.value(date, data.format) : "";
		}
	};

	return DateTimeInput;
})(VDOM.Component);

var DateField = /*#__PURE__*/ (function(_DateTimeField) {
	_inheritsLoose(DateField, _DateTimeField);

	function DateField() {
		return _DateTimeField.apply(this, arguments) || this;
	}

	return DateField;
})(DateTimeField);
DateField.prototype.picker = "calendar";
DateField.prototype.segment = "date";
Widget.alias("datefield", DateField);
Localization.registerPrototype("cx/widgets/DateField", DateField);

var TimeField = /*#__PURE__*/ (function(_DateTimeField) {
	_inheritsLoose(TimeField, _DateTimeField);

	function TimeField() {
		return _DateTimeField.apply(this, arguments) || this;
	}

	return TimeField;
})(DateTimeField);
TimeField.prototype.segment = "time";
Widget.alias("timefield", TimeField);
Localization.registerPrototype("cx/widgets/TimeField", TimeField);

var Validator = /*#__PURE__*/ (function(_Field) {
	_inheritsLoose(Validator, _Field);

	function Validator() {
		return _Field.apply(this, arguments) || this;
	}

	var _proto = Validator.prototype;

	_proto.declareData = function declareData() {
		var _Field$prototype$decl;

		return (_Field$prototype$decl = _Field.prototype.declareData).call.apply(
			_Field$prototype$decl,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					value: {
						structured: true
					},
					disabled: undefined
				}
			])
		);
	};

	_proto.isEmpty = function isEmpty(data) {
		return false;
	};

	_proto.render = function render() {
		return null;
	};

	return Validator;
})(Field);

var DropDownIcon = registerIcon(
	"sort-asc",
	function(props) {
		return /*#__PURE__*/ jsx(
			"svg",
			_objectSpread2(
				_objectSpread2({}, props),
				{},
				{
					viewBox: "0 0 16 16",
					children: /*#__PURE__*/ jsx("path", {
						fill: "currentColor",
						d: "M10.5 5.8l-3-3-3 3 .707.708L7 4.688v8.312h1V4.69l1.793 1.817z"
					})
				}
			)
		);
	},
	true
);

var GridCell = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(GridCell, _PureContainer);

	function GridCell() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto = GridCell.prototype;

	_proto.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					value: undefined,
					aggregateValue: undefined,
					weight: undefined,
					pad: undefined,
					format: undefined,
					colSpan: undefined,
					rowSpan: undefined,
					editable: undefined,
					fixed: undefined
				}
			])
		);
	};

	_proto.init = function init() {
		if (!this.value && this.field)
			this.value = {
				bind: this.recordName + "." + this.field
			};
		if (isUndefined(this.editable)) this.editable = !!this.editor;

		_PureContainer.prototype.init.call(this);
	};

	_proto.prepareCSS = function prepareCSS(context, instance) {
		var _this$CSS$state;

		var data = instance.data;
		data.classNames = this.CSS.expand(
			data.className,
			data["class"],
			this.CSS.state(
				((_this$CSS$state = {
					pad: data.pad,
					editable: data.editable
				}),
				(_this$CSS$state["aligned-" + this.align] = this.align),
				_this$CSS$state)
			)
		);
		data.style = this.CSS.parseStyle(data.style);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		var content;
		if (this.items.length > 0) content = this.renderChildren(context, instance);
		else {
			content = data.value;
			if (data.format) content = Format.value(content, data.format);
		}
		return {
			atomic: true,
			content: content,
			instance: instance,
			data: data,
			key: key,
			uniqueColumnId: this.uniqueColumnId
		};
	};

	return GridCell;
})(PureContainer);
GridCell.prototype.pad = true;
GridCell.prototype.styled = true;
GridCell.prototype.fixed = false;

var GridRowLine = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(GridRowLine, _Container);

	function GridRowLine() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = GridRowLine.prototype;

	_proto.init = function init() {
		this.items = Widget.create(GridCell, this.columns || [], {
			recordName: this.recordName
		});

		_Container.prototype.init.call(this);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return {
			key: key,
			data: data,
			content: this.renderChildren(context, instance),
			atomic: true
		};
	};

	return GridRowLine;
})(Container);
GridRowLine.prototype.styled = true;

var GridRow = /*#__PURE__*/ (function(_ValidationGroup) {
	_inheritsLoose(GridRow, _ValidationGroup);

	function GridRow() {
		return _ValidationGroup.apply(this, arguments) || this;
	}

	var _proto = GridRow.prototype;

	_proto.declareData = function declareData() {
		var _ValidationGroup$prot;

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		(_ValidationGroup$prot = _ValidationGroup.prototype.declareData).call.apply(
			_ValidationGroup$prot,
			[this].concat(args, [
				{
					hoverId: undefined
				}
			])
		);
	};

	_proto.init = function init() {
		this.items = [];

		for (var i = 0; i < 10; i++) {
			if (this["line" + i])
				this.items.push(
					GridRowLine.create(this["line" + i], {
						recordName: this.recordName
					})
				);
		}

		_ValidationGroup.prototype.init.call(this);
	};

	_proto.explore = function explore(context, instance) {
		context.push("dragHandles", (instance.dragHandles = []));

		_ValidationGroup.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		_ValidationGroup.prototype.exploreCleanup.call(this, context, instance);

		context.pop("dragHandles");
	};

	return GridRow;
})(ValidationGroup);
GridRow.prototype.styled = true; //styles used on the wrapper component

var GridRowComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(GridRowComponent, _VDOM$Component);

	function GridRowComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.onMouseMove = _this.onMouseMove.bind(_assertThisInitialized(_this));
		_this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized(_this));
		_this.onMouseLeave = _this.onMouseLeave.bind(_assertThisInitialized(_this));
		_this.onClick = _this.onClick.bind(_assertThisInitialized(_this));
		_this.onKeyDown = _this.onKeyDown.bind(_assertThisInitialized(_this));
		var grid = props.grid,
			instance = props.instance;
		if (grid.widget.onRowDoubleClick)
			_this.onDoubleClick = function(e) {
				grid.invoke("onRowDoubleClick", e, instance);
			};
		if (grid.widget.cellEditable)
			_this.onDoubleClick = function(e) {
				_this.props.parent.moveCursor(_this.props.cursorIndex, {
					cellEdit: true
				});

				e.preventDefault(); //prevent text selection
			};
		if (grid.widget.onRowContextMenu)
			_this.onRowContextMenu = function(e) {
				grid.invoke("onRowContextMenu", e, instance);
			};
		return _this;
	}

	var _proto2 = GridRowComponent.prototype;

	_proto2.render = function render() {
		var _this$props = this.props,
			className = _this$props.className,
			dragSource = _this$props.dragSource,
			instance = _this$props.instance,
			record = _this$props.record;
		var data = instance.data,
			widget = instance.widget;
		var CSS = widget.CSS;
		var move, up, keyDown, leave;

		if (dragSource || data.hoverId) {
			move = this.onMouseMove;
			up = ddMouseUp;
		}

		if (data.hoverId) {
			leave = this.onMouseLeave;
		}

		if (widget.onRowClick) keyDown = this.onKeyDown;
		return /*#__PURE__*/ jsx("tbody", {
			className: CSS.expand(data.classNames, className, this.state && this.state.hover && CSS.state("hover")),
			style: data.style,
			onClick: this.onClick,
			onDoubleClick: this.onDoubleClick,
			onTouchStart: this.onMouseDown,
			onMouseDown: this.onMouseDown,
			onTouchMove: move,
			onMouseMove: move,
			onMouseLeave: leave,
			onTouchEnd: up,
			onMouseUp: up,
			onKeyDown: keyDown,
			onContextMenu: this.onRowContextMenu,
			"data-record-key": record.key,
			children: this.props.children
		});
	};

	_proto2.onMouseDown = function onMouseDown(e) {
		var _this$props2 = this.props,
			grid = _this$props2.grid,
			record = _this$props2.record,
			instance = _this$props2.instance,
			parent = _this$props2.parent,
			cursorIndex = _this$props2.cursorIndex;

		if (this.props.dragSource) {
			ddMouseDown(e);

			if (isDragHandleEvent(e) || instance.dragHandles.length == 0) {
				e.preventDefault();
				e.stopPropagation(); //close context menu

				if (!getActiveElement().contains(e.target)) document.activeElement.blur();
			}
		}

		var store = grid.store,
			widget = grid.widget;
		if (widget.selectable) preventFocusOnTouch(e);
		parent.moveCursor(cursorIndex, {
			select:
				!isTouchEvent() && (e.shiftKey || e.ctrlKey || !widget.selection.isSelected(store, record.data, record.index)),
			selectRange: e.shiftKey,
			selectOptions: {
				toggle: e.ctrlKey && !e.shiftKey,
				add: e.ctrlKey && e.shiftKey
			},
			cellIndex: this.getCellIndex(e)
		});
		if (e.shiftKey && !isTouchEvent()) e.preventDefault();
	};

	_proto2.onMouseMove = function onMouseMove(e) {
		var _this$props3 = this.props,
			grid = _this$props3.grid,
			instance = _this$props3.instance,
			parent = _this$props3.parent,
			record = _this$props3.record;
		if (ddDetect(e) && (isDragHandleEvent(e) || instance.dragHandles.length == 0)) parent.beginDragDrop(e, record);
		if (grid.hoverSync && instance.data.hoverId != null)
			grid.hoverSync.report(grid.widget.hoverChannel, instance.data.hoverId, true);
	};

	_proto2.onMouseLeave = function onMouseLeave(e) {
		var _this$props4 = this.props,
			grid = _this$props4.grid,
			instance = _this$props4.instance;
		if (grid.hoverSync && instance.data.hoverId != null)
			grid.hoverSync.report(grid.widget.hoverChannel, instance.data.hoverId, false);
	};

	_proto2.getCellIndex = function getCellIndex(e) {
		var td = closest(e.target, function(node) {
			return node.tagName == "TD";
		});
		if (td)
			return (
				(this.props.fixed ? 0 : this.props.grid.fixedColumnCount) + Array.from(td.parentElement.children).indexOf(td)
			);
		return -1;
	};

	_proto2.onKeyDown = function onKeyDown(e) {
		var _this$props5 = this.props,
			grid = _this$props5.grid,
			instance = _this$props5.instance;

		if (e.keyCode == KeyCode.enter && grid.invoke("onRowClick", e, instance) === false) {
			e.stopPropagation();
		}
	};

	_proto2.onClick = function onClick(e) {
		var _this$props6 = this.props,
			grid = _this$props6.grid,
			record = _this$props6.record,
			instance = _this$props6.instance,
			parent = _this$props6.parent,
			cursorIndex = _this$props6.cursorIndex;
		var store = grid.store,
			widget = grid.widget;

		if (grid.widget.onRowClick) {
			if (grid.invoke("onRowClick", e, instance) === false) return;
		}

		e.stopPropagation();
		parent.moveCursor(cursorIndex, {
			select:
				isTouchEvent() || (!e.shiftKey && !e.ctrlKey && widget.selection.isSelected(store, record.data, record.index)),
			selectRange: e.shiftKey,
			selectOptions: {
				toggle: e.ctrlKey && !e.shiftKey,
				add: e.ctrlKey && e.shiftKey
			},
			cellIndex: this.getCellIndex(e)
		});
	};

	_proto2.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
		return (
			props.shouldUpdate !== false ||
			props.record != this.props.record ||
			props.cursor != this.props.cursor ||
			props.selected != this.props.selected ||
			props.isBeingDragged != this.props.isBeingDragged ||
			props.cursorIndex !== this.props.cursorIndex ||
			props.cursorCellIndex !== this.props.cursorCellIndex ||
			props.cellEdit !== this.props.cellEdit ||
			props.dimensionsVersion !== this.props.dimensionsVersion ||
			props.isDraggedOver !== this.props.isDraggedOver ||
			state !== this.state
		);
	};

	_proto2.compontentWillUnmount = function compontentWillUnmount() {
		this.unsubscribeHoverSync && this.unsubscribeHoverSync();
	};

	_proto2.componentDidMount = function componentDidMount() {
		var _this2 = this;

		var grid = this.props.grid;

		if (grid.hoverSync) {
			this.unsubscribeHoverSync = grid.hoverSync.subscribe(grid.widget.hoverChannel, function(hoverId) {
				var hover = hoverId === _this2.props.instance.data.hoverId;
				if (!_this2.state || hover !== _this2.state.hover)
					_this2.setState({
						hover: hover
					});
			});
		}
	};

	return GridRowComponent;
})(VDOM.Component);

var GridCellEditor = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(GridCellEditor, _Container);

	function GridCellEditor() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = GridCellEditor.prototype;

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			GridCellEditorCmp,
			{
				className: data.className,
				style: data.style,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	return GridCellEditor;
})(Container);
GridCellEditor.prototype.styled = true;

var GridCellEditorCmp = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(GridCellEditorCmp, _VDOM$Component);

	function GridCellEditorCmp() {
		return _VDOM$Component.apply(this, arguments) || this;
	}

	var _proto2 = GridCellEditorCmp.prototype;

	_proto2.render = function render() {
		var _this = this;

		var _this$props = this.props,
			className = _this$props.className,
			style = _this$props.style,
			children = _this$props.children;
		return /*#__PURE__*/ jsx("div", {
			ref: function ref(el) {
				return (_this.el = el);
			},
			className: className,
			style: style,
			children: children
		});
	};

	_proto2.componentDidMount = function componentDidMount() {
		if (!isFocusedDeep(this.el)) {
			var focusableChild = findFirstChild(this.el, isFocusable);
			if (focusableChild) focusableChild.focus();
		}
	};

	return GridCellEditorCmp;
})(VDOM.Component);

var Grid = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(Grid, _Widget);

	function Grid() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = Grid.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		var selection = this.selection.configureWidget(this);

		for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[this].concat(args, [
				{
					records: undefined,
					sorters: undefined,
					preSorters: undefined,
					scrollable: undefined,
					sortField: undefined,
					sortDirection: undefined,
					emptyText: undefined,
					dragSource: {
						structured: true
					},
					dropZone: {
						structured: true
					},
					filterParams: {
						structured: true
					},
					groupingParams: {
						structured: true
					},
					scrollResetParams: {
						structured: true
					},
					page: undefined,
					totalRecordCount: undefined,
					tabIndex: undefined,
					columnParams: {
						structured: true
					}
				},
				selection
			])
		);
	};

	_proto.init = function init() {
		if (this.recordAlias) this.recordName = this.recordAlias;
		if (this.indexAlias) this.indexName = this.indexAlias;

		if (this.infinite) {
			this.buffered = true;
			this.remoteSort = true;
		}

		if (this.buffered) this.scrollable = true;

		if (!this.scrollable) {
			this.fixedFooter = false; //unsupported combination
		}

		this.recordsAccessor = getAccessor(this.records);
		this.selection = Selection.create(this.selection, {
			records: this.records
		});
		if (!this.selection.isDummy || this.onRowClick || this.onRowDoubleClick) this.selectable = true;
		if (this.focusable == null) this.focusable = !this.selection.isDummy || this.cellEditable;

		_Widget.prototype.init.call(this);
	};

	_proto.initState = function initState(context, instance) {
		instance.state = {
			colWidth: {},
			lockedColWidth: {},
			dimensionsVersion: 0
		};
		instance.v = 0;
		if (this.infinite)
			instance.buffer = {
				records: [],
				totalRecordCount: 0,
				page: 1
			};
	};

	_proto.createRowTemplate = function createRowTemplate(context, columnParams, instance, groupingData) {
		var _this = this;

		var row = this.row || {};
		var columns = this.columns;

		if (this.onGetColumns) {
			var result = instance.invoke("onGetColumns", columnParams, instance);
			if (isArray(result)) columns = result;
			else row = result;
		}

		if (columns)
			row.line1 = {
				columns: columns
			};
		row.hasSortableColumns = false;
		row.hasResizableColumns = false;
		var aggregates = {};
		var lines = [];

		for (var i = 0; i < 10; i++) {
			var l = row["line" + i];

			if (l) {
				if (isArray(l.columns))
					for (var c = 0; c < l.columns.length; c++) {
						l.columns[c].uniqueColumnId = "l" + i + "-" + (l.columns[c].key || c);
					}
				lines.push(l);
			}
		}

		row.header = PureContainer.create({
			items: GridColumnHeaderLine.create(lines)
		});
		row.header.items.forEach(function(line) {
			line.items.forEach(function(c) {
				if (c.sortable) row.hasSortableColumns = true;
				if (
					c.resizable ||
					(c.header && c.header.resizable) ||
					(c.header1 && c.header1.resizable) ||
					(c.header2 && c.header2.resizable) ||
					(c.header3 && c.header3.resizable)
				)
					row.hasResizableColumns = true;

				if (c.aggregate && (c.aggregateField || isDefined(c.aggregateValue))) {
					aggregates[c.aggregateAlias] = {
						value: isDefined(c.aggregateValue)
							? c.aggregateValue
							: isDefined(c.value)
							? c.value
							: c.aggregateField
							? {
									bind: _this.recordName + "." + c.aggregateField
							  }
							: null,
						weight:
							c.weight != null
								? c.weight
								: c.weightField && {
										bind: _this.recordName + "." + c.weightField
								  },
						type: c.aggregate
					};
				}
			});
		}); //add default footer if some columns have aggregates and grouping is not defined

		if (!groupingData && (Object.keys(aggregates).length > 0 || this.fixedFooter))
			groupingData = [
				{
					key: {},
					showFooter: true
				}
			];

		var _this$resolveGrouping = this.resolveGrouping(groupingData),
			grouping = _this$resolveGrouping.grouping,
			showHeader = _this$resolveGrouping.showHeader;

		this.showHeader = showHeader;

		if (this.fixedFooter && isNonEmptyArray(grouping)) {
			grouping[0].showFooter = true;
			if (grouping[0].key && Object.keys(grouping[0].key).length > 0)
				Console.warn(
					"First grouping level in grids with a fixed footer must group all data. The key field should be omitted."
				);
		}

		instance.dataAdapter = DataAdapter.create(
			{
				type: (this.dataAdapter && this.dataAdapter.type) || GroupAdapter,
				recordsAccessor: this.recordsAccessor,
				keyField: this.keyField,
				aggregates: aggregates,
				recordName: this.recordName,
				indexName: this.indexName,
				sortOptions: this.sortOptions,
				groupings: grouping
			},
			this.dataAdapter
		);
		instance.dataAdapter.initInstance(context, instance);
		return Widget.create(
			GridRow,
			_objectSpread2(
				{
					class: this.CSS.element(this.baseClass, "data"),
					className: this.rowClass,
					style: this.rowStyle,
					recordName: this.recordName,
					hoverId: this.rowHoverId
				},
				row
			)
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var _data$stateMods;

		var data = instance.data,
			state = instance.state,
			cached = instance.cached,
			row = instance.row;
		var grouping = this.grouping;

		if (this.onGetGrouping) {
			if (!cached.data || cached.data.groupingParams !== data.groupingParams)
				grouping = instance.invoke("onGetGrouping", data.groupingParams, instance);
			else grouping = cached.grouping;
		}

		var groupingChanged = instance.cache("grouping", grouping);

		if (instance.cache("columnParams", data.columnParams) || groupingChanged || !row) {
			row = instance.row = this.createRowTemplate(context, data.columnParams, instance, grouping);
		}

		data.version = ++instance.v;
		if (!this.infinite) data.totalRecordCount = isArray(data.records) ? data.records.length : 0;
		else {
			if (isNumber(data.totalRecordCount)) instance.buffer.totalRecordCount = data.totalRecordCount;
			else data.totalRecordCount = instance.buffer.totalRecordCount;
			if (isDefined(data.records)) instance.buffer.records = data.records;
			else data.records = instance.buffer.records;
			if (isNumber(data.page)) instance.buffer.page = data.page;
			else data.page = instance.buffer.page;
			data.offset = (data.page - 1) * this.pageSize;
		}
		if (!isArray(data.records)) data.records = [];
		if (state.sorters && !isDefined(this.sorters)) data.sorters = state.sorters;
		var sortField = null;

		if (isDefined(this.sortField) && isDefined(this.sortDirection)) {
			var sorter = {
				field: data.sortField,
				direction: data.sortDirection
			};
			sortField = data.sortField;
			data.sorters = [sorter];
		}

		if (!isNonEmptyArray(data.sorters) && this.defaultSortField) {
			var _sorter = {
				field: this.defaultSortField,
				direction: this.defaultSortDirection || "ASC"
			};
			sortField = this.defaultSortField;
			data.sorters = [_sorter];
		}

		if (sortField) {
			for (var l = 1; l < 10; l++) {
				var line = instance.row["line" + l];
				var sortColumn =
					line &&
					line.columns &&
					line.columns.find(function(c) {
						return c.field == sortField;
					});

				if (sortColumn) {
					data.sorters[0].value = sortColumn.sortValue || sortColumn.value;
					data.sorters[0].comparer = sortColumn.comparer;
					data.sorters[0].sortOptions = sortColumn.sortOptions;
					break;
				}
			}
		}

		var headerMode = this.headerMode;

		if (this.headerMode == null) {
			if (this.scrollable || row.hasSortableColumns || row.hasResizableColumns) headerMode = "default";
			else headerMode = "plain";
		}

		var border = this.border;
		if (this.showBorder || (border == null && this.scrollable)) border = true;
		var dragMode = false;
		if (data.dragSource) dragMode = data.dragSource.mode || "move";
		var dropMode = data.dropZone && data.dropZone.mode;
		if (this.onDrop && !dropMode) dropMode = "preview";
		data.dropMode = dropMode;
		data.stateMods =
			((_data$stateMods = {
				selectable: this.selectable,
				"cell-editable": this.cellEditable,
				scrollable: data.scrollable,
				buffered: this.buffered
			}),
			(_data$stateMods["header-" + headerMode] = true),
			(_data$stateMods.border = border),
			(_data$stateMods.vlines = this.vlines),
			(_data$stateMods["drag-" + dragMode] = dragMode),
			(_data$stateMods["drop-" + dropMode] = dropMode),
			(_data$stateMods.resizable = row.hasResizableColumns),
			_data$stateMods);

		_Widget.prototype.prepareData.call(this, context, instance);

		instance.records = this.mapRecords(context, instance); //tree adapters can have additional (child) records, filtering also affects actual record count

		if (instance.records && !this.infinite) {
			//apply record count after filtering
			data.totalRecordCount = instance.records.length; //recheck if there are any actual records
			//when grouping is enabled group header/footer are always in

			if (instance.records.length < 5) {
				data.empty = true;

				for (var i = 0; i < instance.records.length; i++) {
					if (instance.records[i].type == "data") {
						data.empty = false;
						break;
					}
				}
			} else data.empty = data.totalRecordCount == 0;
		} else data.empty = data.totalRecordCount == 0;

		if (this.onCreateIsRecordSelectable) {
			instance.isRecordSelectable = instance.invoke("onCreateIsRecordSelectable", null, instance);
		}
	};

	_proto.initInstance = function initInstance(context, instance) {
		instance.fixedHeaderResizeEvent = new SubscriberList();

		_Widget.prototype.initInstance.call(this, context, instance);
	};

	_proto.explore = function explore(context, instance) {
		context.push("parentPositionChangeEvent", instance.fixedHeaderResizeEvent);
		instance.hoverSync = context.hoverSync;

		_Widget.prototype.explore.call(this, context, instance);

		instance.header = instance.getChild(context, instance.row.header, "header");
		instance.header.scheduleExploreIfVisible(context);
		var store = instance.store;
		instance.isSelected = this.selection.getIsSelectedDelegate(store); //do not process rows in buffered mode or cached mode if nothing has changed;

		if (!this.buffered && (!this.cached || instance.shouldUpdate)) {
			for (var i = 0; i < instance.records.length; i++) {
				var record = instance.records[i];

				if (record.type == "data") {
					var row = (record.row = instance.getChild(context, instance.row, record.key, record.store));
					row.selected = instance.isSelected(record.data, record.index);
					var changed = false;
					if (row.cache("selected", row.selected)) changed = true;
					if (row.cache("recordData", record.data)) changed = true;
					if (this.cached && !changed && !row.childStateDirty) row.shouldUpdate = false;
					else row.scheduleExploreIfVisible(context);
				}
			}
		}
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("parentPositionChangeEvent");
		var fixedColumnCount = 0,
			visibleColumns = [];
		instance.header.children.forEach(function(line) {
			line.children.forEach(function(col) {
				if (col.data.fixed) fixedColumnCount++;
				visibleColumns.push(col.widget);
			});
		});
		instance.visibleColumns = visibleColumns;
		instance.hasFixedColumns = fixedColumnCount > 0;
		instance.fixedColumnCount = fixedColumnCount;

		if (fixedColumnCount > 0) {
			instance.data.classNames += " " + instance.widget.CSS.state("fixed-columns");
		}
	};

	_proto.resolveGrouping = function resolveGrouping(grouping) {
		var _this2 = this;

		if (grouping) {
			if (!isArray(grouping)) {
				if (isString(grouping) || isObject(grouping)) grouping = [grouping];
				else throw new Error("Dynamic grouping should be an array of grouping objects.");
			}

			grouping = grouping.map(function(g, i) {
				var _key2;

				var group;
				if (isString(g))
					group = {
						key:
							((_key2 = {}),
							(_key2[g] = {
								bind: _this2.recordName + "." + g
							}),
							_key2),
						showHeader: !_this2.scrollable && i == grouping.length - 1,
						showFooter: true,
						caption: {
							bind: "$group." + g
						},
						text: {
							bind: _this2.recordName + "." + g
						}
					};
				else group = _objectSpread2({}, g);
				if (group.caption) group.caption = getSelector(group.caption);
				return group;
			});
		}

		var showHeader =
			!isArray(grouping) ||
			!grouping.some(function(g) {
				return g.showHeader;
			});
		return {
			showHeader: showHeader,
			grouping: grouping
		};
	};

	_proto.groupBy = function groupBy(groupingData, options) {
		var _this$resolveGrouping2 = this.resolveGrouping(groupingData),
			grouping = _this$resolveGrouping2.grouping,
			showHeader = _this$resolveGrouping2.showHeader;

		this.grouping = grouping;
		if (options != null && options.autoConfigure) this.showHeader = showHeader;
		this.update();
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data,
			hasFixedColumns = instance.hasFixedColumns;
		var fixedHeader = data.scrollable && this.showHeader && this.renderHeader(context, instance, "header", true, false);
		var fixedColumnsFixedHeader =
			data.scrollable &&
			this.showHeader &&
			hasFixedColumns &&
			this.renderHeader(context, instance, "header", true, true);
		if (!this.buffered) this.renderRows(context, instance);
		if (this.fixedFooter) this.renderFixedFooter(context, instance);
		var header = this.showHeader && this.renderHeader(context, instance, "header", false, false);
		var fixedColumnsHeader =
			this.showHeader && hasFixedColumns && this.renderHeader(context, instance, "header", false, true);
		return /*#__PURE__*/ jsx(
			GridComponent,
			{
				instance: instance,
				data: instance.data,
				shouldUpdate: instance.shouldUpdate,
				header: header,
				fixedColumnsHeader: fixedColumnsHeader,
				fixedColumnsFixedHeader: fixedColumnsFixedHeader,
				fixedHeader: fixedHeader,
				fixedFooter: instance.fixedFooterVDOM,
				fixedColumnsFixedFooter: instance.fixedColumnsFixedFooterVDOM
			},
			key
		);
	};

	_proto.renderHeader = function renderHeader(context, instance, key, fixed, fixedColumns) {
		var _this3 = this;

		var data = instance.data,
			widget = instance.widget,
			header = instance.header;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var headerRows = [];
		if (!header) return null;
		var skip = {};
		header.children.forEach(function(line, lineIndex) {
			var empty = [true, true, true];
			var result = [[], [], []];
			line.children.forEach(function(hdinst, colIndex) {
				var hdwidget = hdinst.widget;

				var _loop = function _loop(l) {
					var colKey = lineIndex + "-" + colIndex + "-" + l;
					if (skip[colKey]) return "continue";
					if (Boolean(hdinst.data.fixed) != fixedColumns) return "continue";
					var header = hdinst.components["header" + (l + 1)];
					var colSpan = void 0,
						rowSpan = void 0,
						style = void 0,
						cls = void 0,
						mods = [],
						content = void 0,
						sortIcon = void 0,
						tool = void 0;
					var resizer = null;

					if (header) {
						empty[l] = false;
						if (header.widget.align) mods.push("aligned-" + header.widget.align);
						else if (hdwidget.align) mods.push("aligned-" + hdwidget.align);

						if (hdwidget.sortable && header.widget.allowSorting) {
							mods.push("sortable");

							if (data.sorters && data.sorters[0].field == (hdwidget.sortField || hdwidget.field)) {
								mods.push("sorted-" + data.sorters[0].direction.toLowerCase());
								sortIcon = /*#__PURE__*/ jsx(DropDownIcon, {
									className: CSS.element(baseClass, "column-sort-icon")
								});
							}
						}

						style = header.data.style;
						var customWidth =
							header.data.width ||
							instance.state.colWidth[hdwidget.uniqueColumnId] ||
							header.data.defaultWidth ||
							instance.state.lockedColWidth[hdwidget.uniqueColumnId];

						if (customWidth) {
							if (instance.state.colWidth[hdwidget.uniqueColumnId] != customWidth)
								instance.state.colWidth[hdwidget.uniqueColumnId] = customWidth;
							var s = customWidth + "px";
							style = _objectSpread2(
								_objectSpread2({}, style),
								{},
								{
									width: s,
									minWidth: s,
									maxWidth: s
								}
							);
						}

						if (header.data.classNames) cls = header.data.classNames;
						content = header.render(context);

						if (header.components && header.components.tool) {
							tool = /*#__PURE__*/ jsx("div", {
								className: CSS.element(baseClass, "col-header-tool"),
								children: getContent(header.components.tool.render(context))
							});
							mods.push("tool");
						}

						if (header.data.colSpan > 1 || header.data.rowSpan > 1) {
							colSpan = header.data.colSpan;
							rowSpan = header.data.rowSpan;

							for (var r = 0; r < header.data.rowSpan; r++) {
								for (var c = 0; c < header.data.colSpan; c++) {
									skip[lineIndex + "-" + (colIndex + c) + "-" + (l + r)] = true;
								}
							}
						}

						if ((hdwidget.resizable || header.data.resizable) && header.data.colSpan < 2) {
							resizer = /*#__PURE__*/ jsx("div", {
								className: CSS.element(baseClass, "col-resizer"),
								onClick: function onClick(e) {
									e.stopPropagation();
								},
								onMouseDown: function onMouseDown(e) {
									if (e.buttons != 1) return;
									var resizeOverlayEl = document.createElement("div");
									var headerCell = e.target.parentElement;
									var scrollAreaEl = headerCell.parentElement.parentElement.parentElement.parentElement;
									var gridEl = scrollAreaEl.parentElement;
									var initialWidth = headerCell.offsetWidth;
									var initialPosition = getCursorPos(e);
									resizeOverlayEl.className = CSS.element(baseClass, "resize-overlay");
									resizeOverlayEl.style.width = initialWidth + "px";
									resizeOverlayEl.style.left =
										headerCell.getBoundingClientRect().left - gridEl.getBoundingClientRect().left + "px";
									gridEl.appendChild(resizeOverlayEl);
									captureMouse2(e, {
										onMouseMove: function onMouseMove(e) {
											var cursor = getCursorPos(e);
											var width = Math.max(30, Math.round(initialWidth + cursor.clientX - initialPosition.clientX));
											resizeOverlayEl.style.width = width + "px";
										},
										onMouseUp: function onMouseUp(e) {
											var _objectSpread2$1;

											if (!resizeOverlayEl) return; //dblclick

											var width = resizeOverlayEl.offsetWidth;
											hdinst.assignedWidth = width;
											gridEl.removeChild(resizeOverlayEl);
											resizeOverlayEl = null;
											if (widget.onColumnResize)
												instance.invoke(
													"onColumnResize",
													{
														width: width,
														column: hdwidget
													},
													hdinst
												);
											header.set("width", width);
											instance.setState({
												dimensionsVersion: instance.state.dimensionsVersion + 1,
												colWidth: _objectSpread2(
													_objectSpread2({}, instance.state.colWidth),
													{},
													((_objectSpread2$1 = {}),
													(_objectSpread2$1[hdwidget.uniqueColumnId] = width),
													_objectSpread2$1)
												)
											});
										},
										onDblClick: function onDblClick() {
											var _objectSpread3;

											var table = gridEl.querySelector("table");
											var parentEl = table.parentElement;
											var tableClone = table.cloneNode(true);
											tableClone.childNodes.forEach(function(tbody) {
												tbody.childNodes.forEach(function(tr) {
													tr.childNodes.forEach(function(td, index) {
														if (index == colIndex) {
															td.style.maxWidth = null;
															td.style.minWidth = null;
															td.style.width = "auto";
														} else {
															td.style.display = "none";
														}
													});
												});
											});
											tableClone.style.position = "absolute";
											tableClone.style.visibility = "hidden";
											tableClone.style.top = 0;
											tableClone.style.left = 0;
											tableClone.style.width = "auto";
											parentEl.appendChild(tableClone);
											var width = tableClone.offsetWidth;
											parentEl.removeChild(tableClone);
											header.set("width", width);
											instance.setState({
												dimensionsVersion: instance.state.dimensionsVersion + 1,
												colWidth: _objectSpread2(
													_objectSpread2({}, instance.state.colWidth),
													{},
													((_objectSpread3 = {}), (_objectSpread3[hdwidget.uniqueColumnId] = width), _objectSpread3)
												)
											});
										}
									});
								}
							});
						}
					}

					cls = CSS.element(baseClass, "col-header", mods) + (cls ? " " + cls : "");
					var onContextMenu = void 0;
					if (_this3.onColumnContextMenu)
						onContextMenu = function onContextMenu(e) {
							return instance.invoke("onColumnContextMenu", e, hdinst);
						};
					result[l].push(
						/*#__PURE__*/ jsxs(
							"th",
							{
								colSpan: colSpan,
								rowSpan: rowSpan,
								className: cls,
								style: style,
								onMouseDown: ddMouseDown,
								onMouseMove: function onMouseMove(e) {
									return _this3.onHeaderMouseMove(e, hdwidget, hdinst, instance, l);
								},
								onClick: function onClick(e) {
									return _this3.onHeaderClick(e, hdwidget, instance, l);
								},
								onContextMenu: onContextMenu,
								"data-unique-col-id": hdwidget.uniqueColumnId,
								children: [getContent(content), sortIcon, tool, resizer]
							},
							colIndex
						)
					);
				};

				for (var l = 0; l < 3; l++) {
					var _ret = _loop(l);

					if (_ret === "continue") continue;
				}
			});
			result = result.filter(function(_, i) {
				return !empty[i];
			});

			if (result[0]) {
				if (fixed && !fixedColumns) {
					result[0].push(
						/*#__PURE__*/ jsx(
							"th",
							{
								rowSpan: result.length,
								className: CSS.element(baseClass, "col-header")
							},
							"dummy"
						)
					);
				}

				headerRows.push(
					/*#__PURE__*/ jsx(
						"tbody",
						{
							className: CSS.element(baseClass, "header"),
							children: result.map(function(h, i) {
								return /*#__PURE__*/ jsx(
									"tr",
									{
										children: h
									},
									i
								);
							})
						},
						"h" + key + lineIndex
					)
				);
			}
		});
		if (headerRows.length == 0) return null;
		return headerRows;
	};

	_proto.onHeaderMouseMove = function onHeaderMouseMove(e, column, columnInstance, gridInstance, headerLine) {
		var _gridInstance$widget = gridInstance.widget,
			baseClass = _gridInstance$widget.baseClass,
			CSS = _gridInstance$widget.CSS;
		if (columnInstance.data.fixed) return;
		var headerInstance = columnInstance.components["header" + (headerLine + 1)];
		if (!headerInstance) return;
		var store = headerInstance.store,
			data = headerInstance.data;

		if (data.draggable && !data.fixed && ddDetect(e) && e.buttons == 1) {
			initiateDragDrop(
				e,
				{
					sourceEl: e.currentTarget,
					source: {
						type: "grid-column",
						store: store,
						column: column,
						columnInstance: columnInstance,
						headerInstance: headerInstance,
						gridInstance: gridInstance,
						headerLine: headerLine
					},
					clone: {
						store: store,
						matchCursorOffset: true,
						matchWidth: true,
						widget: function widget() {
							return /*#__PURE__*/ jsx("div", {
								className: CSS.element(baseClass, "col-header-drag-clone"),
								children: data.text
							});
						}
					}
				},
				function() {}
			);
		}
	};

	_proto.onHeaderClick = function onHeaderClick(e, column, instance, headerLine) {
		e.preventDefault();
		e.stopPropagation();
		var data = instance.data;
		var header = column.components["header" + (headerLine + 1)];
		var field = column.sortField || column.field;
		var value = column.sortValue || column.value;
		var compare = column.compare;
		var sortOptions = column.sortOptions;

		if (header && header.allowSorting && column.sortable && (field || value)) {
			var direction = "ASC";

			if (data.sorters && (data.sorters[0].field == (field || data.sortField) || data.sorters[0].value == value)) {
				if (data.sorters[0].direction == "ASC") direction = "DESC";
				else if (this.clearableSort && data.sorters[0].direction == "DESC") direction = null;
			}

			var sorters = direction
				? [
						{
							field: field,
							direction: direction,
							value: value,
							compare: compare,
							sortOptions: sortOptions
						}
				  ]
				: null;
			instance.set("sorters", sorters);
			instance.set("sortField", field);
			instance.set("sortDirection", direction);
			if (!this.remoteSort || this.infinite)
				instance.setState({
					sorters: sorters
				});
		}
	};

	_proto.renderGroupHeader = function renderGroupHeader(context, instance, g, level, group, i, store, fixedColumns) {
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var data = store.getData();

		if (g.caption) {
			var caption = g.caption(data);
			return /*#__PURE__*/ jsx(
				"tbody",
				{
					className: CSS.element(baseClass, "group-caption", ["level-" + level]),
					"data-group-key": group.$key,
					"data-group-element": "group-caption-" + level,
					children: /*#__PURE__*/ jsx("tr", {
						children: /*#__PURE__*/ jsx("td", {
							colSpan: 1000,
							children: caption
						})
					})
				},
				"g-" + level + "-" + group.$key
			);
		} else if (g.showCaption) {
			var skip = 0;
			var header = instance.header;
			var lines = [];
			header.children.forEach(function(line, lineIndex) {
				var empty = true;
				var cells = line.children.map(function(ci, i) {
					if (--skip >= 0) return null;
					if (Boolean(ci.data.fixed) != fixedColumns) return null;
					var v,
						c = ci.widget,
						colSpan,
						pad;

					if (c.caption) {
						if (c.caption.children)
							v = /*#__PURE__*/ jsx(Cx, {
								widget: c.caption.children,
								store: store,
								parentInstance: instance,
								subscribe: true
							});
						else v = c.caption.value(data);
						pad = c.caption.pad;
						colSpan = c.caption.colSpan;
						empty = false;

						if (c.caption.expand) {
							colSpan = 1;

							for (
								var ind = i + 1;
								ind < line.children.length &&
								!line.children[ind].widget.caption &&
								!line.children[ind].widget.aggregate;
								ind++
							) {
								colSpan++;
							}
						}

						if (colSpan > 1) skip = colSpan - 1;
					} else if (c.aggregate && c.aggregateField && c.caption !== false) {
						empty = false;
						v = group[c.aggregateField];
						if (isString(ci.data.format)) v = Format.value(v, ci.data.format);
					}

					var cls = "";
					if (c.align) cls += CSS.state("aligned-" + c.align);
					if (pad !== false) cls += (cls ? " " : "") + CSS.state("pad");
					return /*#__PURE__*/ jsx(
						"td",
						{
							className: cls,
							colSpan: colSpan,
							children: v
						},
						i
					);
				});
				if (empty) return;
				lines.push(
					/*#__PURE__*/ jsx(
						"tr",
						{
							children: cells
						},
						lineIndex
					)
				);
			});
			if (lines.length == 0) return null;
			return /*#__PURE__*/ jsx(
				"tbody",
				{
					className: CSS.element(baseClass, "group-caption", ["level-" + level]),
					"data-group-key": group.$key,
					"data-group-element": "group-caption-" + level,
					children: lines
				},
				"c" + group.$key
			);
		}
	};

	_proto.renderGroupFooter = function renderGroupFooter(
		context,
		instance,
		g,
		level,
		group,
		i,
		store,
		fixed,
		fixedColumns
	) {
		var CSS = this.CSS,
			baseClass = this.baseClass;
		var data = store.getData();
		var skip = 0;
		var header = instance.header,
			dataAdapter = instance.dataAdapter;
		var rowStyle = {}; //hide the last group footer if fixedFooter is used
		//but leave it rendered for column size calculation

		if (this.fixedFooter && !fixed && isArray(dataAdapter.groupings) && level == dataAdapter.groupings.length)
			rowStyle.visibility = "hidden";
		var lines = [];
		header.children.forEach(function(line, lineIndex) {
			var empty = true;
			var cells = line.children.map(function(ci, i) {
				if (--skip >= 0) return null;
				if (Boolean(ci.data.fixed) != fixedColumns) return null;
				var v,
					c = ci.widget,
					colSpan,
					pad,
					cls = "",
					style = null;

				if (c.footer) {
					v = c.footer.value(data);
					var fmt = c.footer.format(data);
					if (fmt) v = Format.value(v, fmt);
					pad = c.footer.pad;
					colSpan = c.footer.colSpan;
					empty = false;
					cls = CSS.expand(c.footer["class"](data)) || "";
					style = parseStyle$1(c.footer.style(data));

					if (c.footer.expand) {
						colSpan = 1;

						for (
							var ind = i + 1;
							ind < line.children.length && !line.children[ind].widget.footer && !line.children[ind].widget.aggregate;
							ind++
						) {
							colSpan++;
						}
					}

					if (colSpan > 1) skip = colSpan - 1;
				} else if (c.aggregate && c.aggregateField && c.footer !== false) {
					empty = false;
					v = group[c.aggregateField];
					if (isString(ci.data.format)) v = Format.value(v, ci.data.format);
				}

				if (cls) cls += " ";
				if (c.align) cls += CSS.state("aligned-" + c.align);
				if (pad !== false) cls += (cls ? " " : "") + CSS.state("pad");
				return /*#__PURE__*/ jsx(
					"td",
					{
						className: cls,
						colSpan: colSpan,
						style: style,
						children: v
					},
					i
				);
			});
			if (empty) return;
			if (fixed && !fixedColumns)
				cells.push(
					/*#__PURE__*/ jsx(
						"td",
						{
							className: CSS.element(baseClass, "fixed-footer-corner")
						},
						"dummy"
					)
				);
			lines.push(
				/*#__PURE__*/ jsx(
					"tr",
					{
						children: cells
					},
					lineIndex
				)
			);
		});
		if (lines.length == 0) return null;
		return /*#__PURE__*/ jsx(
			"tbody",
			{
				style: rowStyle,
				className: CSS.element(baseClass, "group-footer", ["level-" + level]),
				"data-group-key": group.$key,
				"data-group-element": "group-footer-" + level,
				children: lines
			},
			"f" + i
		);
	};

	_proto.renderRows = function renderRows(context, instance) {
		var records = instance.records,
			hasFixedColumns = instance.hasFixedColumns;
		if (!isArray(records)) return null;
		var record, g;

		for (var i = 0; i < records.length; i++) {
			record = records[i];

			if (record.type == "data") {
				record.vdom = record.row.render(context, record.key);
			}

			if (record.type == "group-header") {
				record.vdom = [];
				record.fixedVdom = [];
				g = record.grouping;
				if (g.caption || g.showCaption)
					record.vdom.push(
						this.renderGroupHeader(
							context,
							instance,
							g,
							record.level,
							record.group,
							record.key + "-caption",
							record.store,
							false
						)
					);
				if (hasFixedColumns)
					record.fixedVdom.push(
						this.renderGroupHeader(
							context,
							instance,
							g,
							record.level,
							record.group,
							record.key + "-caption",
							record.store,
							true
						)
					);

				if (g.showHeader) {
					record.vdom.push(this.renderHeader(context, instance, record.key + "-header", false, false));
					if (hasFixedColumns)
						record.fixedVdom.push(this.renderHeader(context, instance, record.key + "-header", false, true));
				}
			}

			if (record.type == "group-footer") {
				g = record.grouping;

				if (g.showFooter) {
					record.vdom = this.renderGroupFooter(
						context,
						instance,
						g,
						record.level,
						record.group,
						record.key + "-footer",
						record.store,
						false,
						false
					);
					if (hasFixedColumns)
						record.fixedVdom = this.renderGroupFooter(
							context,
							instance,
							g,
							record.level,
							record.group,
							record.key + "-footer",
							record.store,
							false,
							true
						);
				}
			}
		}
	};

	_proto.renderFixedFooter = function renderFixedFooter(context, instance) {
		var records = instance.records,
			hasFixedColumns = instance.hasFixedColumns,
			data = instance.data;
		instance.fixedFooterVDOM = null;
		instance.fixedColumnsFixedFooterVDOM = null;
		if (data.empty || !isNonEmptyArray(records)) return; //all type of records are allowed here because the footer can be based on pre-computed data
		//it doesn't make sense to show the footer if the grid is empty though

		var record = records[records.length - 1];
		instance.fixedFooterOverlap = record.type == "group-footer";
		instance.fixedFooterVDOM = this.renderGroupFooter(
			context,
			instance,
			record.grouping,
			record.level,
			record.group || {
				$key: "fixed-footer"
			},
			record.key + "-footer",
			record.store,
			true,
			false
		);
		if (hasFixedColumns)
			instance.fixedColumnsFixedFooterVDOM = this.renderGroupFooter(
				context,
				instance,
				record.grouping,
				record.level,
				record.group || {
					$key: "fixed-footer"
				},
				record.key + "-footer",
				record.store,
				true,
				true
			);
	};

	_proto.mapRecords = function mapRecords(context, instance) {
		var data = instance.data,
			store = instance.store,
			dataAdapter = instance.dataAdapter;
		var filter = null;
		if (this.onCreateFilter) filter = instance.invoke("onCreateFilter", data.filterParams, instance);
		var sorters = !this.remoteSort && data.sorters; //apply pre-sorters only if some sorting is applied

		if (isNonEmptyArray(data.sorters) && isNonEmptyArray(data.preSorters)) {
			sorters = [].concat(data.preSorters, data.sorters);
		}

		dataAdapter.setFilter(filter);
		dataAdapter.sort(sorters); //if no filtering or sorting applied, let the component maps records on demand

		if (
			this.buffered &&
			!this.fixedFooter &&
			!filter &&
			!isNonEmptyArray(sorters) &&
			!dataAdapter.isTreeAdapter &&
			!instance.dataAdapter.groupings
		)
			return null;
		return dataAdapter.getRecords(context, instance, data.records, store);
	};

	_proto.mapRecord = function mapRecord(context, instance, data, index) {
		return instance.dataAdapter.mapRecord(context, instance, data, instance.store, this.recordsAccessor, index);
	};

	return Grid;
})(Widget);
Grid.prototype.baseClass = "grid";
Grid.prototype.showHeader = true;
Grid.prototype.showFooter = false;
Grid.prototype.recordName = "$record";
Grid.prototype.indexName = "$index";
Grid.prototype.remoteSort = false;
Grid.prototype.lockColumnWidths = false;
Grid.prototype.lockColumnWidthsRequiredRowCount = 3;
Grid.prototype.focused = false;
Grid.prototype.emptyText = false;
Grid.prototype.showBorder = false; // show border override for material theme

Grid.prototype.cached = false;
Grid.prototype.buffered = false;
Grid.prototype.bufferStep = 15;
Grid.prototype.bufferSize = 60;
Grid.prototype.pageSize = 100;
Grid.prototype.infinite = false;
Grid.prototype.styled = true;
Grid.prototype.scrollSelectionIntoView = false;
Grid.prototype.clearableSort = false;
Grid.prototype.cellEditable = false;
Grid.prototype.preciseMeasurements = false;
Grid.prototype.hoverChannel = "default";
Grid.prototype.focusable = null; // automatically resolved

Widget.alias("grid", Grid);
Localization.registerPrototype("cx/widgets/Grid", Grid);

var GridComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(GridComponent, _VDOM$Component);

	function GridComponent(props) {
		var _this4;

		_this4 = _VDOM$Component.call(this, props) || this;
		_this4.dom = {};
		var widget = props.instance.widget;
		var end = Math.min(widget.bufferSize, props.data.totalRecordCount);
		_this4.state = {
			cursor: widget.focused && widget.selectable ? 0 : -1,
			cursorCellIndex: 0,
			focused: widget.focused,
			dropInsertionIndex: null,
			start: 0,
			end: end
		};
		_this4.syncBuffering = false;

		if (widget.infinite) {
			_this4.start = 0;
			_this4.end = end;
			_this4.loadingStartPage = 0;
			_this4.loadingEndPage = 0;
		}

		_this4.scrollerRef = function(el) {
			_this4.dom.scroller = el;
		};

		_this4.fixedScrollerRef = function(el) {
			_this4.dom.fixedScroller = el;
		};

		_this4.gridRef = function(el) {
			_this4.dom.el = el;
		};

		return _this4;
	}

	var _proto2 = GridComponent.prototype;

	_proto2.getBufferStartEnd = function getBufferStartEnd() {
		//{start, end};
		return this.syncBuffering ? this : this.state;
	};

	_proto2.renderCellEditor = function renderCellEditor(key, CSS, baseClass, instance, column) {
		var _this5 = this;

		//add an inner div with fixed height in order to help IE absolutely position the contents inside
		return /*#__PURE__*/ jsx(
			"td",
			{
				className: CSS.element(baseClass, "cell-editor"),
				children: /*#__PURE__*/ jsx(Cx, {
					parentInstance: instance,
					subscribe: true,
					items: [
						{
							$type: GridCellEditor,
							className: CSS.element(baseClass, "cell-editor-wrap"),
							style:
								this.rowHeight > 0
									? {
											height: this.rowHeight + 1
									  }
									: null,
							jsxAttributes: ["className", "style"],
							children: [
								"\n                  ",
								{
									$type: ValidationGroup,
									valid: {
										get: function get() {
											return _this5.cellEditorValid;
										},
										set: function set(value) {
											_this5.cellEditorValid = value;
										}
									},
									jsxAttributes: ["valid"],
									children: ["\n                     ", column.editor, "\n                  "]
								},
								"\n               "
							]
						}
					]
				})
			},
			key
		);
	};

	_proto2.createRowRenderer = function createRowRenderer(cellWrap) {
		var _this6 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			data = _this$props.data;
		var widget = instance.widget,
			isRecordSelectable = instance.isRecordSelectable,
			visibleColumns = instance.visibleColumns;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var dragSource = data.dragSource;
		var _this$state = this.state,
			dragged = _this$state.dragged,
			cursor = _this$state.cursor,
			cursorCellIndex = _this$state.cursorCellIndex,
			cellEdit = _this$state.cellEdit,
			dropInsertionIndex = _this$state.dropInsertionIndex,
			dropTarget = _this$state.dropTarget;
		var _instance$state = instance.state,
			colWidth = _instance$state.colWidth,
			dimensionsVersion = _instance$state.dimensionsVersion;
		return function(record, index, standalone, fixed) {
			var store = record.store,
				key = record.key,
				row = record.row;
			var isDragged = dragged && (row.selected || record == dragged);
			var mod = {
				selected: row.selected,
				dragged: isDragged,
				draggable: dragSource && (!row.dragHandles || row.dragHandles.length == 0),
				cursor: widget.selectable && index == cursor,
				over: dropTarget == "row" && dropInsertionIndex === index
			};

			if (isRecordSelectable) {
				var selectable = isRecordSelectable(record.data, {});
				mod["selectable"] = selectable;
				mod["non-selectable"] = !selectable;
			}

			var wrap = function wrap(children) {
				return /*#__PURE__*/ jsx(
					GridRowComponent,
					{
						className: CSS.state(mod),
						store: store,
						dragSource: dragSource,
						instance: row,
						grid: instance,
						record: record,
						parent: _this6,
						cursorIndex: index,
						selected: row.selected,
						isBeingDragged: dragged,
						isDraggedOver: mod.over,
						cursor: mod.cursor,
						cursorCellIndex: index == cursor && cursorCellIndex,
						cellEdit: index == cursor && cursorCellIndex && cellEdit,
						shouldUpdate: row.shouldUpdate,
						dimensionsVersion: dimensionsVersion,
						fixed: fixed,
						children: children.content.map(function(_ref, line) {
							var key = _ref.key,
								data = _ref.data,
								content = _ref.content;
							return /*#__PURE__*/ jsx(
								"tr",
								{
									className: data.classNames,
									style: data.style,
									children: content.map(function(_ref2, cellIndex) {
										var key = _ref2.key,
											data = _ref2.data,
											content = _ref2.content,
											uniqueColumnId = _ref2.uniqueColumnId;
										if (Boolean(data.fixed) !== fixed) return null;
										var cellected = index == cursor && cellIndex == cursorCellIndex && widget.cellEditable && line == 0;
										var className = cellected ? CSS.expand(data.classNames, CSS.state("cellected")) : data.classNames;

										if (cellected && cellEdit) {
											var column = visibleColumns[cursorCellIndex];
											if (column && column.editor && data.editable)
												return _this6.renderCellEditor(key, CSS, baseClass, row, column);
										}

										var width = colWidth[uniqueColumnId];
										var style = data.style;

										if (width) {
											style = _objectSpread2(
												_objectSpread2({}, style),
												{},
												{
													maxWidth: width + "px"
												}
											);
										}

										if (cellWrap) content = cellWrap(content);
										return /*#__PURE__*/ jsx(
											"td",
											{
												className: className,
												style: style,
												colSpan: data.colSpan,
												rowSpan: data.rowSpan,
												children: content
											},
											key
										);
									})
								},
								key
							);
						})
					},
					key
				);
			};

			if (!standalone) return wrap(record.vdom);
			return /*#__PURE__*/ jsx(
				Cx,
				{
					instance: record.row,
					parentInstance: instance,
					options: {
						name: "grid-row"
					},
					contentFactory: function contentFactory(x) {
						return wrap({
							content: Array.isArray(x.children) ? x.children : x.children != null ? [x.children] : [],
							data: {}
						});
					},
					params: _objectSpread2(
						_objectSpread2({}, mod),
						{},
						{
							dimensionsVersion: dimensionsVersion,
							cursorIndex: index,
							data: record.data,
							cursorCellIndex: index == cursor && cursorCellIndex,
							cellEdit: index == cursor && cursorCellIndex && cellEdit
						}
					)
				},
				key
			);
		};
	};

	_proto2.render = function render() {
		var _this7 = this;

		var _this$props2 = this.props,
			instance = _this$props2.instance,
			data = _this$props2.data,
			fixedFooter = _this$props2.fixedFooter,
			fixedColumnsFixedFooter = _this$props2.fixedColumnsFixedFooter;
		var widget = instance.widget,
			hasFixedColumns = instance.hasFixedColumns;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;

		var _this$getBufferStartE = this.getBufferStartEnd(),
			start = _this$getBufferStartE.start,
			end = _this$getBufferStartE.end;

		var cellWrap = false;

		if (widget.cellEditable && (widget.hasResizableColumns || hasFixedColumns)) {
			cellWrap = function cellWrap(children) {
				return /*#__PURE__*/ jsx("div", {
					className: "cxe-grid-cell-clip",
					children: children
				});
			};
		}

		var children = [],
			fixedChildren = [];
		var renderRow = this.createRowRenderer(cellWrap);

		var addRow = function addRow(record, index, standalone) {
			children.push(renderRow(record, index, standalone, false));
			if (hasFixedColumns) fixedChildren.push(renderRow(record, index, standalone, true)); //avoid re-rendering on cursor change

			record.row.shouldUpdate = false;
		};

		if (widget.buffered) {
			var context = new RenderingContext();
			var dummyDataClass = CSS.element(baseClass, "data", {
				dummy: true
			});
			if (!instance.recordInstanceCache) instance.recordInstanceCache = new InstanceCache(instance);
			instance.recordInstanceCache.mark();
			this.getRecordsSlice(start, end).forEach(function(r, i) {
				if (r == null) {
					addRow(
						{
							key: "dummy-" + start + i,
							row: {
								data: {
									classNames: dummyDataClass
								},
								widget: instance.row
							},
							vdom: {
								content: [
									{
										key: 0,
										data: {},
										content: [
											{
												key: 0,
												data: {
													colSpan: 1000,
													style: {
														height: _this7.rowHeight + "px"
													}
												}
											}
										]
									}
								]
							}
						},
						start + i
					);
				} else {
					var record = instance.records
						? r
						: widget.mapRecord(context, instance, r, widget.infinite ? start + i - data.offset : start + i);
					var row = (record.row = instance.recordInstanceCache.getChild(instance.row, record.store, record.key));
					instance.recordInstanceCache.addChild(row);
					row.detached = true;
					row.selected = instance.isSelected(record.data, record.index);

					if (record.type == "data") {
						addRow(record, start + i, true);
					} else if (record.type == "group-header") {
						var g = record.grouping;

						if (g.caption || g.showCaption) {
							children.push(
								widget.renderGroupHeader(
									null,
									instance,
									g,
									record.level,
									record.group,
									record.key + "-caption",
									record.store,
									false
								)
							);
							if (hasFixedColumns)
								fixedChildren.push(
									widget.renderGroupHeader(
										null,
										instance,
										g,
										record.level,
										record.group,
										record.key + "-caption",
										record.store,
										true
									)
								);
						}
					} else if (record.type == "group-footer") {
						var _g = record.grouping;

						if (_g.showFooter && (!widget.fixedFooter || start + i != instance.records.length - 1)) {
							children.push(
								widget.renderGroupFooter(
									null,
									instance,
									_g,
									record.level,
									record.group,
									record.key + "-footer",
									record.store,
									false,
									false
								)
							);
							if (hasFixedColumns)
								fixedChildren.push(
									widget.renderGroupFooter(
										null,
										instance,
										_g,
										record.level,
										record.group,
										record.key + "-footer",
										record.store,
										false,
										true
									)
								);
						}
					}
				}
			});
			instance.recordInstanceCache.sweep();
		} else {
			instance.records.forEach(function(record, i) {
				if (record.type == "data") {
					addRow(record, i);
				} else {
					children.push(record.vdom);
					if (hasFixedColumns) fixedChildren.push(record.fixedVdom);
				}
			});
		}

		if (this.state.dropTarget == "grid" && this.state.dropInsertionIndex != null) {
			var dragInsertionRow = /*#__PURE__*/ jsx(
				"tbody",
				{
					children: /*#__PURE__*/ jsx("tr", {
						children: /*#__PURE__*/ jsx("td", {
							className: CSS.element(baseClass, "dropzone"),
							colSpan: 1000,
							style: {
								height: data.dropMode == "insertion" ? 0 : this.state.dropItemHeight
							}
						})
					})
				},
				"dropzone"
			);

			children.splice(this.state.dropInsertionIndex, 0, dragInsertionRow);
		}

		var content = [],
			fixedColumnsContent = []; //instance.records holds the record count after filtering

		if (data.emptyText && data.empty) {
			children = [
				/*#__PURE__*/ jsx(
					"tbody",
					{
						className: CSS.element(baseClass, "empty-text"),
						children: /*#__PURE__*/ jsx("tr", {
							children: /*#__PURE__*/ jsx("td", {
								colSpan: 1000,
								children: data.emptyText
							})
						})
					},
					"empty"
				)
			];
		}

		if (hasFixedColumns) {
			fixedColumnsContent.push(
				/*#__PURE__*/ jsx(
					"div",
					{
						ref: this.fixedScrollerRef,
						className: CSS.element(baseClass, "fixed-scroll-area", {
							"fixed-header": !!this.props.header
						}),
						children: /*#__PURE__*/ jsx("div", {
							className: CSS.element(baseClass, "fixed-table-wrapper"),
							children: /*#__PURE__*/ jsxs("table", {
								ref: function ref(el) {
									_this7.dom.fixedTable = el;
								},
								children: [this.props.fixedColumnsHeader, fixedChildren]
							})
						})
					},
					"fixedscroller"
				)
			);
		}

		content.push(
			/*#__PURE__*/ jsx(
				"div",
				{
					ref: this.scrollerRef,
					onScroll: this.onScroll.bind(this),
					className: CSS.element(baseClass, "scroll-area", {
						"fixed-header": !!this.props.header
					}),
					children: /*#__PURE__*/ jsx("div", {
						className: CSS.element(baseClass, "table-wrapper"),
						children: /*#__PURE__*/ jsxs("table", {
							ref: function ref(el) {
								_this7.dom.table = el;
							},
							children: [this.props.header, children]
						})
					})
				},
				"scroller"
			)
		);
		if (this.props.fixedHeader)
			content.push(
				/*#__PURE__*/ jsx(
					"div",
					{
						ref: function ref(el) {
							_this7.dom.fixedHeader = el;
						},
						className: CSS.element(baseClass, "fixed-header"),
						style: {
							display: this.scrollWidth > 0 ? "block" : "none"
						},
						children: /*#__PURE__*/ jsx("table", {
							children: this.props.fixedHeader
						})
					},
					"fh"
				)
			);
		if (this.props.fixedColumnsFixedHeader)
			fixedColumnsContent.push(
				/*#__PURE__*/ jsx(
					"div",
					{
						ref: function ref(el) {
							_this7.dom.fixedColumnsFixedHeader = el;
						},
						className: CSS.element(baseClass, "fixed-fixed-header"),
						style: {
							display: this.scrollWidth > 0 ? "block" : "none"
						},
						children: /*#__PURE__*/ jsx("table", {
							children: this.props.fixedColumnsFixedHeader
						})
					},
					"fcfh"
				)
			);

		if (fixedFooter || fixedColumnsFixedFooter) {
			content.push(
				/*#__PURE__*/ jsx(
					"div",
					{
						ref: function ref(el) {
							_this7.dom.fixedFooter = el;
						},
						className: CSS.element(baseClass, "fixed-footer"),
						style: {
							display: this.scrollWidth > 0 ? "block" : "none"
						},
						children: /*#__PURE__*/ jsx("table", {
							children: fixedFooter
						})
					},
					"ff"
				)
			);
			if (hasFixedColumns)
				fixedColumnsContent.push(
					/*#__PURE__*/ jsx(
						"div",
						{
							ref: function ref(el) {
								_this7.dom.fixedColumnsFixedFooter = el;
							},
							className: CSS.element(baseClass, "fixed-fixed-footer"),
							style: {
								display: this.scrollWidth > 0 ? "block" : "none"
							},
							children: /*#__PURE__*/ jsx("table", {
								children: fixedColumnsFixedFooter
							})
						},
						"fcff"
					)
				);
		}

		var columnInsertionMarker = null;

		if (this.state.dropTarget == "column") {
			columnInsertionMarker = /*#__PURE__*/ jsx("div", {
				className: CSS.element(baseClass, "col-insertion-marker"),
				style: {
					left: this.state.colDropInsertionLeft
				}
			});
		}

		return /*#__PURE__*/ jsxs("div", {
			className: data.classNames,
			style: _objectSpread2(
				_objectSpread2({}, data.style),
				{},
				{
					counterReset: "cx-row-number " + start
				}
			),
			tabIndex: widget.focusable ? data.tabIndex || 0 : null,
			ref: this.gridRef,
			onKeyDown: this.handleKeyDown.bind(this),
			onFocus: this.onFocus.bind(this),
			onBlur: this.onBlur.bind(this),
			children: [fixedColumnsContent, content, columnInsertionMarker]
		});
	};

	_proto2.getRecordsSlice = function getRecordsSlice(start, end) {
		var _this$props3 = this.props,
			data = _this$props3.data,
			instance = _this$props3.instance;
		var widget = instance.widget;

		if (!widget.infinite) {
			var source = instance.records || data.records;
			return source.slice(start, end);
		}

		var offset = data.offset,
			records = data.records;
		var result = [];

		for (var i = start; i < Math.min(end, data.totalRecordCount); i++) {
			if (i >= offset && i < offset + records.length) result.push(records[i - offset]);
			else result.push(null);
		}

		return result;
	};

	_proto2.ensureData = function ensureData(visibleStart, visibleEnd) {
		var _this8 = this;

		if (this.loading) return;
		var instance = this.props.instance;
		var widget = instance.widget;
		var pageSize = widget.pageSize;
		var startPage = Math.trunc(visibleStart / pageSize) + 1,
			endPage = Math.trunc((visibleEnd - 1) / pageSize) + 1; //debouncing restricts excessive page loading on fast scrolling as rendering data is
		//useless because visible region is scrolled away before data appears
		//the user should spent some time on the page before loading it

		if (!this.loadPageRange)
			this.loadPageRange = debounce(function(startPage, endPage) {
				var data = _this8.props.data;
				var records = data.records,
					offset = data.offset;
				var promises = [];

				for (var page = startPage; page <= endPage; page++) {
					var s = (page - 1) * pageSize,
						e = s + pageSize;

					if (s >= offset && e <= offset + records.length) {
						promises.push(Promise.resolve(records.slice(s - offset, e - offset)));
					} else {
						var result = instance.invoke(
							"onFetchRecords",
							{
								page: page,
								pageSize: pageSize,
								sorters: data.sorters,
								sortField: data.sortField,
								sortDirection: data.sortDirection,
								filterParams: data.filterParams,
								state: _this8.prevFetchRecordsState
							},
							instance
						);
						promises.push(Promise.resolve(result));
					}
				}

				_this8.loading = true;
				Promise.all(promises)
					.then(function(pageRecords) {
						_this8.loading = false;
						var records = [];
						var totalRecordCount;
						var lastPage;
						pageRecords.forEach(function(page) {
							if (Array.isArray(page)) {
								records.push.apply(records, page);
							} else {
								if (!Array.isArray(page.records))
									throw new Error(
										"onFetchRecords should return an array of records or an object with results inside records property."
									);
								totalRecordCount = page.totalRecordCount;
								lastPage = page.lastPage;
								_this8.prevFetchRecordsState = page.state;
								records.push.apply(records, page.records);
							}
						});
						var data = _this8.props.data;

						if (!isNumber(totalRecordCount)) {
							totalRecordCount = (startPage - 1) * pageSize + records.length;
							if (!lastPage && records.length == (endPage - startPage + 1) * pageSize) totalRecordCount++;
							if (data.totalRecordCount > totalRecordCount) totalRecordCount = data.totalRecordCount;
						}

						instance.buffer.totalRecordCount = data.totalRecordCount = totalRecordCount;
						instance.buffer.records = data.records = records;
						instance.buffer.page = data.page = startPage;
						data.offset = (startPage - 1) * pageSize;
						instance.store.silently(function() {
							instance.set("records", records);
							instance.set("page", startPage);
							instance.set("totalRecordCount", totalRecordCount);
						});
						var stateChanges = {
							startPage: startPage,
							endPage: endPage
						};
						if (_this8.state.end == 0) stateChanges.end = Math.min(widget.bufferSize, totalRecordCount);

						_this8.setState(stateChanges, function() {
							_this8.loadingStartPage = startPage;
							_this8.loadingEndPage = endPage;

							_this8.onScroll();
						});
					})
					["catch"](function(error) {
						_this8.loading = false;
						if (widget.onLoadingError) instance.invoke(error, "onLoadingError", instance);
					});
			}, 30);

		if (startPage < this.loadingStartPage || endPage > this.loadingEndPage) {
			this.loadingStartPage = startPage;
			this.loadingEndPage = endPage;
			this.loadPageRange(startPage, endPage);
		}
	};

	_proto2.onScroll = function onScroll() {
		var _this9 = this;

		//check if unmounted
		if (!this.dom.scroller) return;

		if (this.dom.fixedHeader) {
			this.dom.fixedHeader.scrollLeft = this.dom.scroller.scrollLeft;
		}

		if (this.dom.fixedFooter) {
			this.dom.fixedFooter.scrollLeft = this.dom.scroller.scrollLeft;
		}

		if (this.dom.fixedScroller) {
			this.dom.fixedScroller.scrollTop = this.dom.scroller.scrollTop;
		}

		var _this$props4 = this.props,
			instance = _this$props4.instance,
			data = _this$props4.data;
		var widget = instance.widget;

		if (widget.buffered && !this.pending) {
			var start = 0;
			if (widget.measureRowHeights && instance.records)
				start = Math.max(0, this.estimateStart(instance.records, this.dom.scroller.scrollTop) - widget.bufferStep);
			else if (this.rowHeight > 0) start = Math.round(this.dom.scroller.scrollTop / this.rowHeight - widget.bufferStep);
			start = Math.round(start / widget.bufferStep) * widget.bufferStep;
			start = Math.max(0, Math.min(start, data.totalRecordCount - widget.bufferSize));
			var end = Math.min(data.totalRecordCount, start + widget.bufferSize);

			if (widget.infinite) {
				this.ensureData(start, end);
			}

			if (this.syncBuffering) {
				this.start = start;
				this.end = end;
			} else if (this.state.end != end) {
				this.pending = true;
				this.setState(
					{
						start: start,
						end: end
					},
					function() {
						_this9.pending = false;
					}
				);
			}
		}
	};

	_proto2.onFixedColumnsWheel = function onFixedColumnsWheel(e) {
		this.dom.scroller.scrollTop += e.deltaY;
		e.preventDefault();
	};

	_proto2.shouldComponentUpdate = function shouldComponentUpdate(props, state) {
		return props.shouldUpdate !== false || state !== this.state;
	};

	_proto2.componentDidMount = function componentDidMount() {
		var _this10 = this;

		this.componentDidUpdate();
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.scrollable)
			this.offResize = ResizeManager.trackElement(this.dom.scroller, function() {
				//update fixed header/footer
				_this10.componentDidUpdate();

				instance.setState({
					dimensionsVersion: instance.state.dimensionsVersion + 1,
					lockedColWidth: {}
				});
			});
		if (widget.pipeKeyDown) instance.invoke("pipeKeyDown", this.handleKeyDown.bind(this), instance);
		this.unregisterDropZone = registerDropZone(this);
		if (widget.infinite) this.ensureData(0, 0);

		if (this.dom.fixedScroller) {
			this.onFixedColumnsWheel = this.onFixedColumnsWheel.bind(this);
			this.dom.fixedScroller.addEventListener("wheel", this.onFixedColumnsWheel, {
				passive: false
			});
		}
	};

	_proto2.onDragStart = function onDragStart(e) {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onDragStart) instance.invoke("onDragStart", e, instance);
	};

	_proto2.onDrop = function onDrop(e) {
		var instance = this.props.instance;
		var widget = instance.widget;

		var _this$getBufferStartE2 = this.getBufferStartEnd(),
			start = _this$getBufferStartE2.start;

		var _this$state2 = this.state,
			dropInsertionIndex = _this$state2.dropInsertionIndex,
			dropTarget = _this$state2.dropTarget;

		if (dropTarget == "grid" && widget.onDrop && dropInsertionIndex != null) {
			e.target = {
				insertionIndex: start + dropInsertionIndex,
				recordBefore: this.getRecordAt(start + dropInsertionIndex - 1),
				recordAfter: this.getRecordAt(start + dropInsertionIndex)
			};
			instance.invoke("onDrop", e, instance);
		} else if (dropTarget == "row") {
			e.target = {
				index: start + dropInsertionIndex,
				record: this.getRecordAt(start + dropInsertionIndex)
			};
			instance.invoke("onRowDrop", e, instance);
		} else if (dropTarget == "column" && widget.onColumnDrop) {
			e.target = {
				index: this.state.colDropInsertionIndex,
				grid: widget,
				instance: instance
			};
			instance.invoke("onColumnDrop", e, instance);
		}
	};

	_proto2.onDropTest = function onDropTest(e) {
		var instance = this.props.instance;
		var widget = instance.widget;
		var grid = widget.onDropTest && instance.invoke("onDropTest", e, instance);
		var row = widget.onRowDropTest && instance.invoke("onRowDropTest", e, instance);
		var column = widget.onColumnDropTest && instance.invoke("onColumnDropTest", e, instance);
		return (
			(grid || row || column) && {
				grid: grid,
				row: row,
				column: column
			}
		);
	};

	_proto2.onDragEnd = function onDragEnd(e) {
		this.setState({
			dropTarget: null,
			dropInsertionIndex: null,
			colDropInsertionIndex: null,
			colDropInsertionLeft: null
		});
		var instance = this.props.instance;
		var widget = instance.widget;
		if (widget.onDragEnd) instance.invoke("onDragEnd", e, instance);
	};

	_proto2.onDragMeasure = function onDragMeasure(e, _ref3) {
		var _ref3$test = _ref3.test,
			grid = _ref3$test.grid,
			row = _ref3$test.row,
			column = _ref3$test.column;
		//columns can be dropped anywhere, while rows only in the scrollable area
		var r = getTopLevelBoundingClientRect(column ? this.dom.el : this.dom.scroller);
		var _e$cursor = e.cursor,
			clientX = _e$cursor.clientX,
			clientY = _e$cursor.clientY;
		if (clientX < r.left || clientX >= r.right || clientY < r.top || clientY >= r.bottom) return false;
		return {
			over: 1000
		};
	};

	_proto2.onColumnDragOver = function onColumnDragOver(ev) {
		var headerTBody = this.dom.table.firstChild;
		var positions = [];
		var bounds;
		var exists = {};

		for (var r = 0; r < headerTBody.children.length; r++) {
			var cells = headerTBody.children[r].children;

			for (var c = 0; c < cells.length; c++) {
				bounds = cells[c].getBoundingClientRect();
				var key = bounds.left.toFixed(0);
				if (exists[key]) continue;
				positions.push(bounds.left);
				exists[key] = true;
			}

			if (r == 0) positions.push(bounds.right);
		} //due to the order of enumeration it's possible that positions are out of order

		positions.sort(function(a, b) {
			return a - b;
		});
		var index = 0;

		while (index + 1 < positions.length && ev.cursor.clientX > positions[index + 1]) {
			index++;
		}

		var fixedColumnCount = this.props.instance.fixedColumnCount;
		this.setState({
			colDropInsertionIndex: fixedColumnCount + index,
			colDropInsertionLeft:
				positions[index] - positions[0] - this.dom.scroller.scrollLeft + this.dom.scroller.offsetLeft,
			dropTarget: "column"
		});
	};

	_proto2.onDragOver = function onDragOver(ev, _ref4) {
		var _ref4$test = _ref4.test,
			grid = _ref4$test.grid,
			row = _ref4$test.row,
			column = _ref4$test.column;
		if (column) this.onColumnDragOver(ev);
		if (!grid && !row) return;
		var instance = this.props.instance;
		var widget = instance.widget,
			data = instance.data;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var rowClass = CSS.element(baseClass, "data");
		var nodes = Array.from(this.dom.table.children).filter(function(node) {
			return node.className && node.className.indexOf(rowClass) != -1;
		});

		var _this$getBufferStartE3 = this.getBufferStartEnd(),
			start = _this$getBufferStartE3.start;

		var s = 0,
			e = nodes.length,
			m,
			b;
		var parentOffset = getParentFrameBoundingClientRect(this.dom.scroller);
		var cy = ev.cursor.clientY - parentOffset.top;
		var rowOverIndex = null;

		while (s < e) {
			m = Math.floor((s + e) / 2);
			b = nodes[m].getBoundingClientRect(); //dragged items might be invisible and have no client bounds

			if (b.top == 0 && b.bottom == 0) {
				//it's important to go all the way in one direction otherwise infinite loop might occur
				while (m > s && b.top == 0 && b.bottom == 0) {
					m--;
					b = nodes[m].getBoundingClientRect();
				}

				while (m + 1 < e && b.top == 0 && b.bottom == 0) {
					m = m + 1;
					b = nodes[m].getBoundingClientRect();
				}

				if (b.top == 0 && b.bottom == 0) {
					s = e = m;
					break;
				}
			}

			if (cy < b.top) e = m;
			else if (cy > b.bottom) s = m + 1;
			else {
				//hovering over a row here
				if (row) {
					var confirmed = !grid;

					if (!confirmed) {
						var insertionZone = (b.bottom - b.top) / 4;
						confirmed = cy > b.top + insertionZone && cy < b.bottom - insertionZone;
					}

					if (confirmed) {
						rowOverIndex = m;
						break;
					}
				}

				if (cy > (b.bottom + b.top) / 2) s = e = m + 1;
				else s = e = m;
			}
		}

		var cancel = false;

		if (rowOverIndex != null) {
			var evt = _objectSpread2(
				_objectSpread2({}, ev),
				{},
				{
					target: {
						record: this.getRecordAt(rowOverIndex),
						index: start + rowOverIndex
					}
				}
			);

			if (widget.onRowDragOver && instance.invoke("onRowDragOver", evt, instance) === false) cancel = true;
			else if (rowOverIndex != this.state.dropInsertionIndex || this.state.dropTarget != "row") {
				this.setState({
					dropInsertionIndex: rowOverIndex,
					dropItemHeight: ev.source.height - 1,
					dropTarget: "row"
				});
			}
		} else if (grid) {
			var _evt = _objectSpread2(
				_objectSpread2({}, ev),
				{},
				{
					target: {
						recordBefore: this.getRecordAt(s - 1),
						recordAfter: this.getRecordAt(s),
						insertionIndex: start + s,
						totalRecordCount: data.totalRecordCount
					}
				}
			);

			if (widget.onDragOver && instance.invoke("onDragOver", _evt, instance) === false) cancel = true;
			else if (s != this.state.dropInsertionIndex || this.state.dropTarget != "grid") {
				this.setState({
					dropInsertionIndex: s,
					dropItemHeight: ev.source.height - 1,
					dropTarget: "grid"
				});
			}
		}

		if (cancel) {
			this.setState({
				dropInsertionIndex: null,
				dropTarget: null
			});
		}
	};

	_proto2.onDragLeave = function onDragLeave(e) {
		this.setState({
			dropInsertionIndex: null,
			dropTarget: null
		});
	};

	_proto2.onGetHScrollParent = function onGetHScrollParent() {
		var widget = this.props.instance.widget;
		if (widget.scrollable) return this.dom.scroller;
		return findScrollableParent(this.dom.table, true);
	};

	_proto2.onGetVScrollParent = function onGetVScrollParent(_ref5) {
		var _ref5$test = _ref5.test,
			grid = _ref5$test.grid,
			row = _ref5$test.row,
			column = _ref5$test.column;
		if (column && !grid && !row) return null;
		var widget = this.props.instance.widget;
		if (widget.scrollable) return this.dom.scroller;
		return findScrollableParent(this.dom.table);
	};

	_proto2.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(props) {
		var _props$instance = props.instance,
			data = _props$instance.data,
			widget = _props$instance.widget;
		if (this.state.cursor >= data.totalRecordCount)
			this.setState({
				cursor: data.totalRecordCount - 1
			});
		else if (widget.selectable && this.state.focused && this.state.cursor < 0)
			this.setState({
				cursor: 0
			});
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (this.offResize) this.offResize();
		offFocusOut(this);
		if (this.unregisterDropZone) this.unregisterDropZone();
		if (widget.pipeKeyDown) instance.invoke("pipeKeyDown", null, instance);

		if (this.dom.fixedScroller) {
			this.dom.fixedScroller.removeEventListener("wheel", this.onFixedColumnsWheel);
		}
	};

	_proto2.estimateHeight = function estimateHeight(records, start, end, breakCondition) {
		var avgDataRowHeight = this.heightStats.estimate("data");
		var totalHeight = 0;

		for (var i = start; i < end; i++) {
			var record = records[i];

			switch (record.type) {
				case "data":
					if (record.key in this.rowHeights) totalHeight += this.rowHeights[record.key];
					else totalHeight += avgDataRowHeight;
					break;

				case "group-header":
					if (record.grouping.showCaption) {
						var captionKey = "group-caption-" + record.level;
						if (captionKey + "-" + record.group.$key in this.rowHeights)
							totalHeight += this.rowHeights[captionKey + "-" + record.group.$key];
						else totalHeight += this.heightStats.estimate(captionKey) || avgDataRowHeight;
					}

					break;

				case "group-footer":
					if (record.grouping.showFooter) {
						var _captionKey = "group-footer-" + record.level;

						if (_captionKey + "-" + record.group.$key in this.rowHeights)
							totalHeight += this.rowHeights[_captionKey + "-" + record.group.$key];
						else totalHeight += this.heightStats.estimate(_captionKey) || avgDataRowHeight;
					}

					break;

				default:
					Console.warn("UNPROCESSED RECORD TYPE", record);
					break;
			}

			if (breakCondition && breakCondition(i, totalHeight) === false) break;
		}

		return totalHeight;
	};

	_proto2.estimateStart = function estimateStart(records, height) {
		var start = 0;
		if (height == 0) return 0;
		this.estimateHeight(records, 0, records.length, function(index, h) {
			start = index;
			return h < height;
		});
		return start;
	};

	_proto2.componentDidUpdate = function componentDidUpdate() {
		var _this$props5 = this.props,
			instance = _this$props5.instance,
			data = _this$props5.data;
		var widget = instance.widget,
			fixedFooterOverlap = instance.fixedFooterOverlap;

		if (
			widget.lockColumnWidths &&
			isArray(data.records) &&
			data.records.length >= widget.lockColumnWidthsRequiredRowCount
		) {
			var headerTBody = this.dom.table.firstChild;

			for (var r = 0; r < headerTBody.children.length; r++) {
				var sr = headerTBody.children[r];

				for (var c = 0; c < sr.children.length; c++) {
					var cell = sr.children[c];
					cell.style.width = cell.style.minWidth = cell.style.maxWidth = sr.children[c].offsetWidth + "px";
					cell.style.boxSizing = "border-box";
					if (cell.dataset.uniqueColId)
						instance.state.lockedColWidth[cell.dataset.uniqueColId] = sr.children[c].offsetWidth;
				}
			}
		}

		if (widget.scrollable) {
			this.scrollWidth = this.dom.scroller.offsetWidth - this.dom.scroller.clientWidth;
			var resized = false,
				headerHeight = 0,
				footerHeight = 0,
				rowHeight = 0;
			if (this.dom.fixedTable) syncHeaderHeights(this.dom.table.firstChild, this.dom.fixedTable.firstChild);

			if (this.dom.fixedHeader) {
				var fixedHeaderTBody = this.dom.fixedHeader.firstChild.firstChild;
				resized = widget.preciseMeasurements
					? copyCellSizePrecise(this.dom.table.firstChild, fixedHeaderTBody)
					: copyCellSize(this.dom.table.firstChild, fixedHeaderTBody);
				var scrollColumnEl = fixedHeaderTBody.firstChild.lastChild;
				if (scrollColumnEl) scrollColumnEl.style.minWidth = scrollColumnEl.style.maxWidth = this.scrollWidth + "px";
				this.dom.fixedHeader.style.display = "block";
				headerHeight = this.dom.fixedHeader.offsetHeight;
				this.dom.scroller.style.marginTop = headerHeight + "px";
				if (this.dom.fixedScroller) this.dom.fixedScroller.style.marginTop = headerHeight + "px";
			} else {
				this.dom.scroller.style.marginTop = 0;
				if (this.dom.fixedScroller) this.dom.fixedScroller.style.marginTop = 0;
			}

			if (this.dom.fixedColumnsFixedHeader) {
				var fixedColumnsWidth = this.dom.fixedScroller.offsetWidth + "px";
				this.dom.fixedColumnsFixedHeader.style.right = "auto";
				this.dom.fixedColumnsFixedHeader.style.width = fixedColumnsWidth;
				if (this.dom.fixedHeader) this.dom.fixedHeader.style.left = fixedColumnsWidth;
				this.dom.fixedColumnsFixedHeader.style.display = "block";
				var _fixedHeaderTBody = this.dom.fixedColumnsFixedHeader.firstChild.firstChild;

				if (this.dom.fixedTable.firstChild) {
					resized = copyCellSize(this.dom.fixedTable.firstChild, _fixedHeaderTBody);
				}
			}

			if (this.dom.fixedFooter || this.dom.fixedColumnsFixedFooter) {
				if (this.dom.fixedColumnsFixedFooter) {
					var _fixedColumnsWidth = this.dom.fixedScroller.offsetWidth + "px";

					this.dom.fixedColumnsFixedFooter.style.right = "auto";
					this.dom.fixedColumnsFixedFooter.style.width = _fixedColumnsWidth;
					var dstTableBody = this.dom.fixedColumnsFixedFooter.firstChild.firstChild;

					if (dstTableBody) {
						var srcTableBody = this.dom.fixedTable.lastChild;
						copyCellSize(srcTableBody, dstTableBody, fixedFooterOverlap);
						this.dom.fixedColumnsFixedFooter.style.display = "block";
						footerHeight = this.dom.fixedFooter.offsetHeight;
					}
				}

				if (this.dom.fixedFooter) {
					var _dstTableBody = this.dom.fixedFooter.firstChild.firstChild;

					if (_dstTableBody) {
						var _srcTableBody = this.dom.table.lastChild;
						copyCellSize(_srcTableBody, _dstTableBody, fixedFooterOverlap);
						var _scrollColumnEl = _dstTableBody.firstChild.lastChild;
						if (_scrollColumnEl)
							_scrollColumnEl.style.minWidth = _scrollColumnEl.style.maxWidth = this.scrollWidth + "px";
						this.dom.fixedFooter.style.display = "block";
						footerHeight = this.dom.fixedFooter.offsetHeight;
					}

					if (this.dom.fixedScroller) this.dom.fixedFooter.style.left = this.dom.fixedScroller.offsetWidth + "px";
				}

				this.dom.scroller.style.marginBottom = footerHeight + "px";
				if (this.dom.fixedScroller) this.dom.fixedScroller.style.marginBottom = footerHeight + "px"; //Show the last row if fixed footer is shown without grouping, otherwise hide it.
				//For buffered grids, footer is never rendered within the body.
				//Hacky: accessing internal adapter property to check if grouping is applied

				if (!isNonEmptyArray(instance.dataAdapter.groupings) || widget.buffered) footerHeight = 0;
			} else {
				this.dom.scroller.style.marginBottom = 0;
				if (this.dom.fixedScroller) this.dom.fixedScroller.style.marginBottom = 0;
			}

			var scrollOverlap = fixedFooterOverlap ? footerHeight : 0;

			if (widget.buffered) {
				var _this$getBufferStartE4 = this.getBufferStartEnd(),
					start = _this$getBufferStartE4.start,
					end = _this$getBufferStartE4.end;

				var remaining = 0,
					count = Math.min(data.totalRecordCount, end - start);

				if (widget.measureRowHeights) {
					if (!this.rowHeights) this.rowHeights = {};
					if (!this.heightStats) this.heightStats = new AvgHeight();

					for (var i = 0; i < this.dom.table.children.length; i++) {
						var body = this.dom.table.children[i];

						if (body.dataset.recordKey != null) {
							if (!(body.dataset.recordKey in this.rowHeights)) this.heightStats.add("data", body.offsetHeight);
							this.rowHeights[body.dataset.recordKey] = body.offsetHeight;
						} else if (body.dataset.groupKey) {
							var key = body.dataset.groupElement + "-" + body.dataset.groupKey;
							this.rowHeights[key] = body.offsetHeight;
							if (!(body.dataset.recordKey in this.rowHeights))
								this.heightStats.add(body.dataset.groupElement, body.offsetHeight);
						}
					}
				}

				if (count > 0) {
					//do not change row height while a drag-drop operation is in place
					rowHeight = this.state.dragged
						? this.rowHeight
						: Math.round((this.dom.table.offsetHeight - headerHeight) / count); // if (this.rowHeight && this.rowHeight != rowHeight) {
					//    console.warn("ROW-HEIGHT-CHANGE", this.rowHeight, rowHeight);
					// }

					remaining = Math.max(0, data.totalRecordCount - end);
				}

				var upperMargin = 0,
					lowerMargin = 0;

				if (widget.measureRowHeights && instance.records) {
					upperMargin = this.estimateHeight(instance.records, 0, start);
					lowerMargin = this.estimateHeight(instance.records, end, instance.records.length);
				} else {
					upperMargin = start * rowHeight;
					lowerMargin = remaining * rowHeight;
				} //console.log(upperMargin, start * rowHeight, this.rowHeights, this.heightStats);

				this.dom.table.style.marginTop = (-headerHeight + upperMargin).toFixed(0) + "px";
				this.dom.table.style.marginBottom = (lowerMargin - scrollOverlap).toFixed(0) + "px";
			} else {
				this.dom.table.style.marginTop = -headerHeight + "px";
				this.dom.table.style.marginBottom = -scrollOverlap + "px";
			}

			if (this.dom.fixedTable) {
				this.dom.fixedTable.style.marginTop = this.dom.table.style.marginTop;
				this.dom.fixedTable.style.marginBottom = this.dom.table.style.marginBottom;
			}

			this.rowHeight = rowHeight;
			var sortersChanged = widget.infinite && !shallowEquals(data.sorters, this.lastSorters);

			if (data.empty && !widget.infinite) {
				this.dom.scroller.scrollTop = 0;
			}

			if (
				sortersChanged ||
				data.filterParams !== this.lastScrollFilterParams ||
				data.scrollResetParams !== this.lastScrollResetParams
			) {
				this.dom.scroller.scrollTop = 0;
				this.lastScrollFilterParams = data.filterParams;
				this.lastScrollResetParams = data.scrollResetParams;
				this.lastSorters = data.sorters;

				if (widget.infinite) {
					this.loadingStartPage = 0;
					this.loadingEndPage = 0;
					instance.buffer.records = data.records = [];
					instance.buffer.totalRecordCount = 0;
					instance.buffer.page = 1;
					this.prevFetchRecordsState = null;
				}
			}

			if (widget.scrollSelectionIntoView && !widget.buffered) {
				var CSS = widget.CSS,
					baseClass = widget.baseClass;
				var selectedRowSelector = "." + CSS.element(baseClass, "data") + "." + CSS.state("selected");
				var firstSelectedRow = this.dom.table.querySelector(selectedRowSelector);

				if (firstSelectedRow != this.selectedEl) {
					firstSelectedRow && scrollElementIntoView(firstSelectedRow);
					this.selectedEl = firstSelectedRow;
				}
			}

			setTimeout(this.onScroll.bind(this), 0);
			if (resized) instance.fixedHeaderResizeEvent.notify();
		}
	};

	_proto2.moveCursor = function moveCursor(index, _temp) {
		var _this11 = this;

		var _ref6 = _temp === void 0 ? {} : _temp,
			focused = _ref6.focused,
			hover = _ref6.hover,
			scrollIntoView = _ref6.scrollIntoView,
			select = _ref6.select,
			selectRange = _ref6.selectRange,
			selectOptions = _ref6.selectOptions,
			cellIndex = _ref6.cellIndex,
			cellEdit = _ref6.cellEdit,
			cancelEdit = _ref6.cancelEdit;

		var _this$props$instance = this.props.instance,
			widget = _this$props$instance.widget,
			visibleColumns = _this$props$instance.visibleColumns;
		if (!widget.selectable && !widget.cellEditable) return;
		var newState = {};

		if (cellEdit != null && cellEdit != this.state.cellEdit) {
			newState.cellEdit = cellEdit;
			if (
				cellEdit &&
				(!visibleColumns[this.state.cursorCellIndex] || !visibleColumns[this.state.cursorCellIndex].editor)
			)
				newState.cellEdit = false;
		}

		if (cellIndex != null && cellIndex != this.state.cursorCellIndex) {
			newState.cursorCellIndex = cellIndex;
			newState.cellEdit = false;
		}

		if (widget.focused) focused = true;

		if (focused != null && this.state.focused != focused) {
			newState.focused = focused;
			newState.cellEdit = false;
		}

		if (index != this.state.cursor) {
			newState.cursor = index;
			newState.cellEdit = false;
		}

		batchUpdates(function() {
			if (select) {
				var start = selectRange && _this11.state.selectionStart >= 0 ? _this11.state.selectionStart : index;
				if (start < 0) start = index;

				_this11.selectRange(start, index, selectOptions);

				if (!selectRange) newState.selectionStart = index;
			}

			if (Object.keys(newState).length > 0) {
				var prevState = _this11.state;
				var wasCellEditing = prevState.focused && prevState.cellEdit;

				var futureState = _objectSpread2(_objectSpread2({}, _this11.state), newState);

				if (!futureState.cellEdit && wasCellEditing) {
					//If cell editing is in progress, moving the cursor may cause that the cell editor is unmounted before
					//the blur event which may cause data loss for components which do not have reactOn=change set, e.g. NumberField.
					getActiveElement().blur();

					var record = _this11.getRecordAt(prevState.cursor);

					if ((!_this11.cellEditorValid || cancelEdit) && _this11.cellEditUndoData)
						record.store.set(widget.recordName, _this11.cellEditUndoData);
					else {
						var newData = record.store.get(widget.recordName); //record.data might be stale at this point

						if (widget.onCellEdited && newData != _this11.cellEditUndoData)
							_this11.props.instance.invoke(
								"onCellEdited",
								{
									column: visibleColumns[prevState.cursorCellIndex],
									newData: newData,
									oldData: _this11.cellEditUndoData,
									field: visibleColumns[prevState.cursorCellIndex].field
								},
								record
							);
					}
				}

				if (futureState.cellEdit && !wasCellEditing)
					_this11.cellEditUndoData = _this11.getRecordAt(futureState.cursor).data;

				_this11.setState(newState, function() {
					if (_this11.state.focused && !_this11.state.cellEdit && wasCellEditing) FocusManager.focus(_this11.dom.el);

					if (scrollIntoView) {
						var _record = _this11.getRecordAt(index);

						var item = _record && _this11.dom.table.querySelector('tbody[data-record-key="' + _record.key + '"]');

						var hscroll = false;

						if (item) {
							if (widget.cellEditable)
								if (_this11.state.cursorCellIndex >= _this11.props.instance.fixedColumnCount) {
									hscroll = true;
									item =
										item.firstChild.children[_this11.state.cursorCellIndex - _this11.props.instance.fixedColumnCount];
								} else {
									var fixedItem = _this11.dom.fixedTable.querySelector('tbody[data-record-key="' + _record.key + '"]');

									var cell = fixedItem && fixedItem.firstChild.children[_this11.state.cursorCellIndex];
									if (cell) scrollElementIntoView(cell, false, true, 10);
								}
							scrollElementIntoView(item, true, hscroll, widget.cellEditable ? 10 : 0);
						}
					}
				});
			}
		});
	};

	_proto2.showCursor = function showCursor(focused) {
		var _this$props$instance2 = this.props.instance,
			records = _this$props$instance2.records,
			isSelected = _this$props$instance2.isSelected;
		var cursor = this.state.cursor;

		if (cursor == -1) {
			if (records) {
				cursor = records.findIndex(function(x) {
					return isSelected(x.data, x.index);
				}); //if there are no selected records, find the first data record (skip group header)

				if (cursor == -1)
					cursor = records.findIndex(function(x) {
						return x.type == "data";
					});
			} else cursor = 0;
		}

		this.moveCursor(cursor, {
			focused: true,
			scrollIntoView: false
		});
	};

	_proto2.onFocus = function onFocus() {
		var _this12 = this;

		FocusManager.nudge(); //focus moved within the grid

		if (this.state.focused) {
			if (this.state.cellEdit && this.dom.el == getActiveElement())
				this.moveCursor(this.state.cursor, {
					cellEdit: false
				});
			return;
		}

		var widget = this.props.instance.widget; //the cursor will be set if focus in originating from a mouse event

		setTimeout(function() {
			_this12.showCursor(true);
		}, 0);

		if (!widget.focused) {
			if (this.dom.el) {
				//if an inner element is focused first (autoFocus), this.dom.el might be undefined
				oneFocusOut(this, this.dom.el, function() {
					_this12.moveCursor(-1, {
						focused: false
					});
				});
			}
		}

		this.setState({
			focused: true
		});
	};

	_proto2.onBlur = function onBlur() {
		FocusManager.nudge();
	};

	_proto2.selectRange = function selectRange(from, to, options) {
		var _this$props6 = this.props,
			instance = _this$props6.instance,
			data = _this$props6.data;
		var records = instance.records,
			widget = instance.widget;

		if (from > to) {
			var tmp = from;
			from = to;
			to = tmp;
		}

		options = _objectSpread2(
			_objectSpread2({}, options),
			{},
			{
				range: from < to
			}
		);
		var selection = [],
			indexes = [];

		for (var cursor = from; cursor <= to; cursor++) {
			var record = void 0;
			if (records) record = records[cursor];
			else {
				var offset = widget.infinite ? data.offset : 0;
				var r = data.records[cursor - offset];
				if (r) record = widget.mapRecord(null, instance, r, cursor - offset);
			}

			if (record && record.type == "data") {
				if (instance.isRecordSelectable && !instance.isRecordSelectable(record.data, options)) continue;
				selection.push(record.data);
				indexes.push(record.index);
			}
		}

		widget.selection.selectMultiple(instance.store, selection, indexes, options);
	};

	_proto2.getRecordAt = function getRecordAt(cursor) {
		var _this$props7 = this.props,
			instance = _this$props7.instance,
			data = _this$props7.data;
		var records = instance.records,
			widget = instance.widget;
		if (records) return records[cursor];
		var offset = widget.infinite ? data.offset : 0;
		var r = data.records[cursor - offset];
		if (r) return widget.mapRecord(null, instance, r, cursor - offset);
		return null;
	};

	_proto2.getRecordInstanceAt = function getRecordInstanceAt(cursor) {
		var record = this.getRecordAt(cursor);
		if (!record) return null;
		var instance = this.props.instance;
		if (instance.recordInstanceCache)
			return instance.recordInstanceCache.getChild(instance.row, record.store, record.key); //different signature

		return instance.getChild(null, instance.row, record.key, record.store);
	};

	_proto2.handleKeyDown = function handleKeyDown(e) {
		var _this$props8 = this.props,
			instance = _this$props8.instance,
			data = _this$props8.data;
		var widget = instance.widget;
		if (widget.onKeyDown && instance.invoke("onKeyDown", e, instance) === false) return;
		var recordInstance = this.getRecordInstanceAt(this.state.cursor);
		if (recordInstance && widget.onRowKeyDown && instance.invoke("onRowKeyDown", e, recordInstance) === false) return;

		switch (e.keyCode) {
			case KeyCode.enter:
				this.moveCursor(this.state.cursor, {
					select: true,
					selectOptions: {
						toggle: e.ctrlKey && !e.shiftKey,
						add: e.ctrlKey && e.shiftKey
					},
					selectRange: e.shiftKey,
					cellEdit: widget.cellEditable && !this.state.cellEdit,
					focused: true
				});
				e.stopPropagation();
				e.preventDefault();
				break;

			case KeyCode.esc:
				if (this.state.cellEdit) {
					this.moveCursor(this.state.cursor, {
						cellEdit: false,
						focused: true,
						cancelEdit: true
					});
					e.stopPropagation();
					e.preventDefault();
				}

				break;

			case KeyCode.tab:
				if (widget.cellEditable) {
					e.stopPropagation();
					e.preventDefault();
					var direction = e.shiftKey ? -1 : +1;
					var cursor = this.state.cursor;
					var cellIndex = (this.state.cursorCellIndex + direction) % instance.row.line1.columns.length;

					if (cellIndex == -1) {
						cellIndex += instance.row.line1.columns.length;
						cursor--;
					} else if (cellIndex == 0 && direction > 0) cursor++;

					for (; ; cursor += direction) {
						var record = this.getRecordAt(cursor);
						if (!record) break;
						if (record.type != "data") continue;
						this.moveCursor(cursor, {
							focused: true,
							cellIndex: cellIndex,
							scrollIntoView: true,
							cellEdit: false
						});
						break;
					}
				}

				break;

			case KeyCode.down:
				for (var _cursor = this.state.cursor + 1; ; _cursor++) {
					var _record2 = this.getRecordAt(_cursor);

					if (!_record2) break;
					if (_record2.type != "data") continue;
					this.moveCursor(_cursor, {
						focused: true,
						scrollIntoView: true,
						select: e.shiftKey,
						selectRange: e.shiftKey
					});
					break;
				}

				e.stopPropagation();
				e.preventDefault();
				break;

			case KeyCode.up:
				for (var _cursor2 = this.state.cursor - 1; _cursor2 >= 0; _cursor2--) {
					var _record3 = this.getRecordAt(_cursor2);

					if (!_record3) break;
					if (_record3.type != "data") continue;
					this.moveCursor(_cursor2, {
						focused: true,
						scrollIntoView: true,
						select: e.shiftKey,
						selectRange: e.shiftKey
					});
					break;
				}

				e.stopPropagation();
				e.preventDefault();
				break;

			case KeyCode.right:
				if (widget.cellEditable) {
					if (this.state.cursorCellIndex + 1 < instance.row.line1.columns.length) {
						this.moveCursor(this.state.cursor, {
							focused: true,
							cellIndex: this.state.cursorCellIndex + 1,
							scrollIntoView: true
						});
					}

					e.stopPropagation();
					e.preventDefault();
				}

				break;

			case KeyCode.left:
				if (widget.cellEditable) {
					if (this.state.cursorCellIndex > 0) {
						this.moveCursor(this.state.cursor, {
							focused: true,
							cellIndex: this.state.cursorCellIndex - 1,
							scrollIntoView: true
						});
					}

					e.stopPropagation();
					e.preventDefault();
				}

				break;

			case KeyCode.a:
				if (!e.ctrlKey || !widget.selection.multiple) return;
				if (e.target.nodeName == "INPUT" || e.target.nodeName == "TEXTAREA") return;
				this.selectRange(0, data.totalRecordCount);
				e.stopPropagation();
				e.preventDefault();
				break;
		}
	};

	_proto2.beginDragDrop = function beginDragDrop(e, record) {
		var _this13 = this;

		var _this$props9 = this.props,
			instance = _this$props9.instance,
			data = _this$props9.data;
		var widget = instance.widget,
			store = instance.store; //get a fresh isSelected delegate

		var isSelected = widget.selection.getIsSelectedDelegate(store);
		var selected = [];

		var add = function add(rec, data, index, force) {
			if (!data || !(force || isSelected(data, index))) return;
			var mappedRecord = rec ? _objectSpread2({}, rec) : widget.mapRecord(null, instance, data, index);
			var row = (mappedRecord.row = instance.getDetachedChild(
				instance.row,
				"DD:" + mappedRecord.key,
				mappedRecord.store
			));
			row.selected = true;
			selected.push(mappedRecord);
		};

		if (!record.selected) {
			if (instance.records)
				instance.records.forEach(function(r) {
					return add(r, r.data, r.index);
				});
			else
				this.getRecordsSlice(0, data.totalRecordCount).forEach(function(r, index) {
					return add(null, r, index);
				});
		}

		if (selected.length == 0) add(record, record.data, record.index, true);
		var renderRow = this.createRowRenderer(false);
		var contents = selected.map(function(record, i) {
			return {
				type: StaticText,
				text: renderRow(record, i, true, false)
			};
		});
		initiateDragDrop(
			e,
			{
				sourceEl: closest(e.currentTarget, function(a) {
					return a.tagName == "TBODY";
				}),
				source: {
					data: data.dragSource.data,
					store: store,
					record: record,
					records: selected
				},
				clone: {
					store: record.store,
					matchCursorOffset: true,
					matchWidth: true,
					widget: {
						$type: HtmlElement$1,
						tag: "div",
						className: data.classNames,
						jsxAttributes: ["className"],
						children: [
							"\n                        ",
							{
								$type: HtmlElement$1,
								tag: "table",
								children: [contents]
							},
							"\n                     "
						]
					}
				}
			},
			function() {
				_this13.setState({
					dragged: false
				});
			}
		);
		this.setState({
			dragged: record
		});
	};

	return GridComponent;
})(VDOM.Component);

var GridColumnHeaderLine = /*#__PURE__*/ (function(_PureContainer) {
	_inheritsLoose(GridColumnHeaderLine, _PureContainer);

	function GridColumnHeaderLine() {
		return _PureContainer.apply(this, arguments) || this;
	}

	var _proto3 = GridColumnHeaderLine.prototype;

	_proto3.declareData = function declareData() {
		var _PureContainer$protot;

		return (_PureContainer$protot = _PureContainer.prototype.declareData).call.apply(
			_PureContainer$protot,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					showHeader: undefined
				}
			])
		);
	};

	_proto3.init = function init() {
		this.items = Widget.create(GridColumnHeader, this.columns || []);
		this.visible = this.showHeader;
		this.style = this.headerStyle;
		this.className = this.headerClass;
		this["class"] = null;

		_PureContainer.prototype.init.call(this);
	};

	_proto3.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"tr",
			{
				className: data.classNames,
				style: data.style,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	return GridColumnHeaderLine;
})(PureContainer);

GridColumnHeaderLine.prototype.isPureContainer = false;
GridColumnHeaderLine.prototype.styled = true;
GridColumnHeaderLine.prototype.showHeader = true;
GridColumnHeaderLine.autoInit = true;

var GridColumnHeader = /*#__PURE__*/ (function(_Widget2) {
	_inheritsLoose(GridColumnHeader, _Widget2);

	function GridColumnHeader() {
		return _Widget2.apply(this, arguments) || this;
	}

	var _proto4 = GridColumnHeader.prototype;

	_proto4.declareData = function declareData() {
		var _Widget2$prototype$de;

		return (_Widget2$prototype$de = _Widget2.prototype.declareData).call.apply(
			_Widget2$prototype$de,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					format: undefined,
					width: undefined,
					defaultWidth: undefined,
					fixed: undefined
				}
			])
		);
	};

	_proto4.init = function init() {
		delete this.style;
		delete this.className;
		delete this["class"];
		if (this.header) this.header1 = this.header;

		if (this.header1 || this.resizable || this.width || this.defaultWidth || this.sortable || this.draggable) {
			if (!isObject(this.header1))
				this.header1 = {
					text: this.header1 || ""
				};
			if (this.resizable) this.header1.resizable = this.resizable;
			if (this.width) this.header1.width = this.width;
			if (this.defaultWidth) this.header1.defaultWidth = this.defaultWidth;
			if (this.draggable) this.header1.draggable = this.draggable;
		}

		if (this.header2 && isSelector(this.header2))
			this.header2 = {
				text: this.header2
			};
		if (this.header3 && isSelector(this.header3))
			this.header3 = {
				text: this.header3
			};
		if (!this.aggregateField && this.field) this.aggregateField = this.field;
		if (!this.aggregateAlias) this.aggregateAlias = this.aggregateField;
		if (this.footer && isSelector(this.footer))
			this.footer = {
				value: this.footer,
				pad: this.pad
			};

		if (this.footer) {
			this.footer.value = getSelector(this.footer.value);
			this.footer["class"] = getSelector(this.footer["class"]);
			this.footer.style = getSelector(this.footer.style);
			this.footer.format = getSelector(this.footer.format);
		}

		if (this.caption && isSelector(this.caption))
			this.caption = {
				value: this.caption,
				pad: this.pad,
				format: this.format
			};

		if (this.caption) {
			var children = this.caption.children || this.caption.items;

			if (children) {
				delete this.caption.items;
				this.caption.children = Widget.create(children);
			} else this.caption.value = getSelector(this.caption.value);
		}

		_Widget2.prototype.init.call(this);
	};

	_proto4.initComponents = function initComponents() {
		return _Widget2.prototype.initComponents.call(this, {
			header1: this.header1 && GridColumnHeaderCell.create(this.header1),
			header2: this.header2 && GridColumnHeaderCell.create(this.header2),
			header3: this.header3 && GridColumnHeaderCell.create(this.header3)
		});
	};

	_proto4.render = function render() {
		return null;
	};

	return GridColumnHeader;
})(Widget);

GridColumnHeader.autoInit = true;

var GridColumnHeaderCell = /*#__PURE__*/ (function(_PureContainer2) {
	_inheritsLoose(GridColumnHeaderCell, _PureContainer2);

	function GridColumnHeaderCell() {
		return _PureContainer2.apply(this, arguments) || this;
	}

	var _proto5 = GridColumnHeaderCell.prototype;

	_proto5.declareData = function declareData() {
		var _PureContainer2$proto;

		return (_PureContainer2$proto = _PureContainer2.prototype.declareData).call.apply(
			_PureContainer2$proto,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					text: undefined,
					colSpan: undefined,
					rowSpan: undefined,
					width: undefined,
					defaultWidth: undefined,
					resizable: undefined,
					fixed: undefined,
					draggable: undefined
				}
			])
		);
	};

	_proto5.initComponents = function initComponents() {
		var _PureContainer2$proto2;

		return (_PureContainer2$proto2 = _PureContainer2.prototype.initComponents).call.apply(
			_PureContainer2$proto2,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					tool: this.tool && Widget.create(this.tool)
				}
			])
		);
	};

	_proto5.render = function render(context, instance, key) {
		var data = instance.data;
		return data.text || _PureContainer2.prototype.render.call(this, context, instance, key);
	};

	return GridColumnHeaderCell;
})(PureContainer);

GridColumnHeaderCell.prototype.colSpan = 1;
GridColumnHeaderCell.prototype.rowSpan = 1;
GridColumnHeaderCell.prototype.allowSorting = true;
GridColumnHeaderCell.prototype.styled = true;
GridColumnHeaderCell.prototype.fixed = false; // function initGrouping(grouping) {
//    grouping.forEach((g) => {
//       if (g.caption) g.caption = getSelector(g.caption);
//    });
// }

function copyCellSize(srcTableBody, dstTableBody, applyHeight) {
	if (applyHeight === void 0) {
		applyHeight = true;
	}

	if (!srcTableBody || !dstTableBody) return false;
	var changed = false;

	for (var r = 0; r < dstTableBody.children.length && r < srcTableBody.children.length; r++) {
		var sr = srcTableBody.children[r];
		var dr = dstTableBody.children[r];

		for (var c = 0; c < dr.children.length && c < sr.children.length; c++) {
			var dc = dr.children[c];
			var ws = sr.children[c].offsetWidth + "px";
			if (!changed && dc.style.width != ws) changed = true;
			dc.style.width = dc.style.minWidth = dc.style.maxWidth = ws;
			if (applyHeight) dc.style.height = sr.children[c].offsetHeight + "px";
		}
	}

	return changed;
}

function copyCellSizePrecise(srcTableBody, dstTableBody, applyHeight) {
	if (applyHeight === void 0) {
		applyHeight = true;
	}

	if (!srcTableBody || !dstTableBody) return false;
	var changed = false;

	for (var r = 0; r < dstTableBody.children.length && r < srcTableBody.children.length; r++) {
		var sr = srcTableBody.children[r];
		var dr = dstTableBody.children[r];

		for (var c = 0; c < dr.children.length && c < sr.children.length; c++) {
			var dc = dr.children[c];
			var bounds = sr.children[c].getBoundingClientRect();
			var ws = bounds.width + "px";
			if (!changed && dc.style.width != ws) changed = true;
			dc.style.width = dc.style.minWidth = dc.style.maxWidth = ws;
			if (applyHeight) dc.style.height = bounds.height + "px";
		}
	}

	return changed;
}

function syncHeaderHeights(header1, header2) {
	/**
	 * In the first pass measure all row heights.
	 * In the second pass apply those heights.
	 * Use getBoundingClientRect() for sub-pixel accuracy.
	 */
	if (!header1 || !header2) return;
	var rowCount = Math.max(header1.children.length, header2.children.length);
	var rowHeight = [];

	for (var r = 0; r < rowCount; r++) {
		rowHeight.push(0);
		var tr1 = header1.children[r];
		var tr2 = header2.children[r];

		if (tr1) {
			for (var i = 0; i < tr1.children.length; i++) {
				var td = tr1.children[i];
				var h = td.getBoundingClientRect().height;

				if (td.rowSpan == 1 && h > rowHeight[r]) {
					rowHeight[r] = h;
					break;
				}
			}
		}

		if (tr2) {
			for (var _i = 0; _i < tr2.children.length; _i++) {
				var _td = tr2.children[_i];

				var _h = _td.getBoundingClientRect().height;

				if (_td.rowSpan == 1 && _h > rowHeight[r]) {
					rowHeight[r] = _h;
					break;
				}
			}
		}
	}

	for (var _r = 0; _r < rowCount; _r++) {
		var _tr = header1.children[_r];
		var _tr2 = header2.children[_r];

		if (_tr) {
			for (var _i2 = 0; _i2 < _tr.children.length; _i2++) {
				var _td2 = _tr.children[_i2];
				var _h2 = 0;

				for (var x = 0; x < _td2.rowSpan; x++) {
					_h2 += rowHeight[_r + x];
				}

				_td2.style.height = _h2 + "px";
			}
		}

		if (_tr2) {
			for (var _i3 = 0; _i3 < _tr2.children.length; _i3++) {
				var _td3 = _tr2.children[_i3];
				var _h3 = 0;

				for (var _x = 0; _x < _td3.rowSpan; _x++) {
					_h3 += rowHeight[_r + _x];
				}

				_td3.style.height = _h3 + "px";
			}
		}
	}
}

var AvgHeight = /*#__PURE__*/ (function() {
	function AvgHeight() {
		this.groups = {};
	}

	var _proto6 = AvgHeight.prototype;

	_proto6.add = function add(group, height) {
		var g = this.groups[group];
		if (!g)
			g = this.groups[group] = {
				sum: 0,
				count: 0
			};
		g.sum += height;
		g.count++;
	};

	_proto6.estimate = function estimate(group) {
		var g = this.groups[group];
		if (!g || g.count == 0) return null;
		return Math.round(g.sum / g.count);
	};

	return AvgHeight;
})();

var TreeNode = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(TreeNode, _Container);

	function TreeNode() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = TreeNode.prototype;

	_proto.init = function init() {
		if (this.itemIcon) this.leafIcon = this.itemIcon;

		_Container.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Container$prototype$;

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[
				this,
				{
					level: undefined,
					expanded: undefined,
					leaf: undefined,
					text: undefined,
					loading: undefined,
					icon: undefined,
					leafIcon: undefined,
					openFolderIcon: undefined,
					folderIcon: undefined,
					hideArrow: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.prepareData = function prepareData(context, instance) {
		var data = instance.data;
		data.stateMods = {
			expanded: data.expanded,
			loading: data.loading,
			leaf: data.leaf,
			folder: !data.leaf,
			icon: !this.hideIcon
		};
		data.stateMods["level-" + data.level] = true;

		_Container.prototype.prepareData.call(this, context, instance);
	};

	_proto.render = function render(context, instance, key) {
		var _this = this;

		var data = instance.data,
			widget = instance.widget;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		var icon = data.icon;

		if (!data.icon) {
			if (data.leaf) icon = data.leafIcon;
			else {
				if (data.loading) icon = this.loadingIcon;
				else if (data.expanded) icon = data.openFolderIcon || data.folderIcon;
				else icon = data.folderIcon;
			}
		}

		var arrowIcon = this.arrowIcon;
		if (this.hideIcon && data.loading) arrowIcon = this.loadingIcon;
		return /*#__PURE__*/ jsxs(
			"div",
			{
				className: data.classNames,
				style: data.style,
				children: [
					/*#__PURE__*/ jsxs("div", {
						className: CSS.element(baseClass, "handle"),
						onClick: function onClick(e) {
							return _this.toggle(e, instance);
						},
						onMouseDown: !this.hideIcon ? stopPropagation : undefined,
						children: [
							!data.leaf &&
								!data.hideArrow &&
								Icon.render(arrowIcon, {
									className: CSS.element(baseClass, "arrow")
								}),
							!this.hideIcon &&
								Icon.render(icon, {
									className: CSS.element(baseClass, "icon")
								})
						]
					}),
					/*#__PURE__*/ jsx("div", {
						children: data.text || this.renderChildren(context, instance)
					})
				]
			},
			key
		);
	};

	_proto.toggle = function toggle(e, instance) {
		var data = instance.data;
		if (!data.leaf) instance.set("expanded", !data.expanded);
		e.preventDefault();
		e.stopPropagation();
	};

	return TreeNode;
})(Container);
TreeNode.prototype.baseClass = "treenode";
TreeNode.prototype.itemIcon = "file";
TreeNode.prototype.loadingIcon = "loading";
TreeNode.prototype.folderIcon = "folder";
TreeNode.prototype.openFolderIcon = "folder-open";
TreeNode.prototype.arrowIcon = "drop-down";
TreeNode.prototype.styled = true;
TreeNode.prototype.hideIcon = false;
Widget.alias("treenode", TreeNode);

var Pagination = /*#__PURE__*/ (function(_Widget) {
	_inheritsLoose(Pagination, _Widget);

	function Pagination() {
		return _Widget.apply(this, arguments) || this;
	}

	var _proto = Pagination.prototype;

	_proto.declareData = function declareData() {
		var _Widget$prototype$dec;

		(_Widget$prototype$dec = _Widget.prototype.declareData).call.apply(
			_Widget$prototype$dec,
			[
				this,
				{
					page: undefined,
					length: undefined,
					pageCount: undefined
				}
			].concat(Array.prototype.slice.call(arguments))
		);
	};

	_proto.render = function render(context, instance, key) {
		var _this = this;

		var data = instance.data,
			widget = instance.widget;
		var page = data.page,
			pageCount = data.pageCount,
			length = data.length;
		var CSS = widget.CSS,
			baseClass = widget.baseClass;
		if (!pageCount) pageCount = 1;
		var minPage = Math.max(1, page - Math.floor(length / 2));
		var maxPage = minPage + length - 1;

		if (maxPage > pageCount) {
			maxPage = Math.max(pageCount, length);
			minPage = maxPage - length + 1;
		}

		var nextPageIcon = /*#__PURE__*/ jsx(ForwardIcon, {
			className: CSS.element(baseClass, "icon-next-page")
		});

		var prevPageIcon = /*#__PURE__*/ jsx(ForwardIcon, {
			className: CSS.element(baseClass, "icon-prev-page")
		});

		var pageBtns = [];

		var _loop = function _loop(p) {
			pageBtns.push(
				/*#__PURE__*/ jsx(
					"li",
					{
						className: CSS.element(baseClass, "page", {
							active: page == p,
							disabled:
								(p <= maxPage && p > pageCount) || (p < minPage && page == 1) || (p > maxPage && page + 1 > pageCount)
						}),
						onMouseDown: function onMouseDown(e) {
							e.stopPropagation();
							preventFocusOnTouch(e);
						},
						onClick: function onClick(e) {
							_this.setPage(e, instance, p < minPage ? page - 1 : p > maxPage ? page + 1 : p);
						},
						children: p < minPage ? prevPageIcon : p > maxPage ? nextPageIcon : p
					},
					p < minPage ? "-1" : p > maxPage ? "-2" : p
				)
			);
		};

		for (var p = minPage - 1; p <= maxPage + 1; p++) {
			_loop(p);
		}

		return /*#__PURE__*/ jsx(
			"ul",
			{
				className: data.classNames,
				style: data.style,
				tabIndex: 0,
				onKeyDown: function onKeyDown(e) {
					_this.onKeyDown(e, instance);
				},
				children: pageBtns
			},
			key
		);
	};

	_proto.onKeyDown = function onKeyDown(e, instance) {
		var data = instance.data;

		switch (e.keyCode) {
			case KeyCode.left:
				this.setPage(e, instance, data.page - 1);
				break;

			case KeyCode.right:
				this.setPage(e, instance, data.page + 1);
				break;
		}
	};

	_proto.setPage = function setPage(e, instance, page) {
		e.preventDefault();
		e.stopPropagation();
		var data = instance.data;
		var pageCount = data.pageCount;
		if (page <= pageCount && page > 0) instance.set("page", page);
	};

	return Pagination;
})(Widget);
Pagination.prototype.baseClass = "pagination";
Pagination.prototype.length = 5;
Pagination.prototype.styled = true;
Widget.alias("pagination", Pagination);

var DragSource = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(DragSource, _Container);

	function DragSource() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = DragSource.prototype;

	_proto.init = function init() {
		this.cloneStyle = parseStyle(this.cloneStyle);
		this.draggedStyle = parseStyle(this.draggedStyle);

		_Container.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Container$prototype$;

		(_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					id: undefined,
					data: {
						structured: true
					},
					cloneStyle: {
						structured: true
					},
					cloneClass: {
						structured: true
					},
					draggedClass: {
						structured: true
					},
					draggedStyle: {
						structured: true
					}
				}
			])
		);
	};

	_proto.explore = function explore(context, instance) {
		context.push("dragHandles", (instance.dragHandles = []));

		_Container.prototype.explore.call(this, context, instance);
	};

	_proto.exploreCleanup = function exploreCleanup(context, instance) {
		context.pop("dragHandles");
	};

	_proto.render = function render(context, instance, key) {
		return /*#__PURE__*/ jsx(
			DragSourceComponent,
			{
				instance: instance,
				handled: this.handled || instance.dragHandles.length > 0,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	return DragSource;
})(Container);
DragSource.prototype.styled = true;
DragSource.prototype.baseClass = "dragsource";
DragSource.prototype.hideOnDrag = false;
DragSource.prototype.handled = false;
Widget.alias("dragsource", DragSource);

var DragSourceComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(DragSourceComponent, _VDOM$Component);

	function DragSourceComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			dragged: false
		};
		_this.beginDragDrop = _this.beginDragDrop.bind(_assertThisInitialized(_this));
		_this.onMouseMove = _this.onMouseMove.bind(_assertThisInitialized(_this));
		_this.onMouseDown = _this.onMouseDown.bind(_assertThisInitialized(_this));

		_this.setRef = function(el) {
			_this.el = el;
		};

		return _this;
	}

	var _proto2 = DragSourceComponent.prototype;

	_proto2.render = function render() {
		var _this$props = this.props,
			instance = _this$props.instance,
			children = _this$props.children,
			handled = _this$props.handled;
		var data = instance.data,
			widget = instance.widget;
		var CSS = widget.CSS;
		if (this.state.dragged && widget.hideOnDrag) return null;
		var classes = [
			data.classNames,
			CSS.state({
				dragged: this.state.dragged,
				draggable: !handled
			})
		];
		var style = data.style;

		if (this.state.dragged) {
			if (data.draggedClass) classes.push(data.draggedClass);
			if (data.draggedStyle) style = _objectSpread2(_objectSpread2({}, style), data.draggedStyle);
		}

		var eventHandlers = _objectSpread2(
			_objectSpread2({}, instance.getJsxEventProps()),
			{},
			{
				onTouchStart: this.onMouseDown,
				onMouseDown: this.onMouseDown,
				onTouchMove: this.onMouseMove,
				onMouseMove: this.onMouseMove,
				onTouchEnd: ddMouseUp,
				onMouseUp: ddMouseUp
			}
		);

		delete eventHandlers.onDragStart;
		delete eventHandlers.onDragEnd;
		return /*#__PURE__*/ jsx(
			"div",
			_objectSpread2(
				_objectSpread2(
					{
						id: data.id,
						ref: this.setRef,
						className: CSS.expand(classes),
						style: style
					},
					eventHandlers
				),
				{},
				{
					children: children
				}
			)
		);
	};

	_proto2.onMouseDown = function onMouseDown(e) {
		ddMouseDown(e);

		if (isDragHandleEvent(e) || !this.props.handled) {
			preventFocus(e); //disables text selection in Firefox

			e.stopPropagation();
		}
	};

	_proto2.onMouseMove = function onMouseMove(e) {
		if (ddDetect(e)) {
			if (isDragHandleEvent(e) || !this.props.handled) {
				this.beginDragDrop(e);
			}
		}
	};

	_proto2.beginDragDrop = function beginDragDrop(e) {
		var _this2 = this;

		var instance = this.props.instance;
		var data = instance.data,
			widget = instance.widget,
			store = instance.store;
		if (widget.onDragStart && instance.invoke("onDragStart", e, instance) === false) return;
		initiateDragDrop(
			e,
			{
				sourceEl: this.el,
				source: {
					store: store,
					data: data.data
				},
				clone: {
					widget: widget.clone || widget,
					store: store,
					class: data.cloneClass,
					style: data.cloneStyle,
					cloneContent: !widget.clone,
					matchSize: !widget.clone,
					matchCursorOffset: !widget.clone
				}
			},
			function(e) {
				_this2.setState({
					dragged: false
				});

				if (widget.onDragEnd) instance.invoke("onDragEnd", e, instance);
			}
		);
		this.setState({
			dragged: true
		});
	};

	return DragSourceComponent;
})(VDOM.Component);

var DragHandle = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(DragHandle, _Container);

	function DragHandle() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = DragHandle.prototype;

	_proto.explore = function explore(context, instance) {
		if (isArray(context.dragHandles)) context.dragHandles.push(instance);

		_Container.prototype.explore.call(this, context, instance);
	};

	_proto.render = function render(context, instance, key) {
		var data = instance.data;
		return /*#__PURE__*/ jsx(
			"div",
			{
				className: data.classNames,
				style: data.style,
				onTouchStart: ddHandle,
				onMouseDown: ddHandle,
				onTouchMove: ddHandle,
				onMouseMove: ddHandle,
				onTouchEnd: ddHandle,
				onMouseUp: ddHandle,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	return DragHandle;
})(Container);
DragHandle.prototype.styled = true;
DragHandle.prototype.baseClass = "draghandle";
Widget.alias("draghandle", DragHandle);

var DropZone = /*#__PURE__*/ (function(_Container) {
	_inheritsLoose(DropZone, _Container);

	function DropZone() {
		return _Container.apply(this, arguments) || this;
	}

	var _proto = DropZone.prototype;

	_proto.init = function init() {
		this.overStyle = parseStyle(this.overStyle);
		this.nearStyle = parseStyle(this.nearStyle);
		this.farStyle = parseStyle(this.farStyle);

		if (isNumber(this.inflate)) {
			this.hinflate = this.inflate;
			this.vinflate = this.inflate;
		}

		_Container.prototype.init.call(this);
	};

	_proto.declareData = function declareData() {
		var _Container$prototype$;

		return (_Container$prototype$ = _Container.prototype.declareData).call.apply(
			_Container$prototype$,
			[this].concat(Array.prototype.slice.call(arguments), [
				{
					overClass: {
						structured: true
					},
					nearClass: {
						structured: true
					},
					farClass: {
						structured: true
					},
					overStyle: {
						structured: true
					},
					nearStyle: {
						structured: true
					},
					farStyle: {
						structured: true
					},
					data: {
						structured: true
					}
				}
			])
		);
	};

	_proto.render = function render(context, instance, key) {
		return /*#__PURE__*/ jsx(
			DropZoneComponent,
			{
				instance: instance,
				children: this.renderChildren(context, instance)
			},
			key
		);
	};

	return DropZone;
})(Container);
DropZone.prototype.styled = true;
DropZone.prototype.nearDistance = 0;
DropZone.prototype.hinflate = 0;
DropZone.prototype.vinflate = 0;
DropZone.prototype.baseClass = "dropzone";
Widget.alias("dropzone", DropZone);

var DropZoneComponent = /*#__PURE__*/ (function(_VDOM$Component) {
	_inheritsLoose(DropZoneComponent, _VDOM$Component);

	function DropZoneComponent(props) {
		var _this;

		_this = _VDOM$Component.call(this, props) || this;
		_this.state = {
			state: false
		};
		return _this;
	}

	var _proto2 = DropZoneComponent.prototype;

	_proto2.render = function render() {
		var _this2 = this;

		var _this$props = this.props,
			instance = _this$props.instance,
			children = _this$props.children;
		var data = instance.data,
			widget = instance.widget;
		var CSS = widget.CSS;
		var classes = [data.classNames, CSS.state(this.state.state)];
		var stateStyle;

		switch (this.state.state) {
			case "over":
				classes.push(data.overClass);
				stateStyle = parseStyle(data.overStyle);
				break;

			case "near":
				classes.push(data.nearClass);
				stateStyle = parseStyle(data.nearStyle);
				break;

			case "far":
				classes.push(data.farClass);
				stateStyle = parseStyle(data.farStyle);
				break;
		}

		return /*#__PURE__*/ jsx("div", {
			className: CSS.expand(classes),
			style: _objectSpread2(_objectSpread2(_objectSpread2({}, data.style), this.state.style), stateStyle),
			ref: function ref(el) {
				_this2.el = el;
			},
			children: children
		});
	};

	_proto2.componentDidMount = function componentDidMount() {
		var dragDropOptions = this.context;
		var disabled = dragDropOptions && dragDropOptions.disabled;
		if (!disabled) this.unregister = registerDropZone(this);
	};

	_proto2.componentWillUnmount = function componentWillUnmount() {
		this.unregister && this.unregister();
	};

	_proto2.onDropTest = function onDropTest(e) {
		var instance = this.props.instance;
		var widget = instance.widget;
		return !widget.onDropTest || instance.invoke("onDropTest", e, instance);
	};

	_proto2.onDragStart = function onDragStart(e) {
		this.setState({
			state: "far"
		});
	};

	_proto2.onDragNear = function onDragNear(e) {
		this.setState({
			state: "near"
		});
	};

	_proto2.onDragAway = function onDragAway(e) {
		this.setState({
			state: "far"
		});
	};

	_proto2.onDragLeave = function onDragLeave(e) {
		var nearDistance = this.props.instance.widget.nearDistance;
		this.setState({
			state: nearDistance ? "near" : "far",
			style: null
		});
	};

	_proto2.onDragMeasure = function onDragMeasure(e) {
		var rect = getTopLevelBoundingClientRect(this.el);
		var instance = this.props.instance;
		var widget = instance.widget;
		var _e$cursor = e.cursor,
			clientX = _e$cursor.clientX,
			clientY = _e$cursor.clientY;
		var distance =
			Math.max(0, rect.left - clientX, clientX - rect.right) + Math.max(0, rect.top - clientY, clientY - rect.bottom);

		if (widget.hinflate > 0) {
			rect.left -= widget.hinflate;
			rect.right += widget.hinflate;
		}

		if (widget.vinflate > 0) {
			rect.top -= widget.vinflate;
			rect.bottom += widget.vinflate;
		}

		var nearDistance = widget.nearDistance;
		var over = rect.left <= clientX && clientX < rect.right && rect.top <= clientY && clientY < rect.bottom;
		return {
			over: over && distance,
			near: nearDistance && (over || distance < nearDistance)
		};
	};

	_proto2.onDragEnter = function onDragEnter(e) {
		var instance = this.props.instance;
		var widget = instance.widget;
		var style = {};
		if (widget.matchWidth) style.width = e.source.width + "px";
		if (widget.matchHeight) style.height = e.source.height + "px";
		if (widget.matchMargin) style.margin = e.source.margin.join(" ");
		if (this.state != "over")
			this.setState({
				state: "over",
				style: style
			});
	};

	_proto2.onDragOver = function onDragOver(e) {};

	_proto2.onGetHScrollParent = function onGetHScrollParent() {
		return findScrollableParent(this.el, true);
	};

	_proto2.onGetVScrollParent = function onGetVScrollParent() {
		return findScrollableParent(this.el);
	};

	_proto2.onDrop = function onDrop(e) {
		var instance = this.props.instance;
		var widget = instance.widget;
		if (this.state.state == "over" && widget.onDrop) instance.invoke("onDrop", e, instance);
	};

	_proto2.onDragEnd = function onDragEnd(e) {
		this.setState({
			state: false,
			style: null
		});
	};

	return DropZoneComponent;
})(VDOM.Component);

DropZoneComponent.contextType = DragDropContext;

function enableAllInternalDependencies() {
	enableTooltips();
	enableMsgBoxAlerts();
	enableCultureSensitiveFormatting();
	enableFatArrowExpansion();
}

export {
	Button,
	Calendar,
	CalendarCmp,
	Checkbox,
	ColorField,
	ColorPicker,
	ContextMenu,
	CxCredit,
	DateField,
	DateTimeField,
	DateTimePicker,
	DocumentTitle,
	DragDropContext,
	DragHandle,
	DragSource,
	DropZone,
	Dropdown,
	Field,
	FieldGroup,
	FlexBox,
	FlexCol,
	FlexRow,
	FlyweightTooltipTracker,
	Grid,
	HScroller,
	HScrollerComponent,
	Heading,
	HelpText,
	HighlightedSearchText,
	HtmlElement,
	Icon,
	LabeledContainer,
	Link,
	LinkButton,
	List,
	LookupField,
	Menu,
	MenuItem,
	MenuSpacer,
	MonthField,
	MonthPicker,
	MonthPickerComponent,
	MsgBox,
	NumberField,
	Option,
	Overlay,
	OverlayComponent,
	Pagination,
	ProgressBar,
	Radio,
	RedirectRoute,
	Resizer,
	Route,
	Sandbox,
	Scroller,
	Section,
	Select,
	Slider,
	Submenu,
	Switch,
	Tab,
	TextArea,
	TextField,
	TimeField,
	Toast,
	Tooltip,
	TreeNode,
	UploadButton,
	VScroller,
	ValidationError,
	ValidationGroup,
	Validator,
	Wheel,
	WheelComponent,
	Window,
	autoFocus,
	captureMouse,
	captureMouse2,
	captureMouseOrTouch,
	captureMouseOrTouch2,
	cx,
	ddDetect,
	ddHandle,
	ddMouseDown,
	ddMouseUp,
	enableAllInternalDependencies,
	enableMsgBoxAlerts,
	enableTooltips,
	getCursorPos,
	getFieldTooltip,
	getTooltipInstance,
	initiateDragDrop,
	isDragHandleEvent,
	openContextMenu,
	react,
	registerDropZone,
	tooltipMouseLeave,
	tooltipMouseMove,
	tooltipParentDidMount,
	tooltipParentWillReceiveProps,
	tooltipParentWillUnmount,
	urlAttributes,
	wireTooltipOps
};
