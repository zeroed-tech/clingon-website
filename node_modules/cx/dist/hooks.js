import { getCurrentInstance } from "cx/ui";
import { expression, Ref, stringTemplate, getSelector, computable } from "cx/data";
import { isObject, isArray, isFunction, isString } from "cx/util";

function useStore() {
	return getCurrentInstance().store;
}
function useStoreMethods() {
	return getCurrentInstance().store.getMethods();
}
function ref(info) {
	if (isObject(info)) {
		if (info.bind) return useStore().ref(info.bind, info.defaultValue);
		if (info.get) return info;

		if (info.expr) {
			var store = useStore();
			var selector = expression(info.expr).memoize();
			return new Ref({
				get: function get() {
					return selector(store.getData());
				},
				set: info.set
			});
		}

		if (info.tpl) {
			var _store = useStore();

			var _selector = stringTemplate(info.tpl).memoize();

			return new Ref({
				get: function get() {
					return _selector(_store.getData());
				},
				set: info.set
			});
		}
	}

	return getSelector(info);
}

function useEffect(callback) {
	var destroyCallback = callback();
	if (destroyCallback) getCurrentInstance().subscribeOnDestroy(destroyCallback);
}
function useCleanup(cleanupCallback) {
	var unsubscribe = getCurrentInstance().subscribeOnDestroy(cleanupCallback);
	return function() {
		unsubscribe();
		cleanupCallback();
	};
}

function useInterval(callback, timeout) {
	var timer = setInterval(callback, timeout);
	return useCleanup(function() {
		clearInterval(timer);
	});
}

function addExploreCallback(callback) {
	var instance = getCurrentInstance();
	if (!instance.computables) instance.computables = [];
	instance.computables.push(callback);
	return function() {
		instance.computables = instance.computables.filter(function(cb) {
			return cb !== callback;
		});
	};
}
function useTrigger(args, callback, autoRun) {
	if (!isArray(args)) throw new Error("First argument to addTrigger should be an array.");
	var store = useStore();
	var selector = computable.apply(void 0, args.concat([callback])).memoize(!autoRun && store.getData());
	return addExploreCallback(selector);
}

var key = 0;
function useState(defaultValue) {
	var _instance$setState;

	var instance = getCurrentInstance();
	var storeKey = "_state" + ++key;
	instance.setState(((_instance$setState = {}), (_instance$setState[storeKey] = defaultValue), _instance$setState));
	return new Ref({
		get: function get() {
			return instance.state[storeKey];
		},
		set: function set(value) {
			var _instance$setState2;

			return instance.setState(
				((_instance$setState2 = {}), (_instance$setState2[storeKey] = value), _instance$setState2)
			);
		}
	});
}

function createLoacalStorageRef(key) {
	var store = useStore();
	return new Ref({
		get: function get() {
			var json = localStorage.getItem(key);
			if (!json) return localStorage.hasOwnProperty(key) ? null : undefined;
			return JSON.parse(json);
		},
		set: function set(value) {
			if (value === undefined) localStorage.removeItem(key);
			else localStorage.setItem(key, JSON.stringify(value));
			store.meta.version++;
			store.notify();
		}
	});
}

function resolveCallback(callback, instance) {
	if (isFunction(callback)) return callback;

	if (isString(callback)) {
		if (!instance) instance = getCurrentInstance();
		return function() {
			var _instance;

			for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
				args[_key] = arguments[_key];
			}

			return (_instance = instance).invokeControllerMethod.apply(_instance, [callback].concat(args));
		};
	}
}

function invokeCallback(instance, callback) {
	for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
		args[_key - 2] = arguments[_key];
	}

	if (isString(callback)) return instance.invokeControllerMethod.apply(instance, [callback].concat(args));
	if (isFunction(callback)) return callback.apply(void 0, args);
}

export {
	addExploreCallback,
	createLoacalStorageRef,
	invokeCallback,
	ref,
	resolveCallback,
	useCleanup,
	useEffect,
	useInterval,
	useState,
	useStore,
	useStoreMethods,
	useTrigger
};
